{
  "name": "bamboost",
  "path": "bamboost",
  "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/__init__.py",
  "description": null,
  "docstring": [],
  "attributes": [
    {
      "name": "__author__",
      "annotation": "str",
      "description": null,
      "value": "'florez@ethz.ch'"
    },
    {
      "name": "__copyright__",
      "annotation": "str",
      "description": null,
      "value": "''"
    },
    {
      "name": "__license__",
      "annotation": "str",
      "description": null,
      "value": "'MIT'"
    },
    {
      "name": "__version__",
      "annotation": "str",
      "description": null,
      "value": "version('bamboost')"
    },
    {
      "name": "BAMBOOST_LOGGER",
      "annotation": "logging.logging.Logger",
      "description": null,
      "value": "logging.getLogger('bamboost')"
    },
    {
      "name": "STREAM_HANDLER",
      "annotation": "logging.logging.StreamHandler",
      "description": null,
      "value": "logging.StreamHandler()"
    }
  ],
  "modules": {
    "_typing": {
      "name": "_typing",
      "path": "bamboost._typing",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/_typing.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "StrPath",
          "annotation": "typing_extensions.TypeAlias",
          "description": null,
          "value": "typing.Union[str, pathlib.Path]"
        },
        {
          "name": "_T",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_T')"
        },
        {
          "name": "_U",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_U')"
        },
        {
          "name": "_P",
          "annotation": null,
          "description": null,
          "value": "ParamSpec('_P')"
        },
        {
          "name": "_KT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_KT')"
        },
        {
          "name": "_VT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_VT')"
        },
        {
          "name": "SimulationParameterT",
          "annotation": "typing_extensions.TypeAlias",
          "description": null,
          "value": "typing.MutableMapping[str, typing.Any]"
        },
        {
          "name": "Mutable",
          "annotation": null,
          "description": null,
          "value": "type('Mutable', (_Mutability,), {})"
        },
        {
          "name": "Immutable",
          "annotation": null,
          "description": null,
          "value": "type('Immutable', (_Mutability,), {})"
        },
        {
          "name": "_MT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_MT', bound=_Mutability)"
        }
      ],
      "modules": {},
      "classes": {
        "SimulationMetadataT": {
          "name": "SimulationMetadataT",
          "path": "bamboost._typing.SimulationMetadataT",
          "description": null,
          "parameters": [],
          "attributes": [
            {
              "name": "created_at",
              "annotation": "datetime.datetime",
              "description": null,
              "value": null
            },
            {
              "name": "modified_at",
              "annotation": "datetime.datetime",
              "description": null,
              "value": null
            },
            {
              "name": "description",
              "annotation": "str",
              "description": null,
              "value": null
            },
            {
              "name": "status",
              "annotation": "str",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {},
          "source": "class SimulationMetadataT(TypedDict, total=False):\n    created_at: datetime\n    modified_at: datetime\n    description: str\n    status: str",
          "inherited_members": {}
        },
        "_MutabilitySentinel": {
          "name": "_MutabilitySentinel",
          "path": "bamboost._typing._MutabilitySentinel",
          "description": "A metaclass for creating mutability sentinel types.\n\nThis metaclass is used to create special types that represent mutability\nstates (Mutable and Immutable). It provides custom boolean evaluation and\nstring representation for the created types.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "bamboost._typing._MutabilitySentinel.__new__",
              "signature": "(cls, name, bases, attrs)",
              "description": "Create a new class using this metaclass.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The name of the class being created."
                    }
                  ]
                },
                {
                  "name": "bases",
                  "annotation": "tuple",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The base classes of the class being created."
                    }
                  ]
                },
                {
                  "name": "attrs",
                  "annotation": "dict",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The attributes of the class being created."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "type",
                "annotation": null,
                "description": "The newly created class."
              },
              "docstring": [],
              "source": "def __new__(cls, name, bases, attrs):\n    \"\"\"Create a new class using this metaclass.\n\n    Args:\n        name (str): The name of the class being created.\n        bases (tuple): The base classes of the class being created.\n        attrs (dict): The attributes of the class being created.\n\n    Returns:\n        type: The newly created class.\n    \"\"\"\n    return super().__new__(cls, name, bases, attrs)"
            },
            "__bool__": {
              "name": "__bool__",
              "path": "bamboost._typing._MutabilitySentinel.__bool__",
              "signature": "(self)",
              "description": "Determine the boolean value of the class.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "bool",
                "annotation": null,
                "description": "True if the class is Mutable, False otherwise."
              },
              "docstring": [],
              "source": "def __bool__(self):\n    \"\"\"Determine the boolean value of the class.\n\n    Returns:\n        bool: True if the class is Mutable, False otherwise.\n    \"\"\"\n    return self is Mutable"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._typing._MutabilitySentinel.__repr__",
              "signature": "(self)",
              "description": "Get the string representation of the class.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "str",
                "annotation": null,
                "description": "The name of the class."
              },
              "docstring": [],
              "source": "def __repr__(self):\n    \"\"\"\n    Get the string representation of the class.\n\n    Returns:\n        str: The name of the class.\n    \"\"\"\n    return self.__name__"
            }
          },
          "source": "class _MutabilitySentinel(type):\n    \"\"\"A metaclass for creating mutability sentinel types.\n\n    This metaclass is used to create special types that represent mutability\n    states (Mutable and Immutable). It provides custom boolean evaluation and\n    string representation for the created types.\n    \"\"\"\n\n    def __new__(cls, name, bases, attrs):\n        \"\"\"Create a new class using this metaclass.\n\n        Args:\n            name (str): The name of the class being created.\n            bases (tuple): The base classes of the class being created.\n            attrs (dict): The attributes of the class being created.\n\n        Returns:\n            type: The newly created class.\n        \"\"\"\n        return super().__new__(cls, name, bases, attrs)\n\n    def __bool__(self):\n        \"\"\"Determine the boolean value of the class.\n\n        Returns:\n            bool: True if the class is Mutable, False otherwise.\n        \"\"\"\n        return self is Mutable\n\n    def __repr__(self):\n        \"\"\"\n        Get the string representation of the class.\n\n        Returns:\n            str: The name of the class.\n        \"\"\"\n        return self.__name__",
          "inherited_members": {}
        },
        "_Mutability": {
          "name": "_Mutability",
          "path": "bamboost._typing._Mutability",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {},
          "source": "class _Mutability(metaclass=_MutabilitySentinel):\n    pass",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "constants": {
      "name": "constants",
      "path": "bamboost.constants",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/constants.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "UID_SEPARATOR",
          "annotation": null,
          "description": null,
          "value": "':'"
        },
        {
          "name": "HDF_DATA_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'data.h5'"
        },
        {
          "name": "XDMF_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'data.xdmf'"
        },
        {
          "name": "RUN_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'run.sh'"
        },
        {
          "name": "PATH_DATA",
          "annotation": null,
          "description": null,
          "value": "'data'"
        },
        {
          "name": "RELATIVE_PATH_FIELD_DATA",
          "annotation": null,
          "description": null,
          "value": "'fields'"
        },
        {
          "name": "RELATIVE_PATH_SCALAR_DATA",
          "annotation": null,
          "description": null,
          "value": "'globals'"
        },
        {
          "name": "PATH_PARAMETERS",
          "annotation": null,
          "description": null,
          "value": "'.parameters'"
        },
        {
          "name": "PATH_MESH",
          "annotation": null,
          "description": null,
          "value": "'.mesh'"
        },
        {
          "name": "PATH_LINKS",
          "annotation": null,
          "description": null,
          "value": "'.links'"
        },
        {
          "name": "PATH_USERDATA",
          "annotation": null,
          "description": null,
          "value": "'.userdata'"
        },
        {
          "name": "DS_NAME_TIMESTEPS",
          "annotation": null,
          "description": null,
          "value": "'.map'"
        },
        {
          "name": "DEFAULT_MESH_NAME",
          "annotation": null,
          "description": null,
          "value": "'default'"
        },
        {
          "name": "TABLENAME_COLLECTIONS",
          "annotation": null,
          "description": null,
          "value": "'collections'"
        },
        {
          "name": "TABLENAME_SIMULATIONS",
          "annotation": null,
          "description": null,
          "value": "'simulations'"
        },
        {
          "name": "TABLENAME_PARAMETERS",
          "annotation": null,
          "description": null,
          "value": "'parameters'"
        }
      ],
      "modules": {},
      "classes": {},
      "functions": {}
    },
    "utilities": {
      "name": "utilities",
      "path": "bamboost.utilities",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/utilities.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "_R",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_R')"
        }
      ],
      "modules": {},
      "classes": {
        "PathSet": {
          "name": "PathSet",
          "path": "bamboost.utilities.PathSet",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "iterable",
              "annotation": "typing.Optional[typing.Iterable[bamboost._typing.StrPath]]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost.utilities.PathSet.__init__",
              "signature": "(self, iterable=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "iterable",
                  "annotation": "typing.Optional[typing.Iterable[bamboost._typing.StrPath]]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, iterable: Optional[Iterable[StrPath]] = None) -> None:\n    super().__init__(Path(arg).resolve().expanduser() for arg in iterable or [])"
            },
            "add": {
              "name": "add",
              "path": "bamboost.utilities.PathSet.add",
              "signature": "(self, element) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "element",
                  "annotation": "typing.Union[str, pathlib.Path]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def add(self, element: Union[str, Path], /) -> None:\n    return super().add(Path(element).resolve().expanduser())"
            }
          },
          "source": "class PathSet(set[Path]):\n    def __init__(self, iterable: Optional[Iterable[StrPath]] = None) -> None:\n        super().__init__(Path(arg).resolve().expanduser() for arg in iterable or [])\n\n    def add(self, element: Union[str, Path], /) -> None:\n        return super().add(Path(element).resolve().expanduser())",
          "inherited_members": {}
        }
      },
      "functions": {
        "maybe_apply": {
          "name": "maybe_apply",
          "path": "bamboost.utilities.maybe_apply",
          "signature": "(func) -> Callable[[Optional[_T]], Optional[_U]]",
          "description": null,
          "parameters": [
            {
              "name": "func",
              "annotation": "typing.Callable[[bamboost._typing._T], bamboost._typing._U]",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def maybe_apply(func: Callable[[_T], _U]) -> Callable[[Optional[_T]], Optional[_U]]:\n    def function(x: Optional[_T]) -> Optional[_U]:\n        if x is not None:\n            return func(x)\n\n    return function"
        },
        "compose_while_not_none": {
          "name": "compose_while_not_none",
          "path": "bamboost.utilities.compose_while_not_none",
          "signature": "(first_func, *funcs) -> Callable[_P, Optional[Any]]",
          "description": "Compose multiple functions into a single function. The output of each\nfunction is passed as the input to the next function. The functions are\napplied from left to right. If a function returns `None`, the next function\nis not called and `None` is returned.",
          "parameters": [
            {
              "name": "first_func",
              "annotation": "typing.Callable[bamboost._typing._P, typing.Any]",
              "description": null,
              "value": null
            },
            {
              "name": "funcs",
              "annotation": "typing.Callable",
              "description": null,
              "value": "()"
            }
          ],
          "returns": {
            "name": "Callable",
            "annotation": "typing.Callable[bamboost._typing._P, typing.Optional[typing.Any]]",
            "description": "The composed function."
          },
          "docstring": [],
          "source": "def compose_while_not_none(\n    first_func: Callable[_P, Any], *funcs: Callable\n) -> Callable[_P, Optional[Any]]:\n    \"\"\"Compose multiple functions into a single function. The output of each\n    function is passed as the input to the next function. The functions are\n    applied from left to right. If a function returns `None`, the next function\n    is not called and `None` is returned.\n\n    Args:\n        *funcs: Functions to compose.\n\n    Returns:\n        Callable: The composed function.\n    \"\"\"\n    funcs = (first_func, *funcs)\n\n    def function(f: Callable, g: Callable) -> Callable:\n        def composed(*x: Any) -> Any:\n            result = f(*x)\n            if result is None:\n                return None\n            else:\n                return g(result)\n\n        return composed\n\n    return reduce(function, funcs)"
        },
        "full_class_name": {
          "name": "full_class_name",
          "path": "bamboost.utilities.full_class_name",
          "signature": "(_cls)",
          "description": "Returns the full name of a class, including the module name.",
          "parameters": [
            {
              "name": "_cls",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def full_class_name(_cls):\n    \"\"\"Returns the full name of a class, including the module name.\"\"\"\n    module = _cls.__module__\n    if module is None or module == str.__class__.__module__:\n        return _cls.__qualname__\n    return \".\".join([module, _cls.__qualname__])"
        }
      }
    },
    "plugins": {
      "name": "plugins",
      "path": "bamboost.plugins",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/plugins.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "_T_PluginOpts",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_T_PluginOpts', bound=BasePluginOpts)"
        },
        {
          "name": "_active",
          "annotation": "set[bamboost.plugins.Plugin]",
          "description": null,
          "value": "set()"
        }
      ],
      "modules": {},
      "classes": {
        "ElligibleForPlugin": {
          "name": "ElligibleForPlugin",
          "path": "bamboost.plugins.ElligibleForPlugin",
          "description": "A base class for all classes that should be available to be replaced by plugins.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "bamboost.plugins.ElligibleForPlugin.__new__",
              "signature": "(cls, *args, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __new__(cls, *args, **kwargs):\n    # hook up plugins here\n    for plugin in _active:\n        if cls in plugin.override_components:\n            return super().__new__(plugin.override_components[cls])\n\n    return super().__new__(cls)"
            }
          },
          "source": "class ElligibleForPlugin:\n    \"\"\"A base class for all classes that should be available to be replaced by plugins.\"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        # hook up plugins here\n        for plugin in _active:\n            if cls in plugin.override_components:\n                return super().__new__(plugin.override_components[cls])\n\n        return super().__new__(cls)",
          "inherited_members": {}
        },
        "PluginComponent": {
          "name": "PluginComponent",
          "path": "bamboost.plugins.PluginComponent",
          "description": null,
          "parameters": [],
          "attributes": [
            {
              "name": "__plugin__",
              "annotation": "bamboost.plugins.Plugin",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init_subclass__": {
              "name": "__init_subclass__",
              "path": "bamboost.plugins.PluginComponent.__init_subclass__",
              "signature": "(cls, **kwargs) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init_subclass__(cls, **kwargs) -> None:\n    cls.__replace_base__ = kwargs.pop(\"replace_base\", False)\n    return super().__init_subclass__()"
            }
          },
          "source": "class PluginComponent:\n    __plugin__: ClassVar[Plugin]\n\n    def __init_subclass__(cls, **kwargs) -> None:\n        cls.__replace_base__ = kwargs.pop(\"replace_base\", False)\n        return super().__init_subclass__()",
          "inherited_members": {}
        },
        "PluginMeta": {
          "name": "PluginMeta",
          "path": "bamboost.plugins.PluginMeta",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "bamboost.plugins.PluginMeta.__new__",
              "signature": "(mcs, name, bases, namespace, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "mcs",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "bases",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "namespace",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __new__(mcs, name, bases, namespace, **kwargs):\n    # Collect and register plugin components\n    _components = []\n    _replacements: dict[type, type] = {}\n\n    for attr_name, attr_value in namespace.items():\n        if isinstance(attr_value, type) and issubclass(attr_value, PluginComponent):\n            _components.append(attr_value)\n\n            # Handle replacement if `replace_base=True` is set\n            if getattr(attr_value, \"__replace_base__\", False):\n                for base in attr_value.__bases__:\n                    if issubclass(base, ElligibleForPlugin):\n                        _replacements[base] = attr_value\n                        break\n                else:\n                    raise ValueError(\n                        f\"Could not find a base class that is elligible for replacement by the plugin API (for {attr_value})\"\n                    )\n\n    namespace[\"components\"] = _components\n    namespace[\"override_components\"] = _replacements\n\n    return super().__new__(mcs, name, bases, namespace)"
            }
          },
          "source": "class PluginMeta(type):\n    def __new__(mcs, name, bases, namespace, **kwargs):\n        # Collect and register plugin components\n        _components = []\n        _replacements: dict[type, type] = {}\n\n        for attr_name, attr_value in namespace.items():\n            if isinstance(attr_value, type) and issubclass(attr_value, PluginComponent):\n                _components.append(attr_value)\n\n                # Handle replacement if `replace_base=True` is set\n                if getattr(attr_value, \"__replace_base__\", False):\n                    for base in attr_value.__bases__:\n                        if issubclass(base, ElligibleForPlugin):\n                            _replacements[base] = attr_value\n                            break\n                    else:\n                        raise ValueError(\n                            f\"Could not find a base class that is elligible for replacement by the plugin API (for {attr_value})\"\n                        )\n\n        namespace[\"components\"] = _components\n        namespace[\"override_components\"] = _replacements\n\n        return super().__new__(mcs, name, bases, namespace)",
          "inherited_members": {}
        },
        "BasePluginOpts": {
          "name": "BasePluginOpts",
          "path": "bamboost.plugins.BasePluginOpts",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {},
          "source": "class BasePluginOpts(TypedDict):\n    pass",
          "inherited_members": {}
        },
        "Plugin": {
          "name": "Plugin",
          "path": "bamboost.plugins.Plugin",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "opts",
              "annotation": "bamboost.plugins._T_PluginOpts",
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": null
            },
            {
              "name": "override_components",
              "annotation": "dict[type, type]",
              "description": null,
              "value": null
            },
            {
              "name": "components",
              "annotation": "list[typing.Type[bamboost.plugins.PluginComponent]]",
              "description": null,
              "value": null
            },
            {
              "name": "opts",
              "annotation": null,
              "description": null,
              "value": "bamboost.plugins.Plugin(opts)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost.plugins.Plugin.__init__",
              "signature": "(self, opts) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "opts",
                  "annotation": "bamboost.plugins._T_PluginOpts",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, opts: _T_PluginOpts) -> None:\n    self.opts = opts\n\n    # remember the source plugin for each class\n    for cls in self.components:\n        cls.__plugin__ = self"
            }
          },
          "source": "class Plugin(Generic[_T_PluginOpts], metaclass=PluginMeta):\n    name: str\n    override_components: dict[type, type]\n    components: list[Type[PluginComponent]]\n\n    def __init__(self, opts: _T_PluginOpts) -> None:\n        self.opts = opts\n\n        # remember the source plugin for each class\n        for cls in self.components:\n            cls.__plugin__ = self",
          "inherited_members": {}
        }
      },
      "functions": {
        "load": {
          "name": "load",
          "path": "bamboost.plugins.load",
          "signature": "(*plugins) -> None",
          "description": null,
          "parameters": [
            {
              "name": "plugins",
              "annotation": "bamboost.plugins.Plugin",
              "description": null,
              "value": "()"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def load(*plugins: Plugin) -> None:\n    _active.update(plugins)"
        },
        "unload": {
          "name": "unload",
          "path": "bamboost.plugins.unload",
          "signature": "() -> None",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def unload() -> None:\n    _active.clear()"
        }
      }
    },
    "_config": {
      "name": "_config",
      "path": "bamboost._config",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/_config.py",
      "description": "This module manages configuration options for bamboost. It supports loading configuration\nfrom a global file (`~/.config/bamboost/config.toml`) and a project configuration in the\nstandard (`pyproject.toml`).\n\nThe configuration is structured using dataclasses, allowing hierarchical and\ntype-validated configuration handling.\n\nKey Features:\n- Detects the root directory of the project based on common anchor files.\n- Reads configuration from global and project-specific TOML files.\n- Provides structured access to configuration values via dataclasses.\n- Supports nested dictionary updates for merging configuration sources.\n- Includes an index system for managing paths and database settings.",
      "docstring": [],
      "attributes": [
        {
          "name": "__all__",
          "annotation": null,
          "description": null,
          "value": "['config']"
        },
        {
          "name": "CONFIG_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.config/bamboost').expanduser()"
        },
        {
          "name": "CONFIG_FILE",
          "annotation": null,
          "description": null,
          "value": "CONFIG_DIR.joinpath('config-next.toml')"
        },
        {
          "name": "LOCAL_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.local/share/bamboost').expanduser()"
        },
        {
          "name": "CACHE_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.cache/bamboost-next').expanduser()"
        },
        {
          "name": "DATABASE_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'bamboost-next.sqlite'"
        },
        {
          "name": "DEFAULT_EXCLUDE_DIRS",
          "annotation": "set[str]",
          "description": null,
          "value": "{'.git', '.hg', '.svn', '.bzr', '.cvs', '.venv', 'venv', 'env', '.tox', '.nox', 'node_modules', '.yarn', '.pnp', 'build', 'dist', '.eggs', '.idea', '.vscode', '.vs', '__pycache__', '.mypy_cache', '.pytest_cache', '.ruff_cache', '.cache', '.cargo', '.gocache', '.next', '.nuxt', '.terser-cache', '.parcel-cache', '.vercel', '.serverless', '.aws-sam', '.terraform', 'vendor'}"
        },
        {
          "name": "config",
          "description": [
            {
              "kind": "text",
              "value": "The main configuration instance containing paths, options, and index\nsettings."
            }
          ],
          "annotation": "bamboost._config._Config",
          "value": "_Config()"
        }
      ],
      "modules": {},
      "classes": {
        "_Base": {
          "name": "_Base",
          "path": "bamboost._config._Base",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "_field_aliases",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "docstring": [],
          "functions": {
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._config._Base.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    s = \"\"\n    max_length = max(len(field.name) for field in fields(self))\n    for field in fields(self):\n        s += f\"{field.name:<{max_length + 1}}: {getattr(self, field.name)}\\n\"\n    return s"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "bamboost._config._Base.__getitem__",
              "signature": "(self, key) -> Any",
              "description": "Access the configuration options by key, separated by dots.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(self, key: str) -> Any:\n    \"\"\"Access the configuration options by key, separated by dots.\"\"\"\n    try:\n        current_selection = self\n        for attr in key.split(\".\"):\n            current_selection = getattr(current_selection, attr)\n        return current_selection\n    except KeyError:\n        raise KeyError(f\"Invalid key path: '{key}'\")"
            },
            "__setitem__": {
              "name": "__setitem__",
              "path": "bamboost._config._Base.__setitem__",
              "signature": "(self, key, value) -> None",
              "description": "Set the configuration options by key, separated by dots.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "typing.Any",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __setitem__(self, key: str, value: Any) -> None:\n    \"\"\"Set the configuration options by key, separated by dots.\"\"\"\n    current_selection = self\n    keys = key.split(\".\")\n    for attr in keys[:-1]:\n        current_selection = getattr(current_selection, attr)\n    setattr(current_selection, keys[-1], value)"
            },
            "__getattr__": {
              "name": "__getattr__",
              "path": "bamboost._config._Base.__getattr__",
              "signature": "(self, name) -> Any",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getattr__(self, name: str) -> Any:\n    # handle aliases\n    actual_name = self._field_aliases.get(name, name)\n    return super().__getattribute__(actual_name)"
            },
            "_ipython_key_completions_": {
              "name": "_ipython_key_completions_",
              "path": "bamboost._config._Base._ipython_key_completions_",
              "signature": "(self) -> Generator[str, None, None]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _ipython_key_completions_(self) -> Generator[str, None, None]:\n    for key, obj in self.__dict__.items():\n        yield key\n        for subkey in getattr(obj, \"__dict__\", {}).keys():\n            yield f\"{key}.{subkey}\""
            },
            "from_dict": {
              "name": "from_dict",
              "path": "bamboost._config._Base.from_dict",
              "signature": "(cls, config, **kwargs) -> Self",
              "description": "Create an instance of the dataclass from a dictionary of\nconfiguration values.\n\nThis method performs the following steps:\n1. Identifies valid field names and aliases.\n2. Logs any unknown configuration keys.\n3. Filters the input dictionary to include only valid keys and aliases.\n4. Validates the types of the configuration values.\n5. Creates an instance of the class with the filtered and validated configuration.\n6. Logs any missing fields that are using default values.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "config",
                  "annotation": "dict",
                  "description": [
                    {
                      "kind": "text",
                      "value": "A dictionary containing configuration key-value pairs."
                    }
                  ]
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing_extensions.Self",
                "description": "An instance of the class initialized with the provided configuration."
              },
              "docstring": [
                {
                  "kind": "raises",
                  "value": [
                    {
                      "annotation": "No exceptions are raised, but various warnings and errors are logged",
                      "description": ""
                    }
                  ]
                },
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "note",
                    "description": "- Invalid type values are removed from the configuration.\n- Aliases are resolved to their corresponding field names."
                  },
                  "title": "Note"
                }
              ],
              "source": "@classmethod\ndef from_dict(cls, config: dict, **kwargs) -> \"Self\":\n    \"\"\"Create an instance of the dataclass from a dictionary of\n    configuration values.\n\n    This method performs the following steps:\n    1. Identifies valid field names and aliases.\n    2. Logs any unknown configuration keys.\n    3. Filters the input dictionary to include only valid keys and aliases.\n    4. Validates the types of the configuration values.\n    5. Creates an instance of the class with the filtered and validated configuration.\n    6. Logs any missing fields that are using default values.\n\n    Args:\n        config: A dictionary containing configuration key-value pairs.\n        **kwargs: Additional keyword arguments to pass to the class constructor\n\n    Returns:\n        An instance of the class initialized with the provided configuration.\n\n    Raises:\n        No exceptions are raised, but various warnings and errors are logged:\n        - Unknown configuration keys are logged as info.\n        - Invalid types for configuration values are logged as errors.\n        - Type checking errors are logged as info.\n        - Missing fields (using defaults) are logged as info.\n\n    Note:\n        - Invalid type values are removed from the configuration.\n        - Aliases are resolved to their corresponding field names.\n    \"\"\"\n    # Get the valid field names\n    valid_fields = {f.name for f in fields(cls)}\n    aliases = set(cls._field_aliases.keys())\n\n    # Check for unknown keys\n    unknown_keys = set(config) - valid_fields - aliases\n    for key in unknown_keys:\n        log.info(f\"Unknown config key: {key}\")\n\n    # Filter the input dictionary to only include valid keys\n    filtered_config = {k: v for k, v in config.items() if k in valid_fields}\n    filtered_config.update(\n        {cls._field_aliases[k]: v for k, v in config.items() if k in aliases}\n    )\n\n    # Validate type of user and project config values\n    resolved_type_hints = get_type_hints(cls)\n    for field_def in fields(cls):\n        if field_def.name in filtered_config:\n            try:\n                if not isinstance(\n                    filtered_config[field_def.name],\n                    resolved_type_hints[field_def.name],\n                ):\n                    log.error(\n                        (\n                            f\"Invalid type for config key '{field_def.name}': {filtered_config[field_def.name]}. \"\n                            f\"Requires {field_def.type} \"\n                        )\n                    )\n                    # If the type is invalid, remove the key\n                    filtered_config.pop(field_def.name)\n            except TypeError:\n                # An error occurred while checking the type, keep the key but log a warning\n                log.info(\n                    f\"Error checking type for config key '{field_def.name}': {filtered_config[field_def.name]}\"\n                )\n\n    # Create the instance\n    instance = cls(**filtered_config, **kwargs)\n\n    # Check for missing fields (defaults used)\n    for field_def in fields(cls):\n        if field_def.name not in filtered_config:\n            log.info(\n                f\"Config key '{field_def.name}' not set; using default: {getattr(instance, field_def.name)}\"\n            )\n\n    return instance"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Base.__init__",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass _Base:\n    _field_aliases = {}\n\n    def __repr__(self) -> str:\n        s = \"\"\n        max_length = max(len(field.name) for field in fields(self))\n        for field in fields(self):\n            s += f\"{field.name:<{max_length + 1}}: {getattr(self, field.name)}\\n\"\n        return s\n\n    def __getitem__(self, key: str) -> Any:\n        \"\"\"Access the configuration options by key, separated by dots.\"\"\"\n        try:\n            current_selection = self\n            for attr in key.split(\".\"):\n                current_selection = getattr(current_selection, attr)\n            return current_selection\n        except KeyError:\n            raise KeyError(f\"Invalid key path: '{key}'\")\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        \"\"\"Set the configuration options by key, separated by dots.\"\"\"\n        current_selection = self\n        keys = key.split(\".\")\n        for attr in keys[:-1]:\n            current_selection = getattr(current_selection, attr)\n        setattr(current_selection, keys[-1], value)\n\n    def __getattr__(self, name: str) -> Any:\n        # handle aliases\n        actual_name = self._field_aliases.get(name, name)\n        return super().__getattribute__(actual_name)\n\n    def _ipython_key_completions_(self) -> Generator[str, None, None]:\n        for key, obj in self.__dict__.items():\n            yield key\n            for subkey in getattr(obj, \"__dict__\", {}).keys():\n                yield f\"{key}.{subkey}\"\n\n    @classmethod\n    def from_dict(cls, config: dict, **kwargs) -> \"Self\":\n        \"\"\"Create an instance of the dataclass from a dictionary of\n        configuration values.\n\n        This method performs the following steps:\n        1. Identifies valid field names and aliases.\n        2. Logs any unknown configuration keys.\n        3. Filters the input dictionary to include only valid keys and aliases.\n        4. Validates the types of the configuration values.\n        5. Creates an instance of the class with the filtered and validated configuration.\n        6. Logs any missing fields that are using default values.\n\n        Args:\n            config: A dictionary containing configuration key-value pairs.\n            **kwargs: Additional keyword arguments to pass to the class constructor\n\n        Returns:\n            An instance of the class initialized with the provided configuration.\n\n        Raises:\n            No exceptions are raised, but various warnings and errors are logged:\n            - Unknown configuration keys are logged as info.\n            - Invalid types for configuration values are logged as errors.\n            - Type checking errors are logged as info.\n            - Missing fields (using defaults) are logged as info.\n\n        Note:\n            - Invalid type values are removed from the configuration.\n            - Aliases are resolved to their corresponding field names.\n        \"\"\"\n        # Get the valid field names\n        valid_fields = {f.name for f in fields(cls)}\n        aliases = set(cls._field_aliases.keys())\n\n        # Check for unknown keys\n        unknown_keys = set(config) - valid_fields - aliases\n        for key in unknown_keys:\n            log.info(f\"Unknown config key: {key}\")\n\n        # Filter the input dictionary to only include valid keys\n        filtered_config = {k: v for k, v in config.items() if k in valid_fields}\n        filtered_config.update(\n            {cls._field_aliases[k]: v for k, v in config.items() if k in aliases}\n        )\n\n        # Validate type of user and project config values\n        resolved_type_hints = get_type_hints(cls)\n        for field_def in fields(cls):\n            if field_def.name in filtered_config:\n                try:\n                    if not isinstance(\n                        filtered_config[field_def.name],\n                        resolved_type_hints[field_def.name],\n                    ):\n                        log.error(\n                            (\n                                f\"Invalid type for config key '{field_def.name}': {filtered_config[field_def.name]}. \"\n                                f\"Requires {field_def.type} \"\n                            )\n                        )\n                        # If the type is invalid, remove the key\n                        filtered_config.pop(field_def.name)\n                except TypeError:\n                    # An error occurred while checking the type, keep the key but log a warning\n                    log.info(\n                        f\"Error checking type for config key '{field_def.name}': {filtered_config[field_def.name]}\"\n                    )\n\n        # Create the instance\n        instance = cls(**filtered_config, **kwargs)\n\n        # Check for missing fields (defaults used)\n        for field_def in fields(cls):\n            if field_def.name not in filtered_config:\n                log.info(\n                    f\"Config key '{field_def.name}' not set; using default: {getattr(instance, field_def.name)}\"\n                )\n\n        return instance",
          "inherited_members": {}
        },
        "_Paths": {
          "name": "_Paths",
          "path": "bamboost._config._Paths",
          "description": "Paths used by bamboost.\n\nThis dataclass contains the paths used by bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "localDir",
              "annotation": "bamboost._typing.StrPath",
              "description": null,
              "value": "bamboost._config.LOCAL_DIR"
            },
            {
              "name": "cacheDir",
              "annotation": "bamboost._typing.StrPath",
              "description": null,
              "value": "bamboost._config.CACHE_DIR"
            }
          ],
          "attributes": [
            {
              "name": "localDir",
              "description": [
                {
                  "kind": "text",
                  "value": "The directory where the local data is stored."
                }
              ],
              "annotation": "bamboost._typing.StrPath",
              "value": "field(default=LOCAL_DIR)"
            },
            {
              "name": "cacheDir",
              "description": [
                {
                  "kind": "text",
                  "value": "The directory where the cache is stored."
                }
              ],
              "annotation": "bamboost._typing.StrPath",
              "value": "field(default=CACHE_DIR)"
            }
          ],
          "docstring": [],
          "functions": {
            "__setattr__": {
              "name": "__setattr__",
              "path": "bamboost._config._Paths.__setattr__",
              "signature": "(self, name, value) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "typing.Any",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __setattr__(self, name: str, value: Any, /) -> None:\n    if isinstance(value, str):\n        value = Path(value).expanduser()\n    super().__setattr__(name, value)"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Paths.__init__",
              "signature": "(self, localDir=LOCAL_DIR, cacheDir=CACHE_DIR) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "localDir",
                  "annotation": "bamboost._typing.StrPath",
                  "description": null,
                  "value": "bamboost._config.LOCAL_DIR"
                },
                {
                  "name": "cacheDir",
                  "annotation": "bamboost._typing.StrPath",
                  "description": null,
                  "value": "bamboost._config.CACHE_DIR"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _Paths(_Base):\n    \"\"\"Paths used by bamboost.\n\n    This dataclass contains the paths used by bamboost.\n\n    Attributes:\n        localDir: The directory where the local data is stored.\n        cacheDir: The directory where the cache is stored.\n    \"\"\"\n\n    localDir: StrPath = field(default=LOCAL_DIR)\n    cacheDir: StrPath = field(default=CACHE_DIR)\n\n    def __setattr__(self, name: str, value: Any, /) -> None:\n        if isinstance(value, str):\n            value = Path(value).expanduser()\n        super().__setattr__(name, value)",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_Options": {
          "name": "_Options",
          "path": "bamboost._config._Options",
          "description": "Core options for bamboost.\n\nThis dataclass contains the core options for bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "mpi",
              "annotation": "bool",
              "description": null,
              "value": "importlib.importlib.util.importlib.util.find_spec('mpi4py') is not None"
            },
            {
              "name": "sortTableKey",
              "annotation": "str",
              "description": null,
              "value": "'time_stamp'"
            },
            {
              "name": "sortTableOrder",
              "annotation": "str",
              "description": null,
              "value": "'desc'"
            },
            {
              "name": "log_file_lock_severity",
              "annotation": "typing.Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
              "description": null,
              "value": "'WARNING'"
            },
            {
              "name": "log_root_only",
              "annotation": "bool",
              "description": null,
              "value": "False"
            }
          ],
          "attributes": [
            {
              "name": "mpi",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, the mpi4py package is available and used."
                }
              ],
              "annotation": "bool",
              "value": "field(default=importlib.util.find_spec('mpi4py') is not None)"
            },
            {
              "name": "sortTableKey",
              "description": [
                {
                  "kind": "text",
                  "value": "The default key to sort the table by."
                }
              ],
              "annotation": "str",
              "value": "field(default='time_stamp')"
            },
            {
              "name": "sortTableOrder",
              "description": [
                {
                  "kind": "text",
                  "value": "The default order to sort the table by."
                }
              ],
              "annotation": "str",
              "value": "field(default='desc')"
            },
            {
              "name": "log_file_lock_severity",
              "annotation": "typing.Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
              "description": [
                {
                  "kind": "text",
                  "value": "The severity level for the log file lock."
                }
              ],
              "value": "field(default='WARNING')"
            },
            {
              "name": "log_root_only",
              "annotation": "bool",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, only the root logger is used."
                }
              ],
              "value": "False"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Options.__init__",
              "signature": "(self, mpi=importlib.util.find_spec('mpi4py') is not None, sortTableKey='time_stamp', sortTableOrder='desc', log_file_lock_severity='WARNING', log_root_only=False) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "mpi",
                  "annotation": "bool",
                  "description": null,
                  "value": "importlib.importlib.util.importlib.util.find_spec('mpi4py') is not None"
                },
                {
                  "name": "sortTableKey",
                  "annotation": "str",
                  "description": null,
                  "value": "'time_stamp'"
                },
                {
                  "name": "sortTableOrder",
                  "annotation": "str",
                  "description": null,
                  "value": "'desc'"
                },
                {
                  "name": "log_file_lock_severity",
                  "annotation": "typing.Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
                  "description": null,
                  "value": "'WARNING'"
                },
                {
                  "name": "log_root_only",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _Options(_Base):\n    \"\"\"Core options for bamboost.\n\n    This dataclass contains the core options for bamboost.\n\n    Attributes:\n        mpi: If True, the mpi4py package is available and used.\n        sortTableKey: The default key to sort the table by.\n        sortTableOrder: The default order to sort the table by.\n    \"\"\"\n\n    mpi: bool = field(default=importlib.util.find_spec(\"mpi4py\") is not None)\n    sortTableKey: str = field(default=\"time_stamp\")\n    sortTableOrder: str = field(default=\"desc\")\n\n    log_file_lock_severity: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"] = (\n        field(default=\"WARNING\")\n    )\n    \"\"\"The severity level for the log file lock.\"\"\"\n\n    log_root_only: bool = False\n    \"\"\"If True, only the root logger is used.\"\"\"",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_IndexOptions": {
          "name": "_IndexOptions",
          "path": "bamboost._config._IndexOptions",
          "description": "Index options for bamboost.\n\nThis dataclass contains the index options for bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "searchPaths",
              "annotation": "typing.Iterable[typing.Union[str, pathlib.Path]]",
              "description": null,
              "value": "lambda: PathSet([Path('~').expanduser()])()"
            },
            {
              "name": "excludeDirs",
              "annotation": "typing.Iterable[str]",
              "description": null,
              "value": "lambda: DEFAULT_EXCLUDE_DIRS()"
            },
            {
              "name": "extendDefaultExcludeDirs",
              "annotation": "typing.Iterable[str] | None",
              "description": null,
              "value": "None"
            },
            {
              "name": "syncTables",
              "annotation": "bool",
              "description": null,
              "value": "True"
            },
            {
              "name": "convertArrays",
              "annotation": "bool",
              "description": null,
              "value": "True"
            },
            {
              "name": "databaseFileName",
              "annotation": "str",
              "description": null,
              "value": "bamboost._config.DATABASE_FILE_NAME"
            },
            {
              "name": "isolated",
              "annotation": "bool",
              "description": null,
              "value": "False"
            },
            {
              "name": "projectDir",
              "annotation": "typing.Optional[pathlib.Path]",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "_field_aliases",
              "annotation": null,
              "description": null,
              "value": "{'paths': 'searchPaths'}"
            },
            {
              "name": "searchPaths",
              "description": [
                {
                  "kind": "text",
                  "value": "A list of paths to index."
                }
              ],
              "annotation": "typing.Iterable[typing.Union[str, pathlib.Path]]",
              "value": "field(default_factory=lambda: PathSet([Path('~').expanduser()]))"
            },
            {
              "name": "excludeDirs",
              "annotation": "typing.Iterable[str]",
              "description": [
                {
                  "kind": "text",
                  "value": "The list of directory names to exclude from the search."
                }
              ],
              "value": "field(default_factory=lambda: DEFAULT_EXCLUDE_DIRS)"
            },
            {
              "name": "extendDefaultExcludeDirs",
              "annotation": "typing.Iterable[str] | None",
              "description": [
                {
                  "kind": "text",
                  "value": "Use this to extend the default exclude directories."
                }
              ],
              "value": "None"
            },
            {
              "name": "syncTables",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, the sqlite tables are synchronized immediatly\nafter some queries."
                }
              ],
              "annotation": "bool",
              "value": "field(default=True)"
            },
            {
              "name": "convertArrays",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, arrays are converted to np.arrays."
                }
              ],
              "annotation": "bool",
              "value": "True"
            },
            {
              "name": "databaseFileName",
              "description": [
                {
                  "kind": "text",
                  "value": "The name of the database file."
                }
              ],
              "annotation": "str",
              "value": "field(default=DATABASE_FILE_NAME)"
            },
            {
              "name": "databaseFile",
              "description": [
                {
                  "kind": "text",
                  "value": "The path to the database file."
                }
              ],
              "annotation": "pathlib.Path",
              "value": "field(init=False)"
            },
            {
              "name": "isolated",
              "description": [
                {
                  "kind": "text",
                  "value": "If true, this project manages it's own database. The\nsearchPaths are reduced to the project root only."
                }
              ],
              "annotation": "bool",
              "value": "False"
            },
            {
              "name": "projectDir",
              "annotation": "typing.Optional[pathlib.Path]",
              "description": [
                {
                  "kind": "text",
                  "value": "The project directory, if found."
                }
              ],
              "value": "None"
            }
          ],
          "docstring": [],
          "functions": {
            "__post_init__": {
              "name": "__post_init__",
              "path": "bamboost._config._IndexOptions.__post_init__",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __post_init__(self) -> None:\n    # Parse search paths to Path objects\n    self.searchPaths = PathSet(\n        Path(p).expanduser() if isinstance(p, str) else p for p in self.searchPaths\n    )\n\n    # Handle isolated mode\n    if self.isolated and self.projectDir:\n        self.projectDir.joinpath(\".bamboost_cache\").mkdir(\n            parents=True, exist_ok=True\n        )\n        self.databaseFile = self.projectDir.joinpath(\n            \".bamboost_cache\", \"bamboost.sqlite\"\n        )\n        self.searchPaths = PathSet([self.projectDir])\n    else:\n        self.databaseFile = LOCAL_DIR.joinpath(self.databaseFileName)\n\n    # Handle extendDefaultExcludeDirs\n    if self.extendDefaultExcludeDirs is not None:\n        self.excludeDirs = set((*self.excludeDirs, *self.extendDefaultExcludeDirs))"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._IndexOptions.__init__",
              "signature": "(self, searchPaths=lambda: PathSet([Path('~').expanduser()])(), excludeDirs=lambda: DEFAULT_EXCLUDE_DIRS(), extendDefaultExcludeDirs=None, syncTables=True, convertArrays=True, databaseFileName=DATABASE_FILE_NAME, isolated=False, projectDir=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "searchPaths",
                  "annotation": "typing.Iterable[typing.Union[str, pathlib.Path]]",
                  "description": null,
                  "value": "lambda: PathSet([Path('~').expanduser()])()"
                },
                {
                  "name": "excludeDirs",
                  "annotation": "typing.Iterable[str]",
                  "description": null,
                  "value": "lambda: DEFAULT_EXCLUDE_DIRS()"
                },
                {
                  "name": "extendDefaultExcludeDirs",
                  "annotation": "typing.Iterable[str] | None",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "syncTables",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "convertArrays",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "databaseFileName",
                  "annotation": "str",
                  "description": null,
                  "value": "bamboost._config.DATABASE_FILE_NAME"
                },
                {
                  "name": "isolated",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "projectDir",
                  "annotation": "typing.Optional[pathlib.Path]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _IndexOptions(_Base):\n    \"\"\"Index options for bamboost.\n\n    This dataclass contains the index options for bamboost.\n\n    Attributes:\n        searchPaths: A list of paths to index.\n        syncTables: If True, the sqlite tables are synchronized immediatly\n            after some queries.\n        convertArrays: If True, arrays are converted to np.arrays.\n        databaseFileName: The name of the database file.\n        databaseFile: The path to the database file.\n        isolated: If true, this project manages it's own database. The\n            searchPaths are reduced to the project root only.\n    \"\"\"\n\n    _field_aliases = {\n        \"paths\": \"searchPaths\",\n    }\n\n    searchPaths: Iterable[Union[str, Path]] = field(\n        default_factory=lambda: PathSet([Path(\"~\").expanduser()])\n    )\n    \"\"\"The list of paths to search for collections.\"\"\"\n\n    excludeDirs: Iterable[str] = field(default_factory=lambda: DEFAULT_EXCLUDE_DIRS)\n    \"\"\"The list of directory names to exclude from the search.\"\"\"\n\n    extendDefaultExcludeDirs: Iterable[str] | None = None\n    \"\"\"Use this to extend the default exclude directories.\"\"\"\n\n    syncTables: bool = field(default=True)\n    \"\"\"If True, the sqlite database is updated after some queries to keep it in sync.\"\"\"\n\n    convertArrays: bool = True\n    \"\"\"If True, sqlite lists are converted to np.arrays. If false, they are left as\n    lists.\"\"\"\n\n    databaseFileName: str = field(default=DATABASE_FILE_NAME)\n    \"\"\"The basename of the database file.\"\"\"\n\n    databaseFile: Path = field(init=False)\n    \"\"\"The path to the default database file in the current context. This can be the\n    global database or a project-specific database.\"\"\"\n\n    isolated: bool = False\n    \"\"\"If true, this project manages it's own database. The searchPaths are reduced to the\n    project root only.\"\"\"\n\n    projectDir: Optional[Path] = None\n    \"\"\"The project directory, if found.\"\"\"\n\n    def __post_init__(self) -> None:\n        # Parse search paths to Path objects\n        self.searchPaths = PathSet(\n            Path(p).expanduser() if isinstance(p, str) else p for p in self.searchPaths\n        )\n\n        # Handle isolated mode\n        if self.isolated and self.projectDir:\n            self.projectDir.joinpath(\".bamboost_cache\").mkdir(\n                parents=True, exist_ok=True\n            )\n            self.databaseFile = self.projectDir.joinpath(\n                \".bamboost_cache\", \"bamboost.sqlite\"\n            )\n            self.searchPaths = PathSet([self.projectDir])\n        else:\n            self.databaseFile = LOCAL_DIR.joinpath(self.databaseFileName)\n\n        # Handle extendDefaultExcludeDirs\n        if self.extendDefaultExcludeDirs is not None:\n            self.excludeDirs = set((*self.excludeDirs, *self.extendDefaultExcludeDirs))",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_Config": {
          "name": "_Config",
          "path": "bamboost._config._Config",
          "description": "Configuration class for bamboost.\n\nThis class manages the configuration options and index settings for bamboost.\nIt loads the configuration from a file and provides access to the options\nand index attributes.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "project_dir",
              "annotation": "typing.Optional[bamboost._typing.StrPath]",
              "description": [
                {
                  "kind": "text",
                  "value": "An optional alternative directory to load the project-based config\nfrom."
                }
              ],
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "paths",
              "description": [
                {
                  "kind": "text",
                  "value": "Paths used by bamboost."
                }
              ],
              "annotation": "bamboost._config._Paths",
              "value": "_Paths.from_dict(config.pop('paths', {}))"
            },
            {
              "name": "options",
              "description": [
                {
                  "kind": "text",
                  "value": "Configuration options for bamboost."
                }
              ],
              "annotation": "bamboost._config._Options",
              "value": "_Options.from_dict(config.pop('options', {}))"
            },
            {
              "name": "index",
              "description": [
                {
                  "kind": "text",
                  "value": "Index settings for bamboost."
                }
              ],
              "annotation": "bamboost._config._IndexOptions",
              "value": "_IndexOptions.from_dict(config.pop('index', {}), projectDir=project_dir)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Config.__init__",
              "signature": "(self, project_dir=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "project_dir",
                  "annotation": "typing.Optional[bamboost._typing.StrPath]",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, project_dir: Optional[StrPath] = None) -> None:\n    global_config = _get_global_config(CONFIG_FILE)\n    project_dir = project_dir or _find_root_dir()\n    if project_dir:\n        project_config = _get_project_config(Path(project_dir))\n    else:\n        project_config = {}\n\n    def nested_update(d: MutableMapping, u: MutableMapping) -> MutableMapping:\n        for k, v in u.items():\n            d[k] = (\n                nested_update(d.get(k, {}), v)\n                if isinstance(v, MutableMapping)\n                else v\n            )\n        return d\n\n    config = nested_update(global_config, project_config)\n\n    self.paths = _Paths.from_dict(config.pop(\"paths\", {}))\n    self.options = _Options.from_dict(config.pop(\"options\", {}))\n    self.index = _IndexOptions.from_dict(\n        config.pop(\"index\", {}), projectDir=project_dir\n    )\n\n    # Log unknown config options\n    for key in global_config.keys():\n        log.info(f\"Unknown config table: {key}\")"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._config._Config.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    s = str()\n    for field in fields(self):\n        s += f\"> {field.name.upper()}\\n\"\n        s += getattr(self, field.name).__repr__()\n        s += \"\\n\"\n    return s"
            }
          },
          "source": "@dataclass(repr=False, init=False)\nclass _Config(_Base):\n    \"\"\"Configuration class for bamboost.\n\n    This class manages the configuration options and index settings for bamboost.\n    It loads the configuration from a file and provides access to the options\n    and index attributes.\n\n    Args:\n        project_dir: An optional alternative directory to load the project-based config\n            from.\n\n    Attributes:\n        paths: Paths used by bamboost.\n        options: Configuration options for bamboost.\n        index: Index settings for bamboost.\n    \"\"\"\n\n    paths: _Paths\n    options: _Options\n    index: _IndexOptions\n\n    def __init__(self, project_dir: Optional[StrPath] = None) -> None:\n        global_config = _get_global_config(CONFIG_FILE)\n        project_dir = project_dir or _find_root_dir()\n        if project_dir:\n            project_config = _get_project_config(Path(project_dir))\n        else:\n            project_config = {}\n\n        def nested_update(d: MutableMapping, u: MutableMapping) -> MutableMapping:\n            for k, v in u.items():\n                d[k] = (\n                    nested_update(d.get(k, {}), v)\n                    if isinstance(v, MutableMapping)\n                    else v\n                )\n            return d\n\n        config = nested_update(global_config, project_config)\n\n        self.paths = _Paths.from_dict(config.pop(\"paths\", {}))\n        self.options = _Options.from_dict(config.pop(\"options\", {}))\n        self.index = _IndexOptions.from_dict(\n            config.pop(\"index\", {}), projectDir=project_dir\n        )\n\n        # Log unknown config options\n        for key in global_config.keys():\n            log.info(f\"Unknown config table: {key}\")\n\n    def __repr__(self) -> str:\n        s = str()\n        for field in fields(self):\n            s += f\"> {field.name.upper()}\\n\"\n            s += getattr(self, field.name).__repr__()\n            s += \"\\n\"\n        return s",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        }
      },
      "functions": {
        "_find_root_dir": {
          "name": "_find_root_dir",
          "path": "bamboost._config._find_root_dir",
          "signature": "() -> Optional[Path]",
          "description": "Find the root directory.",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _find_root_dir() -> Optional[Path]:\n    \"\"\"Find the root directory.\"\"\"\n\n    ANCHORS = [\n        \".git\",\n        \"pyproject.toml\",\n    ]\n\n    cwd = Path.cwd()\n    try:\n        return next(\n            path\n            for path in chain([cwd], cwd.parents)\n            if any(path.joinpath(anchor).exists() for anchor in ANCHORS)\n        )\n    except StopIteration:\n        log.info(\"Root directory not found.\")\n        return None"
        },
        "_get_global_config": {
          "name": "_get_global_config",
          "path": "bamboost._config._get_global_config",
          "signature": "(filepath) -> dict[str, Any]",
          "description": "Reads the configuration file and fills the configuration options.",
          "parameters": [
            {
              "name": "filepath",
              "annotation": "pathlib.Path",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_global_config(filepath: Path) -> dict[str, Any]:\n    \"\"\"Reads the configuration file and fills the configuration options.\"\"\"\n    try:\n        with filepath.open(\"rb\") as f:\n            try:\n                return tomli.load(f)\n            except tomli.TOMLDecodeError as e:\n                log.warning(f\"Error reading config file: {e}\")\n                return {}\n    except FileNotFoundError:\n        log.info(\"Config file not found or unreadable. Using default settings.\")\n        return {}"
        },
        "_get_project_config": {
          "name": "_get_project_config",
          "path": "bamboost._config._get_project_config",
          "signature": "(project_dir) -> dict[str, Any]",
          "description": "Get the project configuration from bamboost.toml or pyproject.toml.",
          "parameters": [
            {
              "name": "project_dir",
              "annotation": "pathlib.Path",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_project_config(project_dir: Path) -> dict[str, Any]:\n    \"\"\"Get the project configuration from bamboost.toml or pyproject.toml.\"\"\"\n    bamboost_path = project_dir.joinpath(\"bamboost.toml\")\n    pyproject_path = project_dir.joinpath(\"pyproject.toml\")\n\n    if bamboost_path.is_file():\n        try:\n            with bamboost_path.open(\"rb\") as f:\n                return tomli.load(f)\n        except tomli.TOMLDecodeError as e:\n            log.warning(f\"Error reading bamboost.toml: {e}\")\n            return {}\n\n    if pyproject_path.is_file():\n        try:\n            with pyproject_path.open(\"rb\") as f:\n                return tomli.load(f).get(\"tool\", {}).get(\"bamboost\", {})\n        except tomli.TOMLDecodeError as e:\n            log.warning(f\"Error reading pyproject.toml: {e}\")\n            return {}\n\n    log.info(\"No configuration file found. Using default settings.\")\n    return {}"
        }
      }
    },
    "core": {
      "name": "core",
      "path": "bamboost.core",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "__all__",
          "annotation": null,
          "description": null,
          "value": "['Collection', 'Simulation', 'SimulationWriter', 'FieldType']"
        }
      ],
      "modules": {
        "remote": {
          "name": "remote",
          "path": "bamboost.core.remote",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/remote.py",
          "description": "This module introduces the Remote class, which is used to access remote collections.",
          "docstring": [],
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild(__name__)"
            }
          ],
          "modules": {},
          "classes": {
            "Remote": {
              "name": "Remote",
              "path": "bamboost.core.remote.Remote",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "remote_url",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "comm",
                  "annotation": "typing.Optional[bamboost.mpi.Comm]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "workspace_path",
                  "annotation": "typing.Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "workspace_name",
                  "annotation": "typing.Optional[str]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "skip_fetch",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                }
              ],
              "attributes": [
                {
                  "name": "DATABASE_BASE_NAME",
                  "annotation": null,
                  "description": null,
                  "value": "'bamboost.sqlite'"
                },
                {
                  "name": "DATABASE_REMOTE_PATH",
                  "annotation": null,
                  "description": null,
                  "value": "_config.LOCAL_DIR.joinpath(_config.DATABASE_FILE_NAME)"
                },
                {
                  "name": "WORKSPACE_SPLITTER",
                  "annotation": null,
                  "description": null,
                  "value": "'_WS_'"
                },
                {
                  "name": "_remote_url",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.Remote(remote_url)"
                },
                {
                  "name": "id",
                  "annotation": null,
                  "description": null,
                  "value": "f'{bamboost.core.remote.Remote(remote_url)}{bamboost.core.remote.Remote(self).bamboost.core.remote.Remote(self).WORKSPACE_SPLITTER}{bamboost.core.remote.Remote(workspace_name)}' if bamboost.core.remote.Remote(workspace_name) else bamboost.core.remote.Remote(remote_url)"
                },
                {
                  "name": "_local_path",
                  "annotation": null,
                  "description": null,
                  "value": "Path(cache_dir).joinpath(self.id)"
                },
                {
                  "name": "_workspace_path",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.Remote(workspace_path)"
                },
                {
                  "name": "_workspace_name",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.Remote(workspace_name)"
                },
                {
                  "name": "_remote_database_path",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.Remote(self).bamboost.core.remote.Remote(self).DATABASE_REMOTE_PATH"
                },
                {
                  "name": "_local_database_path",
                  "annotation": null,
                  "description": null,
                  "value": "cache_dir.joinpath(f'{self.id}.sqlite')"
                },
                {
                  "name": "search_paths",
                  "annotation": null,
                  "description": null,
                  "value": "PathSet([self._local_path])"
                },
                {
                  "name": "_url",
                  "annotation": null,
                  "description": null,
                  "value": "f'sqlite:///{bamboost.core.remote.Remote(self).bamboost.core.remote.Remote(self)._local_database_path}'"
                },
                {
                  "name": "_engine",
                  "annotation": null,
                  "description": null,
                  "value": "create_engine(self._url, json_serializer=json_serializer, json_deserializer=json_deserializer)"
                },
                {
                  "name": "_sm",
                  "annotation": null,
                  "description": null,
                  "value": "sessionmaker(bind=self._engine, autobegin=False, expire_on_commit=False)"
                },
                {
                  "name": "_s",
                  "annotation": null,
                  "description": null,
                  "value": "self._sm()"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.remote.Remote.__init__",
                  "signature": "(self, remote_url, comm=None, *, workspace_path=None, workspace_name=None, skip_fetch=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "remote_url",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "workspace_path",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "workspace_name",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "skip_fetch",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    remote_url: str,\n    comm: Optional[Comm] = None,\n    *,\n    workspace_path: Optional[str] = None,\n    workspace_name: Optional[str] = None,\n    skip_fetch: bool = False,\n):\n    cache_dir = Path(config.paths.cacheDir)\n    self._remote_url = remote_url\n    self.id = (\n        f\"{remote_url}{self.WORKSPACE_SPLITTER}{workspace_name}\"\n        if workspace_name\n        else remote_url\n    )\n    self._local_path = Path(cache_dir).joinpath(self.id)\n    self._workspace_path = workspace_path\n    self._workspace_name = workspace_name\n    self._remote_database_path = self.DATABASE_REMOTE_PATH\n\n    if workspace_name is not None:\n        # check if the remote workspace has a meta file\n        meta_file = cache_dir.joinpath(f\"{self.id}.json\")\n        if workspace_path is not None:\n            # update the meta file\n            meta_file.write_text(\n                f'{{\"remote_url\": \"{remote_url}\", \"workspace_path\": \"{workspace_path}\"}}'\n            )\n            self._workspace_path = workspace_path\n        else:\n            assert meta_file.exists(), (\n                f\"Workspace {workspace_name} is not found in the cache. \"\n                \"You must also provide the workspace path (`workspace_path=...`).\"\n            )\n            meta = json.loads(meta_file.read_text())\n            self._workspace_path = cast(str, meta[\"workspace_path\"])\n\n        self._remote_database_path = Path(self._workspace_path).joinpath(\n            \".bamboost_cache\", self.DATABASE_BASE_NAME\n        )\n\n    # Create the local path if it doesn't exist\n    self._local_path.mkdir(parents=True, exist_ok=True)\n    self._local_database_path = cache_dir.joinpath(f\"{self.id}.sqlite\")\n\n    # super init\n    self.search_paths = PathSet([self._local_path])\n    self._url = f\"sqlite:///{self._local_database_path}\"\n\n    # Fetch the remote database\n    if not skip_fetch:\n        process = self.fetch_remote_database()\n        process.wait()\n\n    self._engine = create_engine(\n        self._url,\n        json_serializer=json_serializer,\n        json_deserializer=json_deserializer,\n    )\n    self._sm = sessionmaker(\n        bind=self._engine, autobegin=False, expire_on_commit=False\n    )\n    self._s = self._sm()"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.core.remote.Remote.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    qualname = \".\".join([__name__, self.__class__.__qualname__])\n    return f\"<{qualname} (source={self._remote_url}, workspace={self._workspace_name})>\""
                },
                "_from_id": {
                  "name": "_from_id",
                  "path": "bamboost.core.remote.Remote._from_id",
                  "signature": "(cls, id) -> Remote",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef _from_id(cls, id: str) -> Remote:\n    remote_url, *workspace_name = id.split(cls.WORKSPACE_SPLITTER)\n    return cls(\n        remote_url,\n        workspace_name=workspace_name[0] if workspace_name else None,\n        skip_fetch=True,\n    )"
                },
                "fetch_remote_database": {
                  "name": "fetch_remote_database",
                  "path": "bamboost.core.remote.Remote.fetch_remote_database",
                  "signature": "(self) -> subprocess.Popen",
                  "description": "Fetch the remote database.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def fetch_remote_database(\n    self,\n) -> subprocess.Popen:\n    \"\"\"Fetch the remote database.\"\"\"\n    return subprocess.Popen(\n        [\n            \"rsync\",\n            \"-av\",\n            f\"{self._remote_url}:{self._remote_database_path}\",\n            str(self._local_database_path),\n        ],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )"
                },
                "rsync": {
                  "name": "rsync",
                  "path": "bamboost.core.remote.Remote.rsync",
                  "signature": "(self, source, dest) -> subprocess.Popen",
                  "description": "Sync data with the remote server.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "source",
                      "annotation": "bamboost._typing.StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The absolute source path on the remote server."
                        }
                      ]
                    },
                    {
                      "name": "dest",
                      "annotation": "bamboost._typing.StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The relative (from the cache dir for this remote) destination path on\nthe local machine."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def rsync(self, source: StrPath, dest: StrPath) -> subprocess.Popen:\n    \"\"\"Sync data with the remote server.\n\n    Args:\n        source: The absolute source path on the remote server.\n        dest: The relative (from the cache dir for this remote) destination path on\n            the local machine.\n    \"\"\"\n    return subprocess.Popen(\n        [\n            \"rsync\",\n            \"-ravh\",\n            f\"{self._remote_url}:{source}\",\n            f\"{self._local_path.joinpath(dest)}\",\n        ],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )"
                },
                "list": {
                  "name": "list",
                  "path": "bamboost.core.remote.Remote.list",
                  "signature": "(cls) -> list[Remote]",
                  "description": "List all remote databases in the cache.",
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef list(cls) -> list[Remote]:\n    \"\"\"List all remote databases in the cache.\"\"\"\n    # find all sqlite files in the cache directory\n    return [\n        Remote._from_id(name.stem)\n        for name in _config.CACHE_DIR.iterdir()\n        if name.is_file() and name.suffix == \".sqlite\"\n    ]"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.remote.Remote.__getitem__",
                  "signature": "(self, key) -> RemoteCollection",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key: str) -> RemoteCollection:\n    uid = key.split(\" - \")[0]\n    return RemoteCollection(uid, remote=self)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.remote.Remote._ipython_key_completions_",
                  "signature": "(self) -> list[str]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self) -> list[str]:\n    return [coll.uid for coll in self._get_collections()]"
                },
                "get_local_path": {
                  "name": "get_local_path",
                  "path": "bamboost.core.remote.Remote.get_local_path",
                  "signature": "(self, collection_uid) -> Path",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_local_path(self, collection_uid: str) -> Path:\n    return self._local_path.joinpath(collection_uid)"
                }
              },
              "source": "class Remote(Index):\n    DATABASE_BASE_NAME = \"bamboost.sqlite\"\n    DATABASE_REMOTE_PATH = _config.LOCAL_DIR.joinpath(_config.DATABASE_FILE_NAME)\n    WORKSPACE_SPLITTER = \"_WS_\"\n\n    def __init__(\n        self,\n        remote_url: str,\n        comm: Optional[Comm] = None,\n        *,\n        workspace_path: Optional[str] = None,\n        workspace_name: Optional[str] = None,\n        skip_fetch: bool = False,\n    ):\n        cache_dir = Path(config.paths.cacheDir)\n        self._remote_url = remote_url\n        self.id = (\n            f\"{remote_url}{self.WORKSPACE_SPLITTER}{workspace_name}\"\n            if workspace_name\n            else remote_url\n        )\n        self._local_path = Path(cache_dir).joinpath(self.id)\n        self._workspace_path = workspace_path\n        self._workspace_name = workspace_name\n        self._remote_database_path = self.DATABASE_REMOTE_PATH\n\n        if workspace_name is not None:\n            # check if the remote workspace has a meta file\n            meta_file = cache_dir.joinpath(f\"{self.id}.json\")\n            if workspace_path is not None:\n                # update the meta file\n                meta_file.write_text(\n                    f'{{\"remote_url\": \"{remote_url}\", \"workspace_path\": \"{workspace_path}\"}}'\n                )\n                self._workspace_path = workspace_path\n            else:\n                assert meta_file.exists(), (\n                    f\"Workspace {workspace_name} is not found in the cache. \"\n                    \"You must also provide the workspace path (`workspace_path=...`).\"\n                )\n                meta = json.loads(meta_file.read_text())\n                self._workspace_path = cast(str, meta[\"workspace_path\"])\n\n            self._remote_database_path = Path(self._workspace_path).joinpath(\n                \".bamboost_cache\", self.DATABASE_BASE_NAME\n            )\n\n        # Create the local path if it doesn't exist\n        self._local_path.mkdir(parents=True, exist_ok=True)\n        self._local_database_path = cache_dir.joinpath(f\"{self.id}.sqlite\")\n\n        # super init\n        self.search_paths = PathSet([self._local_path])\n        self._url = f\"sqlite:///{self._local_database_path}\"\n\n        # Fetch the remote database\n        if not skip_fetch:\n            process = self.fetch_remote_database()\n            process.wait()\n\n        self._engine = create_engine(\n            self._url,\n            json_serializer=json_serializer,\n            json_deserializer=json_deserializer,\n        )\n        self._sm = sessionmaker(\n            bind=self._engine, autobegin=False, expire_on_commit=False\n        )\n        self._s = self._sm()\n\n    def __repr__(self) -> str:\n        qualname = \".\".join([__name__, self.__class__.__qualname__])\n        return f\"<{qualname} (source={self._remote_url}, workspace={self._workspace_name})>\"\n\n    @classmethod\n    def _from_id(cls, id: str) -> Remote:\n        remote_url, *workspace_name = id.split(cls.WORKSPACE_SPLITTER)\n        return cls(\n            remote_url,\n            workspace_name=workspace_name[0] if workspace_name else None,\n            skip_fetch=True,\n        )\n\n    def fetch_remote_database(\n        self,\n    ) -> subprocess.Popen:\n        \"\"\"Fetch the remote database.\"\"\"\n        return subprocess.Popen(\n            [\n                \"rsync\",\n                \"-av\",\n                f\"{self._remote_url}:{self._remote_database_path}\",\n                str(self._local_database_path),\n            ],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n\n    def rsync(self, source: StrPath, dest: StrPath) -> subprocess.Popen:\n        \"\"\"Sync data with the remote server.\n\n        Args:\n            source: The absolute source path on the remote server.\n            dest: The relative (from the cache dir for this remote) destination path on\n                the local machine.\n        \"\"\"\n        return subprocess.Popen(\n            [\n                \"rsync\",\n                \"-ravh\",\n                f\"{self._remote_url}:{source}\",\n                f\"{self._local_path.joinpath(dest)}\",\n            ],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n\n    @classmethod\n    def list(cls) -> list[Remote]:\n        \"\"\"List all remote databases in the cache.\"\"\"\n        # find all sqlite files in the cache directory\n        return [\n            Remote._from_id(name.stem)\n            for name in _config.CACHE_DIR.iterdir()\n            if name.is_file() and name.suffix == \".sqlite\"\n        ]\n\n    def __getitem__(self, key: str) -> RemoteCollection:\n        uid = key.split(\" - \")[0]\n        return RemoteCollection(uid, remote=self)\n\n    def _ipython_key_completions_(self) -> list[str]:\n        return [coll.uid for coll in self._get_collections()]\n\n    def get_local_path(self, collection_uid: str) -> Path:\n        return self._local_path.joinpath(collection_uid)",
              "inherited_members": {
                "bamboost.index.base.Index": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index.default"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index._file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index._isolated"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._initialize_root_process"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.sql_transaction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.scan_for_collections"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.check_integrity"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.resolve_path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.resolve_uid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.sync_collection"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index.all_collections"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.collection"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index.all_simulations"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.simulation"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.base.Index.all_parameters"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._drop_collection"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._drop_simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.upsert_collection"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.upsert_simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.update_simulation_metadata"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index.update_simulation_parameters"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._get_collection_path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._get_collections"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.base.Index._get_simulation"
                  }
                ]
              }
            },
            "RemoteCollection": {
              "name": "RemoteCollection",
              "path": "bamboost.core.remote.RemoteCollection",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "remote",
                  "annotation": "bamboost.core.remote.Remote",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "uid",
                  "annotation": null,
                  "description": null,
                  "value": "CollectionUID(uid)"
                },
                {
                  "name": "_index",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.RemoteCollection(remote)"
                },
                {
                  "name": "path",
                  "annotation": null,
                  "description": null,
                  "value": "remote._local_path.joinpath(uid)"
                },
                {
                  "name": "remote_path",
                  "annotation": null,
                  "description": null,
                  "value": "cast(Path, remote._get_collection_path(self.uid))"
                },
                {
                  "name": "df",
                  "annotation": "pandas.DataFrame",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.remote.RemoteCollection.__init__",
                  "signature": "(self, uid, remote)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "remote",
                      "annotation": "bamboost.core.remote.Remote",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    uid: str,\n    remote: Remote,\n):\n    self.uid = CollectionUID(uid)\n    self._index = remote\n\n    # Resolve the path (this updates the index if necessary)\n    self.path = remote._local_path.joinpath(uid)\n    self.remote_path = cast(Path, remote._get_collection_path(self.uid))\n\n    # Create the diretory for the collection if necessary\n    self.path.mkdir(parents=True, exist_ok=True)\n\n    # Check if identifier file exists (and create it if necessary)\n    if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n        create_identifier_file(self.path, self.uid)"
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.core.remote.RemoteCollection._repr_html_",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    import pkgutil\n\n    html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n    icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n    return (\n        html_string.replace(\"$ICON\", icon)\n        .replace(\"$db_path\", f\"<a href={self.path.as_posix()}>{self.path}</a>\")\n        .replace(\"$db_uid\", f\"{self.uid} [from {self._index._remote_url}]\")\n        .replace(\"$db_size\", str(len(self)))\n    )"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.remote.RemoteCollection.__getitem__",
                  "signature": "(self, name) -> RemoteSimulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, name: str) -> RemoteSimulation:\n    return RemoteSimulation(\n        name,\n        collection_uid=self.uid,\n        index=self._index,\n        comm=self._comm,\n    )"
                },
                "get_cached_simulation_names": {
                  "name": "get_cached_simulation_names",
                  "path": "bamboost.core.remote.RemoteCollection.get_cached_simulation_names",
                  "signature": "(self) -> list[str]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_cached_simulation_names(self) -> list[str]:\n    return [str(i.name) for i in self.path.iterdir() if i.is_dir()]"
                },
                "rsync": {
                  "name": "rsync",
                  "path": "bamboost.core.remote.RemoteCollection.rsync",
                  "signature": "(self, name=None) -> Self",
                  "description": "Transfer data using rsync. Wait for the process to finish and return\nself.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "typing.Optional[str]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The simulation name of the simulation to be transferred. If None, all\nsimulations are synced."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def rsync(self, name: Optional[str] = None) -> Self:\n    \"\"\"Transfer data using rsync. Wait for the process to finish and return\n    self.\n\n    Args:\n        name: The simulation name of the simulation to be transferred. If None, all\n            simulations are synced.\n    \"\"\"\n    if name:\n        source = self.remote_path.joinpath(name)\n        dest = self.path.joinpath(name)\n    else:\n        source = self.remote_path\n        dest = self.path\n\n    stream_popen_output(self._index.rsync)(source, dest)\n    return self"
                }
              },
              "source": "class RemoteCollection(Collection):\n    def __init__(\n        self,\n        uid: str,\n        remote: Remote,\n    ):\n        self.uid = CollectionUID(uid)\n        self._index = remote\n\n        # Resolve the path (this updates the index if necessary)\n        self.path = remote._local_path.joinpath(uid)\n        self.remote_path = cast(Path, remote._get_collection_path(self.uid))\n\n        # Create the diretory for the collection if necessary\n        self.path.mkdir(parents=True, exist_ok=True)\n\n        # Check if identifier file exists (and create it if necessary)\n        if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n            create_identifier_file(self.path, self.uid)\n\n    def _repr_html_(self) -> str:\n        import pkgutil\n\n        html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n        icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n        return (\n            html_string.replace(\"$ICON\", icon)\n            .replace(\"$db_path\", f\"<a href={self.path.as_posix()}>{self.path}</a>\")\n            .replace(\"$db_uid\", f\"{self.uid} [from {self._index._remote_url}]\")\n            .replace(\"$db_size\", str(len(self)))\n        )\n\n    def __getitem__(self, name: str) -> RemoteSimulation:\n        return RemoteSimulation(\n            name,\n            collection_uid=self.uid,\n            index=self._index,\n            comm=self._comm,\n        )\n\n    @property\n    def df(self) -> DataFrame:\n        df = super().df\n\n        # Add a cached column at the second position\n        cached_col = df[\"name\"].isin(self.get_cached_simulation_names())\n        df.insert(1, \"cached\", cached_col)  # pyright: ignore[reportArgumentType]\n        return df\n\n    def get_cached_simulation_names(self) -> list[str]:\n        return [str(i.name) for i in self.path.iterdir() if i.is_dir()]\n\n    def rsync(self, name: Optional[str] = None) -> Self:\n        \"\"\"Transfer data using rsync. Wait for the process to finish and return\n        self.\n\n        Args:\n            name: The simulation name of the simulation to be transferred. If None, all\n                simulations are synced.\n        \"\"\"\n        if name:\n            source = self.remote_path.joinpath(name)\n            dest = self.path.joinpath(name)\n        else:\n            source = self.remote_path\n            dest = self.path\n\n        stream_popen_output(self._index.rsync)(source, dest)\n        return self",
              "inherited_members": {
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.collection.Collection": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection.FROZEN"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection.fromUID"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection._filter"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection.k"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.collection.Collection._orm"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.__len__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection._ipython_key_completions_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.filter"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.all_simulation_names"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.sync_cache"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.create_simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection._delete_simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection.find"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection._list_duplicates"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.collection.Collection._check_duplicate"
                  }
                ]
              }
            },
            "RemoteSimulation": {
              "name": "RemoteSimulation",
              "path": "bamboost.core.remote.RemoteSimulation",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "collection_uid",
                  "annotation": "bamboost.index.base.CollectionUID",
                  "description": null,
                  "value": null
                },
                {
                  "name": "index",
                  "annotation": "bamboost.core.remote.Remote",
                  "description": null,
                  "value": null
                },
                {
                  "name": "comm",
                  "annotation": "typing.Optional[bamboost.mpi.Comm]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "bamboost.core.remote.RemoteSimulation(name)"
                },
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "index.get_local_path(collection_uid).joinpath(name)"
                },
                {
                  "name": "remote_path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "index._get_collection_path(collection_uid).joinpath(name)"
                },
                {
                  "name": "collection_uid",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.remote.RemoteSimulation(collection_uid)"
                },
                {
                  "name": "_index",
                  "annotation": "bamboost.core.remote.Remote",
                  "description": null,
                  "value": "bamboost.core.remote.RemoteSimulation(index)"
                },
                {
                  "name": "_data_file",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "self.path.joinpath(constants.HDF_DATA_FILE_NAME)"
                },
                {
                  "name": "_xdmf_file",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "self.path.joinpath(constants.XDMF_FILE_NAME)"
                },
                {
                  "name": "_bash_file",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "self.path.joinpath(constants.RUN_FILE_NAME)"
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parameters",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "metadata",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.remote.RemoteSimulation.__init__",
                  "signature": "(self, name, collection_uid, index, comm=None, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "bamboost.index.base.CollectionUID",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "index",
                      "annotation": "bamboost.core.remote.Remote",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    name: str,\n    collection_uid: CollectionUID,\n    index: Remote,\n    comm: Optional[Comm] = None,\n    **kwargs,\n):\n    self.name: str = name\n    self.path: Path = index.get_local_path(collection_uid).joinpath(name)\n    self.remote_path: Path = index._get_collection_path(collection_uid).joinpath(\n        name\n    )\n    self.collection_uid = collection_uid\n\n    # Reference to the database\n    self._index: Remote = index\n\n    self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n    self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n    self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)"
                },
                "rsync": {
                  "name": "rsync",
                  "path": "bamboost.core.remote.RemoteSimulation.rsync",
                  "signature": "(self) -> Self",
                  "description": "Sync the simulation data with the remote server.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def rsync(self) -> Self:\n    \"\"\"Sync the simulation data with the remote server.\"\"\"\n    stream_popen_output(self._index.rsync)(self.remote_path, self.path.parent)\n    return self"
                }
              },
              "source": "class RemoteSimulation(Simulation):\n    def __init__(\n        self,\n        name: str,\n        collection_uid: CollectionUID,\n        index: Remote,\n        comm: Optional[Comm] = None,\n        **kwargs,\n    ):\n        self.name: str = name\n        self.path: Path = index.get_local_path(collection_uid).joinpath(name)\n        self.remote_path: Path = index._get_collection_path(collection_uid).joinpath(\n            name\n        )\n        self.collection_uid = collection_uid\n\n        # Reference to the database\n        self._index: Remote = index\n\n        self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n        self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n        self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)\n\n    @property\n    def uid(self) -> str:\n        return f\"ssh://{self._index._remote_url}/{super().uid}\"\n\n    @property\n    def parameters(self) -> dict:\n        return self._orm.parameter_dict\n\n    @property\n    def metadata(self) -> dict:\n        return self._orm.as_dict_metadata()\n\n    def rsync(self) -> Self:\n        \"\"\"Sync the simulation data with the remote server.\"\"\"\n        stream_popen_output(self._index.rsync)(self.remote_path, self.path.parent)\n        return self",
              "inherited_members": {
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.simulation.base.Simulation": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base.Simulation._file"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.base._Simulation": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.mutable"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._psize"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._prank"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._ranks"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.__eq__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.root"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._orm"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.from_uid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.edit"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.update_database"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.status"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.created_at"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.description"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.links"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.files"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.git"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.data"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.meshes"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.mesh"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.enter_path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.require_series"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.create_xdmf"
                  }
                ]
              }
            }
          },
          "functions": {
            "stream_popen_output": {
              "name": "stream_popen_output",
              "path": "bamboost.core.remote.stream_popen_output",
              "signature": "(func) -> Callable[_P, None]",
              "description": "Decorator to await, capture and print the output of a subprocess.Popen object.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "typing.Callable[bamboost._typing._P, subprocess.subprocess.Popen]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def stream_popen_output(func: Callable[_P, subprocess.Popen]) -> Callable[_P, None]:\n    \"\"\"Decorator to await, capture and print the output of a subprocess.Popen object.\"\"\"\n\n    def wrapper(*args, **kwargs) -> None:\n        process = func(*args, **kwargs)\n        assert process.stdout is not None\n        for line in process.stdout:\n            print(line, end=\"\", flush=True)\n        process.wait()\n\n    return wrapper"
            }
          }
        },
        "collection": {
          "name": "collection",
          "path": "bamboost.core.collection",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/collection.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "__all__",
              "annotation": null,
              "description": null,
              "value": "['Collection', 'NotACollectionError']"
            },
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild('Collection')"
            }
          ],
          "modules": {},
          "classes": {
            "NotACollectionError": {
              "name": "NotACollectionError",
              "path": "bamboost.core.collection.NotACollectionError",
              "description": "Raised when a path is not a valid collection.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.collection.NotACollectionError.__init__",
                  "signature": "(self, path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, path: Path):\n    super().__init__(f\"{path} is not a valid collection.\")"
                }
              },
              "source": "class NotACollectionError(NotADirectoryError):\n    \"\"\"Raised when a path is not a valid collection.\"\"\"\n\n    def __init__(self, path: Path):\n        super().__init__(f\"{path} is not a valid collection.\")",
              "inherited_members": {}
            },
            "_CollectionPicker": {
              "name": "_CollectionPicker",
              "path": "bamboost.core.collection._CollectionPicker",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.collection._CollectionPicker.__getitem__",
                  "signature": "(self, key) -> Collection",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key: str, /) -> Collection:\n    key = key.split(\" - \", 1)[0]\n    return Collection(uid=key)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.collection._CollectionPicker._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self):\n    return (f\"{i.uid} - {i.path[-30:]}\" for i in Index.default.all_collections)"
                }
              },
              "source": "class _CollectionPicker:\n    def __getitem__(self, key: str, /) -> Collection:\n        key = key.split(\" - \", 1)[0]\n        return Collection(uid=key)\n\n    def _ipython_key_completions_(self):\n        return (f\"{i.uid} - {i.path[-30:]}\" for i in Index.default.all_collections)",
              "inherited_members": {}
            },
            "_FilterKeys": {
              "name": "_FilterKeys",
              "path": "bamboost.core.collection._FilterKeys",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "collection",
                  "annotation": "bamboost.core.collection.Collection",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "collection",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.collection._FilterKeys(collection)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.collection._FilterKeys.__init__",
                  "signature": "(self, collection)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection",
                      "annotation": "bamboost.core.collection.Collection",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, collection: Collection):\n    self.collection = collection"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.collection._FilterKeys.__getitem__",
                  "signature": "(self, key) -> _Key",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key: str) -> _Key:\n    return _Key(key)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.collection._FilterKeys._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self):\n    metadata_keys = (\n        \"collection_uid\",\n        \"name\",\n        \"created_at\",\n        \"modified_at\",\n        \"description\",\n        \"status\",\n    )\n    return (*self.collection._orm.get_parameter_keys()[0], *metadata_keys)"
                }
              },
              "source": "class _FilterKeys:\n    def __init__(self, collection: Collection):\n        self.collection = collection\n\n    def __getitem__(self, key: str) -> _Key:\n        return _Key(key)\n\n    def _ipython_key_completions_(self):\n        metadata_keys = (\n            \"collection_uid\",\n            \"name\",\n            \"created_at\",\n            \"modified_at\",\n            \"description\",\n            \"status\",\n        )\n        return (*self.collection._orm.get_parameter_keys()[0], *metadata_keys)",
              "inherited_members": {}
            },
            "Collection": {
              "name": "Collection",
              "path": "bamboost.core.collection.Collection",
              "description": "View of database.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "typing.Optional[bamboost._typing.StrPath]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "path to the directory of the database. If doesn't exist,\na new database will be created."
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "uid",
                  "annotation": "typing.Optional[str]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID of the database"
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "create_if_not_exist",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "comm",
                  "annotation": "typing.Optional[bamboost.mpi.Comm]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "MPI communicator"
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "index_instance",
                  "annotation": "typing.Optional[bamboost.index.Index]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "sync_collection",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "filter",
                  "annotation": "typing.Optional[bamboost.index._filtering.Filter]",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "FROZEN",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "uid",
                  "annotation": "bamboost.index.CollectionUID",
                  "description": null,
                  "value": "CollectionUID(uid or self._index.resolve_uid(self.path))"
                },
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": "Path(path or self._index.resolve_path(uid.upper())).absolute()"
                },
                {
                  "name": "fromUID",
                  "annotation": null,
                  "description": null,
                  "value": "_CollectionPicker()"
                },
                {
                  "name": "_comm",
                  "annotation": null,
                  "description": null,
                  "value": "Communicator()"
                },
                {
                  "name": "_index",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.collection.Collection(index_instance) or bamboost.index.Index.bamboost.index.Index.default"
                },
                {
                  "name": "_filter",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.collection.Collection(filter)"
                },
                {
                  "name": "k",
                  "annotation": null,
                  "description": null,
                  "value": "_FilterKeys(self)"
                },
                {
                  "name": "_orm",
                  "annotation": "bamboost.index.sqlmodel.CollectionORM | bamboost.index.sqlmodel.FilteredCollection",
                  "description": null,
                  "value": null
                },
                {
                  "name": "df",
                  "annotation": "pandas.pandas.DataFrame",
                  "description": [
                    {
                      "kind": "text",
                      "value": "View of the collection and its parametric space."
                    },
                    {
                      "kind": "returns",
                      "value": [
                        {
                          "name": "",
                          "annotation": "pandas.pandas.DataFrame",
                          "description": "A dataframe of the collection"
                        }
                      ]
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "example",
                    "description": ">>> db = Manager(\"path/to/db\")\n>>> db.df # DataFrame of the database"
                  },
                  "title": "Example"
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.collection.Collection.__init__",
                  "signature": "(self, path=None, *, uid=None, create_if_not_exist=True, comm=None, index_instance=None, sync_collection=True, filter=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "typing.Optional[bamboost._typing.StrPath]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "uid",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "create_if_not_exist",
                      "annotation": "bool",
                      "description": null,
                      "value": "True"
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index_instance",
                      "annotation": "typing.Optional[bamboost.index.Index]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "sync_collection",
                      "annotation": "bool",
                      "description": null,
                      "value": "True"
                    },
                    {
                      "name": "filter",
                      "annotation": "typing.Optional[bamboost.index._filtering.Filter]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    path: Optional[StrPath] = None,\n    *,\n    uid: Optional[str] = None,\n    create_if_not_exist: bool = True,\n    comm: Optional[Comm] = None,\n    index_instance: Optional[Index] = None,\n    sync_collection: bool = True,\n    filter: Optional[Filter] = None,\n):\n    assert path or uid, \"Either path or uid must be provided.\"\n    assert not (path and uid), \"Only one of path or uid must be provided.\"\n\n    self._index = index_instance or Index.default\n    self._filter = filter\n\n    # A key store with completion of all the parameters and metadata keys\n    self.k = _FilterKeys(self)\n\n    # Resolve the path (this updates the index if necessary)\n    self.path = Path(path or self._index.resolve_path(uid.upper())).absolute()\n\n    # Create the diretory for the collection if necessary\n    if not self.path.is_dir():\n        if not create_if_not_exist:\n            raise NotADirectoryError(\"Specified path does not exist.\")\n\n        self.path.mkdir(parents=True, exist_ok=False)  # create the directory\n        log.info(f\"Initialized directory for collection at {path}\")\n\n    # Resolve or get an UID for the collection (updates the index if necessary)\n    self.uid = CollectionUID(uid or self._index.resolve_uid(self.path))\n\n    # Check if identifier file exists (and create it if necessary)\n    if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n        create_identifier_file(self.path, self.uid)\n\n    if sync_collection:\n        # Sync the SQL table with the filesystem\n        # Making sure the collection is up to date in the index\n        self._index.sync_collection(self.uid, self.path)\n\n        # Wait for root process to finish syncing\n        self._comm.barrier()"
                },
                "__len__": {
                  "name": "__len__",
                  "path": "bamboost.core.collection.Collection.__len__",
                  "signature": "(self) -> int",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __len__(self) -> int:\n    return len(self._orm.simulations)"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.collection.Collection.__getitem__",
                  "signature": "(self, name) -> Simulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, name: str) -> Simulation:\n    return Simulation(name, self.path, self._comm)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.collection.Collection._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@cache\ndef _ipython_key_completions_(self):\n    return tuple(s.name for s in self._orm.simulations)"
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.core.collection.Collection._repr_html_",
                  "signature": "(self) -> str",
                  "description": "HTML repr for ipython/notebooks. Uses string replacement to fill the\ntemplate code.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    \"\"\"HTML repr for ipython/notebooks. Uses string replacement to fill the\n    template code.\n    \"\"\"\n    from jinja2 import Template\n\n    html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n    icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n    template = Template(html_string)\n\n    return template.render(\n        icon=icon,\n        db_path=f\"<a href={self.path.as_posix()}>{self.path}</a>\",\n        db_uid=self.uid,\n        db_size=len(self),\n        filtered=self._filter is not None,\n        filter=str(self._filter),\n    )"
                },
                "filter": {
                  "name": "filter",
                  "path": "bamboost.core.collection.Collection.filter",
                  "signature": "(self, *operators) -> Collection",
                  "description": "Filter the collection with the given operators.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "operators",
                      "annotation": "bamboost.index._filtering.Operator",
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.collection.Collection",
                    "description": "A new collection with the filtered simulations."
                  },
                  "docstring": [],
                  "source": "def filter(self, *operators: Operator) -> Collection:\n    \"\"\"Filter the collection with the given operators.\n\n    Args:\n        *operators: The operators to filter the collection with.\n\n    Returns:\n        A new collection with the filtered simulations.\n    \"\"\"\n    return Collection(\n        path=self.path,\n        create_if_not_exist=False,\n        sync_collection=False,\n        comm=self._comm,\n        index_instance=self._index,\n        filter=Filter(*operators) & self._filter,\n    )"
                },
                "all_simulation_names": {
                  "name": "all_simulation_names",
                  "path": "bamboost.core.collection.Collection.all_simulation_names",
                  "signature": "(self) -> list[str]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def all_simulation_names(self) -> list[str]:\n    return [sim.name for sim in self._orm.simulations]"
                },
                "sync_cache": {
                  "name": "sync_cache",
                  "path": "bamboost.core.collection.Collection.sync_cache",
                  "signature": "(self, *, force_all=False) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "force_all",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sync_cache(self, *, force_all: bool = False) -> None:\n    self._index.sync_collection(self.uid, self.path, force_all=force_all)"
                },
                "create_simulation": {
                  "name": "create_simulation",
                  "path": "bamboost.core.collection.Collection.create_simulation",
                  "signature": "(self, name=None, parameters=None, *, description=None, files=None, links=None, override=False) -> SimulationWriter",
                  "description": "Get a writer object for a new simulation. This is written for paralell use\nas it is likely that this may be used in an executable, creating multiple runs\nfor a parametric space, which may be run in paralell.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "parameters",
                      "annotation": "typing.Optional[typing.Dict[str, typing.Any]]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Parameter dictionary. If provided, the parameters will be\nchecked against the existing sims for duplication. Otherwise, they may be\nspecified later with `bamboost.core.simulation.Simulation.parameters`."
                        },
                        {
                          "kind": "admonition",
                          "value": {
                            "annotation": "note",
                            "description": "The parameters are stored in the h5 file as attributes.\n- If the value is a dict, it is flattened using\n  `bamboost.core.utilities.flatten_dict`.\n- If the value is a list/array, it is stored as a dataset."
                          },
                          "title": "Note"
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "description",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "files",
                      "annotation": "typing.Optional[typing.Iterable[str]]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "List of files to copy to the simulation directory."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "links",
                      "annotation": "typing.Optional[typing.Dict[str, str]]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary of links to other simulations."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "override",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.simulation.base.SimulationWriter",
                    "description": "A simulation writer object."
                  },
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "note",
                        "description": "The files and links are copied to the simulation directory. The files are\ncopied with the same name as the original file. The links are copied with\nthe given name."
                      },
                      "title": "Note"
                    },
                    {
                      "kind": "examples",
                      "value": [
                        [
                          "examples",
                          ">>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})"
                        ],
                        [
                          "examples",
                          ">>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")"
                        ]
                      ]
                    }
                  ],
                  "source": "def create_simulation(\n    self,\n    name: Optional[str] = None,\n    parameters: Optional[Dict[str, Any]] = None,\n    *,\n    description: Optional[str] = None,\n    files: Optional[Iterable[str]] = None,\n    links: Optional[Dict[str, str]] = None,\n    override: bool = False,\n) -> SimulationWriter:\n    \"\"\"Get a writer object for a new simulation. This is written for paralell use\n    as it is likely that this may be used in an executable, creating multiple runs\n    for a parametric space, which may be run in paralell.\n\n    Args:\n        uid: The name/uid for the simulation. If not specified, a random id\n            will be assigned.\n        parameters: Parameter dictionary. If provided, the parameters will be\n            checked against the existing sims for duplication. Otherwise, they may be\n            specified later with `bamboost.core.simulation.Simulation.parameters`.\n\n            Note:\n                The parameters are stored in the h5 file as attributes.\n                - If the value is a dict, it is flattened using\n                  `bamboost.core.utilities.flatten_dict`.\n                - If the value is a list/array, it is stored as a dataset.\n\n        skip_duplicate_check: if True, the duplicate check is skipped.\n        prefix: Prefix for the uid. If not specified, no prefix is used.\n        duplicate_action: how to deal with duplicates. Replace\n            first duplicate ('r'), Create with altered uid (`c`), Create new\n            with new id (`n`), Abort (`a`) default \"prompt\" for each\n            duplicate on a case by case basis.\n        note: Note for the simulation.\n        files: List of files to copy to the simulation directory.\n        links: Dictionary of links to other simulations.\n\n    Note:\n        The files and links are copied to the simulation directory. The files are\n        copied with the same name as the original file. The links are copied with\n        the given name.\n\n    Examples:\n        >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n        >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n\n    Returns:\n        A simulation writer object.\n    \"\"\"\n    import shutil\n\n    name = SimulationName(name)  # Generates a unique id as name if not provided\n    directory = self.path.joinpath(name)\n\n    # Check if name is already in use, otherwise create a new directory\n    if directory.exists():\n        if override:\n            if self._comm.rank == 0:\n                # drop the simulation from the index to avoid artefacts\n                # e.g. parameters from the old simulation\n                self._index._drop_simulation(self.uid, name)\n                shutil.rmtree(directory)\n        else:\n            raise FileExistsError(\n                f\"Simulation {name} already exists in {self.path}\"\n            )\n\n    if self._comm.rank == 0:\n        directory.mkdir(exist_ok=False)\n    self._comm.barrier()\n\n    try:\n        # Create the simulation instance\n        sim = SimulationWriter(\n            name, self.path, self._comm, self._index, collection_uid=self.uid\n        )\n        with sim._file.open(\"w\", driver=\"mpio\"), self._index.sql_transaction():\n            sim.initialize()  # create groups, set metadata and status\n            sim.metadata[\"description\"] = description or \"\"\n            sim.parameters.update(parameters or {})\n            sim.links.update(links or {})\n            sim.copy_files(files or [])\n\n        # Invalidate the file_map such that it is reloaded\n        sim._file.file_map.invalidate()\n\n        log.info(f\"Created simulation {name} in {self.path}\")\n        return sim\n    except (ValueError, PermissionError):\n        log.error(\n            f\"Error occurred while creating simulation {name} at path {self.path}\"\n        )\n        self._index._drop_simulation(self.uid, name)\n        shutil.rmtree(directory)\n        raise"
                },
                "_delete_simulation": {
                  "name": "_delete_simulation",
                  "path": "bamboost.core.collection.Collection._delete_simulation",
                  "signature": "(self, name) -> None",
                  "description": "CAUTIOUS. Deletes a simulation.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation to delete."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _delete_simulation(self, name: str) -> None:\n    \"\"\"CAUTIOUS. Deletes a simulation.\n\n    Args:\n        name: Name of the simulation to delete.\n    \"\"\"\n    dir_to_delete = self.path.joinpath(name)\n    if dir_to_delete.parent != self.path:\n        raise ValueError(f\"Invalid name given ({name}). Cannot delete.\")\n\n    import shutil\n\n    shutil.rmtree(dir_to_delete)"
                },
                "find": {
                  "name": "find",
                  "path": "bamboost.core.collection.Collection.find",
                  "signature": "(self, parameter_selection) -> pd.DataFrame",
                  "description": "Find simulations with the given parameters.\n\nThe dictionary can contain callables to filter inequalities or other\nfilters.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameter_selection",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter selection dictionary"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "examples",
                      "value": [
                        [
                          "examples",
                          ">>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n>>> db.find({\"a\": 1, \"b\": 2})"
                        ]
                      ]
                    }
                  ],
                  "source": "def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n    \"\"\"Find simulations with the given parameters.\n\n    The dictionary can contain callables to filter inequalities or other\n    filters.\n\n    Examples:\n        >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n        >>> db.find({\"a\": 1, \"b\": 2})\n\n    Args:\n        parameter_selection (dict): parameter selection dictionary\n    \"\"\"\n    parameter_selection = flatten_dict(parameter_selection)\n    params = {}\n    filters = {}\n    for key, val in parameter_selection.items():\n        if callable(val):\n            filters[key] = val\n        else:\n            params[key] = val\n\n    df = self.df\n    matches = self._list_duplicates(params, df=df)\n    matches = df[df.name.isin(matches)]\n    assert isinstance(matches, pd.DataFrame)\n    if len(matches) == 0:\n        return matches\n\n    for key, func in filters.items():\n        matches = cast(pd.DataFrame, matches[matches[key].apply(func)])\n\n    return matches"
                },
                "_list_duplicates": {
                  "name": "_list_duplicates",
                  "path": "bamboost.core.collection.Collection._list_duplicates",
                  "signature": "(self, parameters, *, df=None) -> list[str]",
                  "description": "List ids of duplicates of the given parameters.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter dictionary"
                        }
                      ]
                    },
                    {
                      "name": "df",
                      "annotation": "pandas.pandas.DataFrame | None",
                      "description": [
                        {
                          "kind": "text",
                          "value": "dataframe to search in. If not provided, the\ndataframe from the sql database is used."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _list_duplicates(\n    self, parameters: dict, *, df: pd.DataFrame | None = None\n) -> list[str]:\n    \"\"\"List ids of duplicates of the given parameters.\n\n    Args:\n        parameters: parameter dictionary\n        df: dataframe to search in. If not provided, the\n            dataframe from the sql database is used.\n    \"\"\"\n    import pandas as pd\n\n    if df is None:\n        df = self._orm.to_pandas()\n    params = flatten_dict(parameters)\n\n    class ComparableIterable:\n        def __init__(self, ori):\n            self.ori = np.asarray(ori)\n\n        def __eq__(self, other):\n            other = np.asarray(other)\n            if other.shape != self.ori.shape:\n                return False\n            return (other == self.ori).all()\n\n    # make all iterables comparable by converting them to ComparableIterable\n    for k in params.keys():\n        if isinstance(params[k], Iterable) and not isinstance(params[k], str):\n            params[k] = ComparableIterable(params[k])\n\n    # if any of the parameters is not in the dataframe, no duplicates\n    for p in params:\n        if p not in df.keys():\n            return []\n\n    # get matching rows where all values of the series are equal to the corresponding values in the dataframe\n    s = pd.Series(params)\n    match = df.loc[(df[s.keys()].apply(lambda row: (s == row).all(), axis=1))]\n    return match.name.tolist()"
                },
                "_check_duplicate": {
                  "name": "_check_duplicate",
                  "path": "bamboost.core.collection.Collection._check_duplicate",
                  "signature": "(self, parameters, uid, duplicate_action='prompt') -> tuple",
                  "description": "Checking whether the parameters dictionary exists already.\nMay need to be improved...",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter dictionary to check for"
                        }
                      ]
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "uid"
                        }
                      ]
                    },
                    {
                      "name": "duplicate_action",
                      "annotation": "str",
                      "description": null,
                      "value": "'prompt'"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "tuple",
                    "description": "Tuple(Bool, uid) wheter to continue and with what uid."
                  },
                  "docstring": [],
                  "source": "def _check_duplicate(\n    self, parameters: dict, uid: str, duplicate_action: str = \"prompt\"\n) -> tuple:\n    \"\"\"Checking whether the parameters dictionary exists already.\n    May need to be improved...\n\n    Args:\n        parameters: parameter dictionary to check for\n        uid: uid\n\n    Returns:\n        Tuple(Bool, uid) wheter to continue and with what uid.\n    \"\"\"\n\n    duplicates = self._list_duplicates(parameters)\n\n    if not duplicates:\n        return True, uid\n\n    print(\n        \"The parameter space already exists. Here are the duplicates:\",\n        flush=True,\n    )\n    print(self.df[self.df[\"name\"].isin([i for i in duplicates])], flush=True)\n\n    if duplicate_action == \"prompt\":\n        # What should be done?\n        prompt = input(\n            f\"`r`: Replace first duplicate [{duplicates[0]}]\\n\"\n            \"`n`: Create new with new id\\n\"\n            \"`a`: Abort\\n\"\n        )\n    else:\n        prompt = duplicate_action\n\n    if prompt == \"r\":\n        self._delete_simulation(duplicates[0])\n        return True, uid\n    if prompt == \"a\":\n        return False, uid\n    if prompt == \"n\":\n        return True, uid\n\n    raise ArgumentError(\"Answer not valid! Aborting\")"
                }
              },
              "source": "class Collection(ElligibleForPlugin):\n    \"\"\"View of database.\n\n    Args:\n        path: path to the directory of the database. If doesn't exist,\n            a new database will be created.\n        comm: MPI communicator\n        uid: UID of the database\n\n    Attributes:\n        ...\n\n    Example:\n        >>> db = Manager(\"path/to/db\")\n        >>> db.df # DataFrame of the database\n    \"\"\"\n\n    FROZEN = False  # TODO: If true, the collection doesn't look for new simulations after initialization\n    uid: CollectionUID\n    path: Path\n    fromUID = _CollectionPicker()\n    _comm = Communicator()\n\n    def __init__(\n        self,\n        path: Optional[StrPath] = None,\n        *,\n        uid: Optional[str] = None,\n        create_if_not_exist: bool = True,\n        comm: Optional[Comm] = None,\n        index_instance: Optional[Index] = None,\n        sync_collection: bool = True,\n        filter: Optional[Filter] = None,\n    ):\n        assert path or uid, \"Either path or uid must be provided.\"\n        assert not (path and uid), \"Only one of path or uid must be provided.\"\n\n        self._index = index_instance or Index.default\n        self._filter = filter\n\n        # A key store with completion of all the parameters and metadata keys\n        self.k = _FilterKeys(self)\n\n        # Resolve the path (this updates the index if necessary)\n        self.path = Path(path or self._index.resolve_path(uid.upper())).absolute()\n\n        # Create the diretory for the collection if necessary\n        if not self.path.is_dir():\n            if not create_if_not_exist:\n                raise NotADirectoryError(\"Specified path does not exist.\")\n\n            self.path.mkdir(parents=True, exist_ok=False)  # create the directory\n            log.info(f\"Initialized directory for collection at {path}\")\n\n        # Resolve or get an UID for the collection (updates the index if necessary)\n        self.uid = CollectionUID(uid or self._index.resolve_uid(self.path))\n\n        # Check if identifier file exists (and create it if necessary)\n        if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n            create_identifier_file(self.path, self.uid)\n\n        if sync_collection:\n            # Sync the SQL table with the filesystem\n            # Making sure the collection is up to date in the index\n            self._index.sync_collection(self.uid, self.path)\n\n            # Wait for root process to finish syncing\n            self._comm.barrier()\n\n    @property\n    def _orm(self) -> CollectionORM | FilteredCollection:\n        collection_orm = self._index.collection(self.uid)\n        if self._filter is None:\n            return collection_orm\n        return FilteredCollection(collection_orm, self._filter)\n\n    def __len__(self) -> int:\n        return len(self._orm.simulations)\n\n    def __getitem__(self, name: str) -> Simulation:\n        return Simulation(name, self.path, self._comm)\n\n    @cache\n    def _ipython_key_completions_(self):\n        return tuple(s.name for s in self._orm.simulations)\n\n    def _repr_html_(self) -> str:\n        \"\"\"HTML repr for ipython/notebooks. Uses string replacement to fill the\n        template code.\n        \"\"\"\n        from jinja2 import Template\n\n        html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n        icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n        template = Template(html_string)\n\n        return template.render(\n            icon=icon,\n            db_path=f\"<a href={self.path.as_posix()}>{self.path}</a>\",\n            db_uid=self.uid,\n            db_size=len(self),\n            filtered=self._filter is not None,\n            filter=str(self._filter),\n        )\n\n    @property\n    def df(self) -> pd.DataFrame:\n        \"\"\"View of the collection and its parametric space.\n\n        Returns:\n            A dataframe of the collection\n        \"\"\"\n        df = self._orm.to_pandas()\n\n        # Try to sort the dataframe with the user specified key\n        try:\n            df.sort_values(\n                config.options.sortTableKey,\n                inplace=True,\n                ascending=config.options.sortTableOrder == \"asc\",\n                ignore_index=True,\n            )\n        except KeyError:\n            pass\n\n        return df\n\n    def filter(self, *operators: Operator) -> Collection:\n        \"\"\"Filter the collection with the given operators.\n\n        Args:\n            *operators: The operators to filter the collection with.\n\n        Returns:\n            A new collection with the filtered simulations.\n        \"\"\"\n        return Collection(\n            path=self.path,\n            create_if_not_exist=False,\n            sync_collection=False,\n            comm=self._comm,\n            index_instance=self._index,\n            filter=Filter(*operators) & self._filter,\n        )\n\n    def all_simulation_names(self) -> list[str]:\n        return [sim.name for sim in self._orm.simulations]\n\n    def sync_cache(self, *, force_all: bool = False) -> None:\n        self._index.sync_collection(self.uid, self.path, force_all=force_all)\n\n    def create_simulation(\n        self,\n        name: Optional[str] = None,\n        parameters: Optional[Dict[str, Any]] = None,\n        *,\n        description: Optional[str] = None,\n        files: Optional[Iterable[str]] = None,\n        links: Optional[Dict[str, str]] = None,\n        override: bool = False,\n    ) -> SimulationWriter:\n        \"\"\"Get a writer object for a new simulation. This is written for paralell use\n        as it is likely that this may be used in an executable, creating multiple runs\n        for a parametric space, which may be run in paralell.\n\n        Args:\n            uid: The name/uid for the simulation. If not specified, a random id\n                will be assigned.\n            parameters: Parameter dictionary. If provided, the parameters will be\n                checked against the existing sims for duplication. Otherwise, they may be\n                specified later with `bamboost.core.simulation.Simulation.parameters`.\n\n                Note:\n                    The parameters are stored in the h5 file as attributes.\n                    - If the value is a dict, it is flattened using\n                      `bamboost.core.utilities.flatten_dict`.\n                    - If the value is a list/array, it is stored as a dataset.\n\n            skip_duplicate_check: if True, the duplicate check is skipped.\n            prefix: Prefix for the uid. If not specified, no prefix is used.\n            duplicate_action: how to deal with duplicates. Replace\n                first duplicate ('r'), Create with altered uid (`c`), Create new\n                with new id (`n`), Abort (`a`) default \"prompt\" for each\n                duplicate on a case by case basis.\n            note: Note for the simulation.\n            files: List of files to copy to the simulation directory.\n            links: Dictionary of links to other simulations.\n\n        Note:\n            The files and links are copied to the simulation directory. The files are\n            copied with the same name as the original file. The links are copied with\n            the given name.\n\n        Examples:\n            >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n            >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n\n        Returns:\n            A simulation writer object.\n        \"\"\"\n        import shutil\n\n        name = SimulationName(name)  # Generates a unique id as name if not provided\n        directory = self.path.joinpath(name)\n\n        # Check if name is already in use, otherwise create a new directory\n        if directory.exists():\n            if override:\n                if self._comm.rank == 0:\n                    # drop the simulation from the index to avoid artefacts\n                    # e.g. parameters from the old simulation\n                    self._index._drop_simulation(self.uid, name)\n                    shutil.rmtree(directory)\n            else:\n                raise FileExistsError(\n                    f\"Simulation {name} already exists in {self.path}\"\n                )\n\n        if self._comm.rank == 0:\n            directory.mkdir(exist_ok=False)\n        self._comm.barrier()\n\n        try:\n            # Create the simulation instance\n            sim = SimulationWriter(\n                name, self.path, self._comm, self._index, collection_uid=self.uid\n            )\n            with sim._file.open(\"w\", driver=\"mpio\"), self._index.sql_transaction():\n                sim.initialize()  # create groups, set metadata and status\n                sim.metadata[\"description\"] = description or \"\"\n                sim.parameters.update(parameters or {})\n                sim.links.update(links or {})\n                sim.copy_files(files or [])\n\n            # Invalidate the file_map such that it is reloaded\n            sim._file.file_map.invalidate()\n\n            log.info(f\"Created simulation {name} in {self.path}\")\n            return sim\n        except (ValueError, PermissionError):\n            log.error(\n                f\"Error occurred while creating simulation {name} at path {self.path}\"\n            )\n            self._index._drop_simulation(self.uid, name)\n            shutil.rmtree(directory)\n            raise\n\n    def _delete_simulation(self, name: str) -> None:\n        \"\"\"CAUTIOUS. Deletes a simulation.\n\n        Args:\n            name: Name of the simulation to delete.\n        \"\"\"\n        dir_to_delete = self.path.joinpath(name)\n        if dir_to_delete.parent != self.path:\n            raise ValueError(f\"Invalid name given ({name}). Cannot delete.\")\n\n        import shutil\n\n        shutil.rmtree(dir_to_delete)\n\n    def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n        \"\"\"Find simulations with the given parameters.\n\n        The dictionary can contain callables to filter inequalities or other\n        filters.\n\n        Examples:\n            >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n            >>> db.find({\"a\": 1, \"b\": 2})\n\n        Args:\n            parameter_selection (dict): parameter selection dictionary\n        \"\"\"\n        parameter_selection = flatten_dict(parameter_selection)\n        params = {}\n        filters = {}\n        for key, val in parameter_selection.items():\n            if callable(val):\n                filters[key] = val\n            else:\n                params[key] = val\n\n        df = self.df\n        matches = self._list_duplicates(params, df=df)\n        matches = df[df.name.isin(matches)]\n        assert isinstance(matches, pd.DataFrame)\n        if len(matches) == 0:\n            return matches\n\n        for key, func in filters.items():\n            matches = cast(pd.DataFrame, matches[matches[key].apply(func)])\n\n        return matches\n\n    def _list_duplicates(\n        self, parameters: dict, *, df: pd.DataFrame | None = None\n    ) -> list[str]:\n        \"\"\"List ids of duplicates of the given parameters.\n\n        Args:\n            parameters: parameter dictionary\n            df: dataframe to search in. If not provided, the\n                dataframe from the sql database is used.\n        \"\"\"\n        import pandas as pd\n\n        if df is None:\n            df = self._orm.to_pandas()\n        params = flatten_dict(parameters)\n\n        class ComparableIterable:\n            def __init__(self, ori):\n                self.ori = np.asarray(ori)\n\n            def __eq__(self, other):\n                other = np.asarray(other)\n                if other.shape != self.ori.shape:\n                    return False\n                return (other == self.ori).all()\n\n        # make all iterables comparable by converting them to ComparableIterable\n        for k in params.keys():\n            if isinstance(params[k], Iterable) and not isinstance(params[k], str):\n                params[k] = ComparableIterable(params[k])\n\n        # if any of the parameters is not in the dataframe, no duplicates\n        for p in params:\n            if p not in df.keys():\n                return []\n\n        # get matching rows where all values of the series are equal to the corresponding values in the dataframe\n        s = pd.Series(params)\n        match = df.loc[(df[s.keys()].apply(lambda row: (s == row).all(), axis=1))]\n        return match.name.tolist()\n\n    def _check_duplicate(\n        self, parameters: dict, uid: str, duplicate_action: str = \"prompt\"\n    ) -> tuple:\n        \"\"\"Checking whether the parameters dictionary exists already.\n        May need to be improved...\n\n        Args:\n            parameters: parameter dictionary to check for\n            uid: uid\n\n        Returns:\n            Tuple(Bool, uid) wheter to continue and with what uid.\n        \"\"\"\n\n        duplicates = self._list_duplicates(parameters)\n\n        if not duplicates:\n            return True, uid\n\n        print(\n            \"The parameter space already exists. Here are the duplicates:\",\n            flush=True,\n        )\n        print(self.df[self.df[\"name\"].isin([i for i in duplicates])], flush=True)\n\n        if duplicate_action == \"prompt\":\n            # What should be done?\n            prompt = input(\n                f\"`r`: Replace first duplicate [{duplicates[0]}]\\n\"\n                \"`n`: Create new with new id\\n\"\n                \"`a`: Abort\\n\"\n            )\n        else:\n            prompt = duplicate_action\n\n        if prompt == \"r\":\n            self._delete_simulation(duplicates[0])\n            return True, uid\n        if prompt == \"a\":\n            return False, uid\n        if prompt == \"n\":\n            return True, uid\n\n        raise ArgumentError(\"Answer not valid! Aborting\")",
              "inherited_members": {
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ]
              }
            }
          },
          "functions": {}
        },
        "utilities": {
          "name": "utilities",
          "path": "bamboost.core.utilities",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/utilities.py",
          "description": "Utility functions used by bamboost.",
          "docstring": [],
          "attributes": [
            {
              "name": "__all__",
              "annotation": null,
              "description": null,
              "value": "['flatten_dict', 'unflatten_dict', 'tree', 'h5_tree', 'show_differences', 'to_camel_case']"
            },
            {
              "name": "space",
              "annotation": null,
              "description": null,
              "value": "'    '"
            },
            {
              "name": "branch",
              "annotation": null,
              "description": null,
              "value": "'\u2502   '"
            },
            {
              "name": "tee",
              "annotation": null,
              "description": null,
              "value": "'\u251c\u2500\u2500 '"
            },
            {
              "name": "last",
              "annotation": null,
              "description": null,
              "value": "'\u2514\u2500\u2500 '"
            },
            {
              "name": "JobArguments",
              "annotation": null,
              "description": null,
              "value": "NamedTuple('JobArguments', [('db_path', Path), ('name', str), ('submit', bool), ('note', str)])"
            },
            {
              "name": "ScriptArguments",
              "annotation": null,
              "description": null,
              "value": "NamedTuple('ScriptArguments', [('simulation', str)])"
            }
          ],
          "modules": {},
          "classes": {
            "FilePicker": {
              "name": "FilePicker",
              "path": "bamboost.core.utilities.FilePicker",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "path",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.utilities.FilePicker(path)"
                },
                {
                  "name": "_dict",
                  "annotation": null,
                  "description": null,
                  "value": "self._build_file_dict(path)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.utilities.FilePicker.__init__",
                  "signature": "(self, path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, path: Path):\n    self.path = path\n    self._dict = self._build_file_dict(path)"
                },
                "_build_file_dict": {
                  "name": "_build_file_dict",
                  "path": "bamboost.core.utilities.FilePicker._build_file_dict",
                  "signature": "(self, path) -> dict",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _build_file_dict(self, path: Path) -> dict:\n    file_dict = {}\n\n    if not path.is_dir():\n        return file_dict\n\n    for f in path.iterdir():\n        if f.is_dir():\n            subdir_dict = self._build_file_dict(f)\n            file_dict.update({f\"{f.name}/{k}\": v for k, v in subdir_dict.items()})\n        else:\n            file_dict[f.name] = f.absolute()\n\n    return file_dict"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.utilities.FilePicker.__getitem__",
                  "signature": "(self, key) -> Path",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key) -> Path:\n    return self._dict[key]"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.utilities.FilePicker._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self):\n    return tuple(self._dict.keys())"
                },
                "__str__": {
                  "name": "__str__",
                  "path": "bamboost.core.utilities.FilePicker.__str__",
                  "signature": "(self, *_args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __str__(self, *_args):\n    return tree(self.path)"
                }
              },
              "source": "class FilePicker:\n    def __init__(self, path: Path):\n        self.path = path\n        self._dict = self._build_file_dict(path)\n\n    def _build_file_dict(self, path: Path) -> dict:\n        file_dict = {}\n\n        if not path.is_dir():\n            return file_dict\n\n        for f in path.iterdir():\n            if f.is_dir():\n                subdir_dict = self._build_file_dict(f)\n                file_dict.update({f\"{f.name}/{k}\": v for k, v in subdir_dict.items()})\n            else:\n                file_dict[f.name] = f.absolute()\n\n        return file_dict\n\n    def __getitem__(self, key) -> Path:\n        return self._dict[key]\n\n    def _ipython_key_completions_(self):\n        return tuple(self._dict.keys())\n\n    def __str__(self, *_args):\n        return tree(self.path)",
              "inherited_members": {}
            }
          },
          "functions": {
            "flatten_dict": {
              "name": "flatten_dict",
              "path": "bamboost.core.utilities.flatten_dict",
              "signature": "(dictionary, parent_key='', seperator='.') -> dict",
              "description": null,
              "parameters": [
                {
                  "name": "dictionary",
                  "annotation": "typing.Mapping",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent_key",
                  "annotation": null,
                  "description": null,
                  "value": "''"
                },
                {
                  "name": "seperator",
                  "annotation": null,
                  "description": null,
                  "value": "'.'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def flatten_dict(dictionary: Mapping, parent_key=\"\", seperator=\".\") -> dict:\n    items = []\n    for key, value in dictionary.items():\n        new_key = parent_key + seperator + key if parent_key else key\n        if isinstance(value, MutableMapping):\n            items.extend(flatten_dict(value, new_key, seperator=seperator).items())\n        else:\n            items.append((new_key, value))\n    return dict(items)"
            },
            "unflatten_dict": {
              "name": "unflatten_dict",
              "path": "bamboost.core.utilities.unflatten_dict",
              "signature": "(dictionary, seperator='.') -> dict",
              "description": null,
              "parameters": [
                {
                  "name": "dictionary",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "seperator",
                  "annotation": "str",
                  "description": null,
                  "value": "'.'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def unflatten_dict(dictionary: dict, seperator: str = \".\") -> dict:\n    new_dict = dict()\n    for key, value in dictionary.items():\n        parts = key.split(seperator)\n        d = new_dict\n        for part in parts[:-1]:\n            if part not in d:\n                d[part] = dict()\n            d = d[part]\n        d[parts[-1]] = value\n    return new_dict"
            },
            "tree": {
              "name": "tree",
              "path": "bamboost.core.utilities.tree",
              "signature": "(dir_path, level=-1, limit_to_directories=False, length_limit=1000) -> str",
              "description": "Given a directory Path object print a visual tree structure",
              "parameters": [
                {
                  "name": "dir_path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": null
                },
                {
                  "name": "level",
                  "annotation": "int",
                  "description": null,
                  "value": "-1"
                },
                {
                  "name": "limit_to_directories",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "length_limit",
                  "annotation": "int",
                  "description": null,
                  "value": "1000"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def tree(\n    dir_path: Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000,\n) -> str:\n    \"\"\"Given a directory Path object print a visual tree structure\"\"\"\n    dir_path = Path(dir_path)  # accept string coerceable to Path\n    files = 0\n    directories = 0\n    folder_symbol = \"\\U00002b57 \"\n\n    def inner(dir_path: Path, prefix: str = \"\", level=-1):\n        nonlocal files, directories\n        if not level:\n            return  # 0, stop iterating\n        if limit_to_directories:\n            contents = [d for d in dir_path.iterdir() if d.is_dir()]\n        else:\n            contents = list(dir_path.iterdir())\n        pointers = [tee] * (len(contents) - 1) + [last]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield prefix + pointer + \"\\U000025cc \" + path.name\n                directories += 1\n                extension = branch if pointer == tee else space\n                yield from inner(path, prefix=prefix + extension, level=level - 1)\n            elif not limit_to_directories:\n                yield prefix + pointer + path.name\n                files += 1\n\n    tree_string = \"\"\n    tree_string += (folder_symbol + dir_path.name) + \"\\n\"\n    iterator = inner(dir_path, level=level)\n    for line in islice(iterator, length_limit):\n        tree_string += (line) + \"\\n\"\n    if next(iterator, None):\n        tree_string += (f\"... length_limit, {length_limit}, reached, counted:\") + \"\\n\"\n    tree_string += (\n        f\"\\n{directories} directories\" + (f\", {files} files\" if files else \"\")\n    ) + \"\\n\"\n    return tree_string"
            },
            "h5_tree": {
              "name": "h5_tree",
              "path": "bamboost.core.utilities.h5_tree",
              "signature": "(val, pre='')",
              "description": null,
              "parameters": [
                {
                  "name": "val",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "pre",
                  "annotation": null,
                  "description": null,
                  "value": "''"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def h5_tree(val, pre=\"\"):\n    import h5py\n\n    items = len(val)\n    for key, val in val.items():\n        items -= 1\n        if items == 0:\n            # the last item\n            if isinstance(val, h5py.Group):\n                print(pre + \"\u2514\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"    \")\n            else:\n                print(pre + \"\u2514\u2500\u2500 \" + key + \" (%d)\" % len(val))\n        else:\n            if isinstance(val, h5py.Group):\n                print(pre + \"\u251c\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"\u2502   \")\n            else:\n                print(pre + \"\u251c\u2500\u2500 \" + key + \" (%d)\" % len(val))"
            },
            "show_differences": {
              "name": "show_differences",
              "path": "bamboost.core.utilities.show_differences",
              "signature": "(df) -> DataFrame",
              "description": "This function takes a pandas DataFrame as input and returns a modified\nDataFrame that shows only the columns which have differences.\n\nThe function first creates a copy of the input DataFrame to work with. It\nthen iterates over each column in the DataFrame and tries to calculate the\nnumber of unique values in that column. If successful, it adds the column\nname and number of unique values to a list of good results. If there is an\nerror, it attempts to apply json.dumps to the column and then calculate the\nnumber of unique values again. If this is successful, it also adds the\ncolumn name and number of unique values to the list of good results. If\nthere is still an error, it adds the column name and the error to a list of\nerrors.\n\nAfter processing all columns, the function removes any columns that had\nerrors from the DataFrame. It then sets the index of the DataFrame to 'id'\nand filters out any columns that have only one unique value. The modified\nDataFrame is then returned.",
              "parameters": [
                {
                  "name": "df",
                  "annotation": "pd.pd.DataFrame",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The input DataFrame to analyze"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "pandas.DataFrame",
                "description": "pd.DataFrame"
              },
              "docstring": [],
              "source": "def show_differences(df: \"DataFrame\") -> \"DataFrame\":\n    \"\"\"This function takes a pandas DataFrame as input and returns a modified\n    DataFrame that shows only the columns which have differences.\n\n    The function first creates a copy of the input DataFrame to work with. It\n    then iterates over each column in the DataFrame and tries to calculate the\n    number of unique values in that column. If successful, it adds the column\n    name and number of unique values to a list of good results. If there is an\n    error, it attempts to apply json.dumps to the column and then calculate the\n    number of unique values again. If this is successful, it also adds the\n    column name and number of unique values to the list of good results. If\n    there is still an error, it adds the column name and the error to a list of\n    errors.\n\n    After processing all columns, the function removes any columns that had\n    errors from the DataFrame. It then sets the index of the DataFrame to 'id'\n    and filters out any columns that have only one unique value. The modified\n    DataFrame is then returned.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame to analyze\n\n    Returns:\n        pd.DataFrame\n    \"\"\"\n    import json\n\n    df_diff = df.copy()\n    cols_nunique_good = []\n    cols_nunique_error = []\n    for col in df_diff.columns:\n        try:\n            nunique = df_diff[col].nunique()\n            cols_nunique_good.append((col, nunique))\n        except Exception:\n            try:\n                df_diff[col] = df_diff[col].apply(json.dumps)\n                nunique = df_diff[col].nunique()\n                cols_nunique_good.append((col, nunique))\n            except TypeError as e:\n                cols_nunique_error.append((col, e))\n\n    df_diff = df_diff[\n        df_diff.columns[~df_diff.columns.isin([col for col, _ in cols_nunique_error])]\n    ]\n    try:\n        df_diff.set_index(\"id\", inplace=True)\n    except KeyError:\n        pass\n    df_diff = df_diff.loc[:, (df_diff.nunique() != 1)]\n    df_diff.dropna(axis=1, how=\"all\", inplace=True)\n    return df_diff"
            },
            "to_camel_case": {
              "name": "to_camel_case",
              "path": "bamboost.core.utilities.to_camel_case",
              "signature": "(s) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "s",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def to_camel_case(s: str) -> str:\n    words = s.split()\n    camel_case = words[0].lower() + \"\".join([word.capitalize() for word in words[1:]])\n    return camel_case"
            },
            "parse_job_arguments": {
              "name": "parse_job_arguments",
              "path": "bamboost.core.utilities.parse_job_arguments",
              "signature": "() -> JobArguments",
              "description": "Parse command-line arguments for submitting a job to a bamboost database.",
              "parameters": [],
              "returns": {
                "name": "JobArguments",
                "annotation": "bamboost.core.utilities.JobArguments",
                "description": "A named tuple containing the parsed arguments."
              },
              "docstring": [],
              "source": "def parse_job_arguments() -> JobArguments:\n    \"\"\"Parse command-line arguments for submitting a job to a bamboost database.\n\n    Returns:\n        JobArguments: A named tuple containing the parsed arguments.\n    \"\"\"\n    parser = ArgumentParser(description=\"Submit a job to a bamboost database\")\n\n    # Add the database path argument\n    parser.add_argument(\"db_path\", type=Path, help=\"Path to the bamboost database\")\n    # Add the name argument as optional\n    parser.add_argument(\"name\", type=str, nargs=\"?\", help=\"Name of the simulation\")\n    # Add the submit flag as optional\n    parser.add_argument(\"--submit\", \"-s\", help=\"Submit the job\", action=\"store_true\")\n    # Add note\n    parser.add_argument(\n        \"--note\", \"-n\", help=\"Add a note to this job\", type=str, default=\"\"\n    )\n\n    args = parser.parse_args()\n\n    return JobArguments(\n        db_path=args.db_path, name=args.name, submit=args.submit, note=args.note\n    )"
            },
            "parse_script_arguments": {
              "name": "parse_script_arguments",
              "path": "bamboost.core.utilities.parse_script_arguments",
              "signature": "() -> ScriptArguments",
              "description": "Parse command-line arguments for a script using the bamboost system.",
              "parameters": [],
              "returns": {
                "name": "ScriptArguments",
                "annotation": "bamboost.core.utilities.ScriptArguments",
                "description": "A named tuple containing the parsed arguments."
              },
              "docstring": [],
              "source": "def parse_script_arguments() -> ScriptArguments:\n    \"\"\"Parse command-line arguments for a script using the bamboost system.\n\n    Returns:\n        ScriptArguments: A named tuple containing the parsed arguments.\n    \"\"\"\n    parser = ArgumentParser(description=\"Submit a job to a bamboost database\")\n\n    # Add the simulation UID argument\n    parser.add_argument(\n        \"--simulation\", type=str, help=\"UID of the simulation\", required=True\n    )\n\n    args = parser.parse_args()\n\n    return ScriptArguments(simulation=args.simulation)"
            }
          }
        },
        "hdf5": {
          "name": "hdf5",
          "path": "bamboost.core.hdf5",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/__init__.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {
            "hdf5path": {
              "name": "hdf5path",
              "path": "bamboost.core.hdf5.hdf5path",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/hdf5path.py",
              "description": null,
              "docstring": [],
              "attributes": [],
              "modules": {},
              "classes": {
                "HDF5Path": {
                  "name": "HDF5Path",
                  "path": "bamboost.core.hdf5.hdf5path.HDF5Path",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "parent",
                      "annotation": "bamboost.core.hdf5.hdf5path.HDF5Path",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parents",
                      "annotation": "typing.Generator[bamboost.core.hdf5.hdf5path.HDF5Path, None, None]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "basename",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.PurePosixPath",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.hdf5.hdf5path.HDF5Path.__new__",
                      "signature": "(cls, path, absolute=True)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "absolute",
                          "annotation": "bool",
                          "description": null,
                          "value": "True"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, path: str, absolute: bool = True):\n    if isinstance(path, HDF5Path):\n        return path\n    prefix = \"/\" if absolute else \"\"\n    return super().__new__(cls, prefix + \"/\".join(filter(None, path.split(\"/\"))))"
                    },
                    "__truediv__": {
                      "name": "__truediv__",
                      "path": "bamboost.core.hdf5.hdf5path.HDF5Path.__truediv__",
                      "signature": "(self, other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __truediv__(self, other: str) -> HDF5Path:\n    return self.joinpath(other)"
                    },
                    "joinpath": {
                      "name": "joinpath",
                      "path": "bamboost.core.hdf5.hdf5path.HDF5Path.joinpath",
                      "signature": "(self, *other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "str",
                          "description": null,
                          "value": "()"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def joinpath(self, *other: str) -> HDF5Path:\n    return HDF5Path(\"/\".join([self, *other]))"
                    },
                    "relative_to": {
                      "name": "relative_to",
                      "path": "bamboost.core.hdf5.hdf5path.HDF5Path.relative_to",
                      "signature": "(self, other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "typing.Union[bamboost.core.hdf5.hdf5path.HDF5Path, str]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def relative_to(self, other: Union[HDF5Path, str]) -> HDF5Path:\n    other = HDF5Path(other)\n    if not self.startswith(other):\n        raise ValueError(f\"{self} is not a subpath of {other}\")\n    return HDF5Path(self[len(other) :], absolute=False)"
                    },
                    "is_child_of": {
                      "name": "is_child_of",
                      "path": "bamboost.core.hdf5.hdf5path.HDF5Path.is_child_of",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "bamboost.core.hdf5.hdf5path.HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def is_child_of(self, other: HDF5Path) -> bool:\n    return other in self.parents"
                    }
                  },
                  "source": "class HDF5Path(str):\n    def __new__(cls, path: str, absolute: bool = True):\n        if isinstance(path, HDF5Path):\n            return path\n        prefix = \"/\" if absolute else \"\"\n        return super().__new__(cls, prefix + \"/\".join(filter(None, path.split(\"/\"))))\n\n    def __truediv__(self, other: str) -> HDF5Path:\n        return self.joinpath(other)\n\n    def joinpath(self, *other: str) -> HDF5Path:\n        return HDF5Path(\"/\".join([self, *other]))\n\n    def relative_to(self, other: Union[HDF5Path, str]) -> HDF5Path:\n        other = HDF5Path(other)\n        if not self.startswith(other):\n            raise ValueError(f\"{self} is not a subpath of {other}\")\n        return HDF5Path(self[len(other) :], absolute=False)\n\n    @property\n    def parent(self) -> HDF5Path:\n        return HDF5Path(self.rsplit(\"/\", 1)[0] or \"/\")\n\n    @property\n    def parents(self) -> Generator[HDF5Path, None, None]:\n        current = self\n        while current != \"/\":\n            current = current.parent\n            yield current\n\n    @property\n    def basename(self) -> str:\n        return self.rsplit(\"/\", 1)[-1]\n\n    @property\n    def path(self) -> PurePosixPath:\n        return PurePosixPath(self)\n\n    def is_child_of(self, other: HDF5Path) -> bool:\n        return other in self.parents",
                  "inherited_members": {}
                }
              },
              "functions": {}
            },
            "filemap": {
              "name": "filemap",
              "path": "bamboost.core.hdf5.filemap",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/filemap.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "_VT_filemap",
                  "annotation": null,
                  "description": null,
                  "value": "typing.Type[typing.Union[h5py.h5py.Group, h5py.h5py.Dataset]]"
                }
              ],
              "modules": {},
              "classes": {
                "KeysViewHDF5": {
                  "name": "KeysViewHDF5",
                  "path": "bamboost.core.hdf5.filemap.KeysViewHDF5",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "__repr__",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.hdf5.filemap.KeysViewHDF5.__str__"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__str__": {
                      "name": "__str__",
                      "path": "bamboost.core.hdf5.filemap.KeysViewHDF5.__str__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __str__(self) -> str:\n    return \"<KeysViewHDF5 {}>\".format(list(self))"
                    }
                  },
                  "source": "class KeysViewHDF5(KeysView):\n    def __str__(self) -> str:\n        return \"<KeysViewHDF5 {}>\".format(list(self))\n\n    __repr__ = __str__",
                  "inherited_members": {}
                },
                "_FileMapMixin": {
                  "name": "_FileMapMixin",
                  "path": "bamboost.core.hdf5.filemap._FileMapMixin",
                  "description": null,
                  "parameters": [],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "keys": {
                      "name": "keys",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin.keys",
                      "signature": "(self) -> KeysViewHDF5",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def keys(self) -> KeysViewHDF5:\n    return KeysViewHDF5(self)"
                    },
                    "datasets": {
                      "name": "datasets",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin.datasets",
                      "signature": "(self) -> tuple[str, ...]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def datasets(self) -> tuple[str, ...]:\n    return tuple(k for k, v in self.items() if v is h5py.Dataset)"
                    },
                    "groups": {
                      "name": "groups",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin.groups",
                      "signature": "(self) -> tuple[str, ...]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def groups(self) -> tuple[str, ...]:\n    return tuple(k for k, v in self.items() if v is h5py.Group)"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return self.keys()"
                    },
                    "_repr_pretty_": {
                      "name": "_repr_pretty_",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin._repr_pretty_",
                      "signature": "(self, p, _cycle)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "p",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "_cycle",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _repr_pretty_(self, p, _cycle):\n    p.pretty(dict(self))"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.filemap._FileMapMixin.__repr__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self):\n    return f\"{type(self).__name__}({dict(self)})\""
                    }
                  },
                  "source": "class _FileMapMixin(Mapping[HDF5Path, _VT_filemap]):\n    def keys(self) -> KeysViewHDF5:\n        return KeysViewHDF5(self)\n\n    def datasets(self) -> tuple[str, ...]:\n        return tuple(k for k, v in self.items() if v is h5py.Dataset)\n\n    def groups(self) -> tuple[str, ...]:\n        return tuple(k for k, v in self.items() if v is h5py.Group)\n\n    def _ipython_key_completions_(self):\n        return self.keys()\n\n    def _repr_pretty_(self, p, _cycle):\n        p.pretty(dict(self))\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({dict(self)})\"",
                  "inherited_members": {}
                },
                "FileMap": {
                  "name": "FileMap",
                  "path": "bamboost.core.hdf5.filemap.FileMap",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_valid",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.hdf5.filemap.FileMap(file)"
                    },
                    {
                      "name": "_dict",
                      "annotation": "dict[bamboost.core.hdf5.hdf5path.HDF5Path, bamboost.core.hdf5.filemap._VT_filemap]",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "valid",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    self._dict: dict[HDF5Path, _VT_filemap] = {}\n    self.valid = False"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__getitem__",
                      "signature": "(self, key) -> _VT_filemap",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str, /) -> _VT_filemap:\n    return self._dict[HDF5Path(key)]"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "bamboost.core.hdf5.filemap._VT_filemap",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __setitem__(self, key: str, value: _VT_filemap) -> None:\n    self._dict[HDF5Path(key)] = value"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __delitem__(self, key: str) -> None:\n    self._dict.pop(HDF5Path(key))"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__iter__",
                      "signature": "(self) -> Iterator[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self) -> Iterator[HDF5Path]:\n    return iter(self._dict)"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.filemap.FileMap.__len__",
                      "signature": "(self) -> int",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self) -> int:\n    return len(self._dict)"
                    },
                    "populate": {
                      "name": "populate",
                      "path": "bamboost.core.hdf5.filemap.FileMap.populate",
                      "signature": "(self, *, exclude_numeric=False) -> None",
                      "description": "Assumes the file is open.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exclude_numeric",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def populate(self, *, exclude_numeric: bool = False) -> None:\n    \"\"\"Assumes the file is open.\"\"\"\n\n    # visit all groups and datasets to cache them\n    def cache_items(name, _obj):\n        path = HDF5Path(name)\n        if exclude_numeric and path.basename.isdigit():\n            return\n        self._dict[path] = type(_obj)\n\n    self._file.visititems(cache_items)\n    self.valid = True"
                    },
                    "invalidate": {
                      "name": "invalidate",
                      "path": "bamboost.core.hdf5.filemap.FileMap.invalidate",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def invalidate(self) -> None:\n    self.valid = False"
                    }
                  },
                  "source": "class FileMap(MutableMapping[HDF5Path, _VT_filemap], _FileMapMixin):\n    _valid: bool\n\n    def __init__(self, file: HDF5File):\n        self._file = file\n        self._dict: dict[HDF5Path, _VT_filemap] = {}\n        self.valid = False\n\n    def __getitem__(self, key: str, /) -> _VT_filemap:\n        return self._dict[HDF5Path(key)]\n\n    def __setitem__(self, key: str, value: _VT_filemap) -> None:\n        self._dict[HDF5Path(key)] = value\n\n    def __delitem__(self, key: str) -> None:\n        self._dict.pop(HDF5Path(key))\n\n    def __iter__(self) -> Iterator[HDF5Path]:\n        return iter(self._dict)\n\n    def __len__(self) -> int:\n        return len(self._dict)\n\n    def populate(self, *, exclude_numeric: bool = False) -> None:\n        \"\"\"Assumes the file is open.\"\"\"\n\n        # visit all groups and datasets to cache them\n        def cache_items(name, _obj):\n            path = HDF5Path(name)\n            if exclude_numeric and path.basename.isdigit():\n                return\n            self._dict[path] = type(_obj)\n\n        self._file.visititems(cache_items)\n        self.valid = True\n\n    def invalidate(self) -> None:\n        self.valid = False",
                  "inherited_members": {
                    "bamboost.core.hdf5.filemap._FileMapMixin": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin._repr_pretty_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.__repr__"
                      }
                    ]
                  }
                },
                "FilteredFileMap": {
                  "name": "FilteredFileMap",
                  "path": "bamboost.core.hdf5.filemap.FilteredFileMap",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file_map",
                      "annotation": "bamboost.core.hdf5.filemap.FileMap",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "parent",
                      "annotation": null,
                      "description": null,
                      "value": "HDF5Path(parent)"
                    },
                    {
                      "name": "file_map",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.hdf5.filemap.FilteredFileMap(file_map)"
                    },
                    {
                      "name": "valid",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__init__",
                      "signature": "(self, file_map, parent) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file_map",
                          "annotation": "bamboost.core.hdf5.filemap.FileMap",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file_map: FileMap, parent: str) -> None:\n    self.parent = HDF5Path(parent)\n    self.file_map = file_map"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__getitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str, /):\n    return self.file_map[self.parent.joinpath(key)]"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__setitem__",
                      "signature": "(self, key, value)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __setitem__(self, key: str, value):\n    self.file_map[self.parent.joinpath(key)] = value"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__delitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __delitem__(self, key):\n    del self.file_map[self.parent.joinpath(key)]"
                    },
                    "children": {
                      "name": "children",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.children",
                      "signature": "(self) -> Iterator[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def children(self) -> Iterator[HDF5Path]:\n    return filter(lambda path: \"/\" not in path, self)"
                    },
                    "children_groups": {
                      "name": "children_groups",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.children_groups",
                      "signature": "(self) -> Iterator[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def children_groups(self) -> Iterator[HDF5Path]:\n    return filter(lambda path: self[path] is h5py.Group, self.children())"
                    },
                    "children_datasets": {
                      "name": "children_datasets",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.children_datasets",
                      "signature": "(self) -> Iterator[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def children_datasets(self) -> Iterator[HDF5Path]:\n    return filter(lambda path: self[path] is h5py.Dataset, self.children())"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    return map(\n        lambda x: HDF5Path(x).relative_to(self.parent),\n        filter(\n            lambda x: HDF5Path(x).is_child_of(self.parent),\n            self.file_map,\n        ),\n    )"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.filemap.FilteredFileMap.__len__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self):\n    return sum(1 for _ in self.__iter__())"
                    }
                  },
                  "source": "class FilteredFileMap(MutableMapping[HDF5Path, _VT_filemap], _FileMapMixin):\n    def __init__(self, file_map: FileMap, parent: str) -> None:\n        self.parent = HDF5Path(parent)\n        self.file_map = file_map\n\n    @property\n    def valid(self) -> bool:\n        return self.file_map.valid\n\n    @valid.setter\n    def valid(self, value: bool) -> None:\n        self.file_map.valid = value\n\n    def __getitem__(self, key: str, /):\n        return self.file_map[self.parent.joinpath(key)]\n\n    def __setitem__(self, key: str, value):\n        self.file_map[self.parent.joinpath(key)] = value\n\n    def __delitem__(self, key):\n        del self.file_map[self.parent.joinpath(key)]\n\n    def children(self) -> Iterator[HDF5Path]:\n        return filter(lambda path: \"/\" not in path, self)\n\n    def children_groups(self) -> Iterator[HDF5Path]:\n        return filter(lambda path: self[path] is h5py.Group, self.children())\n\n    def children_datasets(self) -> Iterator[HDF5Path]:\n        return filter(lambda path: self[path] is h5py.Dataset, self.children())\n\n    def __iter__(self):\n        return map(\n            lambda x: HDF5Path(x).relative_to(self.parent),\n            filter(\n                lambda x: HDF5Path(x).is_child_of(self.parent),\n                self.file_map,\n            ),\n        )\n\n    def __len__(self):\n        return sum(1 for _ in self.__iter__())",
                  "inherited_members": {
                    "bamboost.core.hdf5.filemap._FileMapMixin": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin._repr_pretty_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.filemap._FileMapMixin.__repr__"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "ref": {
              "name": "ref",
              "path": "bamboost.core.hdf5.ref",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/ref.py",
              "description": "This module provides a high-level abstraction for working with HDF5 (`h5py`) groups and\ndatasets. It is built on the concept of describing an object in the file with a reference\nto it (deterministic reference: a file instance, and a path inside the HDF file).\n\nThe reference handles file opening and closing, and provides a simple interface to\ndata, attributes and subgroups. In essence, this model provides `h5py` objects like any\nother in-memory data structure.",
              "docstring": [
                {
                  "kind": "classes",
                  "value": [
                    {
                      "name": "H5Reference",
                      "annotation": null,
                      "description": "\nBase class for Groups and Datasets."
                    },
                    {
                      "name": "Group",
                      "annotation": null,
                      "description": "\nRead-only group reference."
                    },
                    {
                      "name": "MutableGroup",
                      "annotation": null,
                      "description": "\nMutable group reference."
                    },
                    {
                      "name": "Dataset",
                      "annotation": null,
                      "description": "\nRead-only dataset reference."
                    }
                  ]
                }
              ],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild('hdf5')"
                },
                {
                  "name": "MPI_ACTIVE",
                  "annotation": null,
                  "description": null,
                  "value": "'mpio' in h5py.h5py.registered_drivers() and h5py.h5py.get_config().mpi and bamboost.mpi.MPI_ON"
                },
                {
                  "name": "_RT_group",
                  "annotation": null,
                  "description": null,
                  "value": "TypeVar('_RT_group', bound=Union['Group', 'Dataset'])"
                },
                {
                  "name": "_g",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.hdf5.ref.Group"
                },
                {
                  "name": "_d",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.core.hdf5.ref.Dataset"
                }
              ],
              "modules": {},
              "classes": {
                "InvalidReferenceError": {
                  "name": "InvalidReferenceError",
                  "path": "bamboost.core.hdf5.ref.InvalidReferenceError",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "bamboost.core.hdf5.hdf5path.HDF5Path",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "filename",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.ref.InvalidReferenceError.__init__",
                      "signature": "(self, path, filename)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "bamboost.core.hdf5.hdf5path.HDF5Path",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "filename",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path: HDF5Path, filename: str):\n    super().__init__(f\"Object {path} not found in file {filename}\")"
                    }
                  },
                  "source": "class InvalidReferenceError(KeyError):\n    def __init__(self, path: HDF5Path, filename: str):\n        super().__init__(f\"Object {path} not found in file {filename}\")",
                  "inherited_members": {}
                },
                "RefStatus": {
                  "name": "RefStatus",
                  "path": "bamboost.core.hdf5.ref.RefStatus",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "INVALID",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    },
                    {
                      "name": "VALID",
                      "annotation": null,
                      "description": null,
                      "value": "1"
                    },
                    {
                      "name": "NOT_CHECKED",
                      "annotation": null,
                      "description": null,
                      "value": "2"
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class RefStatus(IntEnum):\n    INVALID = 0\n    VALID = 1\n    NOT_CHECKED = 2",
                  "inherited_members": {}
                },
                "H5Reference": {
                  "name": "H5Reference",
                  "path": "bamboost.core.hdf5.ref.H5Reference",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_status",
                      "annotation": "bamboost.core.hdf5.ref.RefStatus",
                      "description": null,
                      "value": "bamboost.core.hdf5.ref.RefStatus.bamboost.core.hdf5.ref.RefStatus.NOT_CHECKED"
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.hdf5.ref.H5Reference(file)"
                    },
                    {
                      "name": "_path",
                      "annotation": null,
                      "description": null,
                      "value": "HDF5Path(path)"
                    },
                    {
                      "name": "_obj",
                      "annotation": "typing.Union[h5py.h5py.Group, h5py.h5py.Dataset, h5py.h5py.Datatype]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Returns the h5py object bound at the path of this reference."
                        },
                        {
                          "kind": "raises",
                          "value": [
                            {
                              "annotation": "KeyError",
                              "description": "'Unable to synchronously open object (invalid identifier type to function)'\nIf the file is not open. Or if the object at the path does not exist."
                            }
                          ]
                        }
                      ],
                      "value": null
                    },
                    {
                      "name": "attrs",
                      "annotation": "bamboost.core.hdf5.attrsdict.AttrsDict[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__init__",
                      "signature": "(self, path, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path: str, file: HDF5File[_MT]):\n    self._file = file\n    self._path = HDF5Path(path)\n\n    # We validate the existance of the object in the file by first, checking the file\n    # map (avoiding a file operation), and if it is not there, we check the file.\n    if self._path in self._file.file_map:\n        self._status = RefStatus.VALID\n        return\n\n    # If we deal with an immutable file, we can't create a new reference.\n    # We decide to immediately check the validity of the reference and raise an\n    # Exception if it is invalid.\n    if not self._file.mutable:\n        if not self._is_valid():\n            raise InvalidReferenceError(self._path, self._file._filename)\n        self._status = RefStatus.VALID"
                    },
                    "_is_valid": {
                      "name": "_is_valid",
                      "path": "bamboost.core.hdf5.ref.H5Reference._is_valid",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef _is_valid(self):\n    try:\n        _ = self._obj\n        return True\n    except KeyError:\n        return False"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    valid_str = (\n        \"NOT_CHECKED\"\n        if self._status == RefStatus.NOT_CHECKED\n        else \"VALID\"\n        if self._status == RefStatus.VALID\n        else \"INVALID\"\n    )\n    return f'<HDF5 {type(self).__name__} \"{self._path}\" ({valid_str}, file {self._file._filename})>'"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__",
                      "signature": "(self, value)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, value):\n    if isinstance(value, str):\n        if _type := self._file.file_map.get(self._path / value):\n            return self.new(\n                self._path.joinpath(value),\n                self._file,\n                Group if _type == h5py.Group else Dataset,\n            )\n\n    with self._file.open(FileMode.READ):\n        obj = self._obj\n        assert not isinstance(obj, h5py.Datatype), (\n            \"__getitem__ not implemented for Datatype\"\n        )\n\n        # If the value is a slice or empty tuple, we return the sliced dataset\n        if isinstance(value, slice) or (\n            isinstance(value, tuple) and len(value) == 0\n        ):\n            return obj[value]\n\n        # Here we know that we are looking for a group or dataset\n        if isinstance(value, tuple):\n            name, _type = value\n        else:\n            name, _type = cast(str, value), None\n        return self.new(self._path / name, self._file, _type)"
                    },
                    "new": {
                      "name": "new",
                      "path": "bamboost.core.hdf5.ref.H5Reference.new",
                      "signature": "(cls, path, file, _type=None) -> _RT_group",
                      "description": "Returns a new pointer object.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "_type",
                          "annotation": "typing.Optional[typing.Type[bamboost.core.hdf5.ref._RT_group]]",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef new(\n    cls,\n    path: str,\n    file: HDF5File[_MT],\n    _type: Optional[Type[_RT_group]] = None,\n) -> _RT_group:\n    \"\"\"Returns a new pointer object.\"\"\"\n    if _type:\n        return _type(path, file)\n\n    with file.open(FileMode.READ):\n        _obj = file[path]\n        if isinstance(_obj, h5py.Group):\n            return cast(_RT_group, Group(path, file))\n        elif isinstance(_obj, h5py.Dataset):\n            return cast(_RT_group, Dataset(path, file))\n        else:\n            raise ValueError(f\"Object {path} is not a group or dataset\")"
                    }
                  },
                  "source": "class H5Reference(H5Object[_MT]):\n    _status: RefStatus = RefStatus.NOT_CHECKED\n\n    def __init__(self, path: str, file: HDF5File[_MT]):\n        self._file = file\n        self._path = HDF5Path(path)\n\n        # We validate the existance of the object in the file by first, checking the file\n        # map (avoiding a file operation), and if it is not there, we check the file.\n        if self._path in self._file.file_map:\n            self._status = RefStatus.VALID\n            return\n\n        # If we deal with an immutable file, we can't create a new reference.\n        # We decide to immediately check the validity of the reference and raise an\n        # Exception if it is invalid.\n        if not self._file.mutable:\n            if not self._is_valid():\n                raise InvalidReferenceError(self._path, self._file._filename)\n            self._status = RefStatus.VALID\n\n    @property\n    def _obj(self) -> Union[h5py.Group, h5py.Dataset, h5py.Datatype]:\n        \"\"\"Returns the h5py object bound at the path of this reference.\n\n        Raises:\n            KeyError: 'Unable to synchronously open object (invalid identifier type to function)'\n                If the file is not open. Or if the object at the path does not exist.\n        \"\"\"\n        _obj = self._file[self._path]\n        self._status = RefStatus.VALID\n        return _obj\n\n    @with_file_open(FileMode.READ)\n    def _is_valid(self):\n        try:\n            _ = self._obj\n            return True\n        except KeyError:\n            return False\n\n    def __repr__(self) -> str:\n        valid_str = (\n            \"NOT_CHECKED\"\n            if self._status == RefStatus.NOT_CHECKED\n            else \"VALID\"\n            if self._status == RefStatus.VALID\n            else \"INVALID\"\n        )\n        return f'<HDF5 {type(self).__name__} \"{self._path}\" ({valid_str}, file {self._file._filename})>'\n\n    @overload\n    def __getitem__(self, value: str) -> Union[Self, Dataset]: ...\n    @overload\n    def __getitem__(self, value: Union[slice, Tuple[()]]) -> Any: ...\n    @overload\n    def __getitem__(self, value: tuple[str, Type[Group]]) -> Group[_MT]: ...\n    @overload\n    def __getitem__(self, value: tuple[str, Type[Dataset]]) -> Dataset[_MT]: ...\n    def __getitem__(self, value):\n        if isinstance(value, str):\n            if _type := self._file.file_map.get(self._path / value):\n                return self.new(\n                    self._path.joinpath(value),\n                    self._file,\n                    Group if _type == h5py.Group else Dataset,\n                )\n\n        with self._file.open(FileMode.READ):\n            obj = self._obj\n            assert not isinstance(obj, h5py.Datatype), (\n                \"__getitem__ not implemented for Datatype\"\n            )\n\n            # If the value is a slice or empty tuple, we return the sliced dataset\n            if isinstance(value, slice) or (\n                isinstance(value, tuple) and len(value) == 0\n            ):\n                return obj[value]\n\n            # Here we know that we are looking for a group or dataset\n            if isinstance(value, tuple):\n                name, _type = value\n            else:\n                name, _type = cast(str, value), None\n            return self.new(self._path / name, self._file, _type)\n\n    @classmethod\n    def new(\n        cls,\n        path: str,\n        file: HDF5File[_MT],\n        _type: Optional[Type[_RT_group]] = None,\n    ) -> _RT_group:\n        \"\"\"Returns a new pointer object.\"\"\"\n        if _type:\n            return _type(path, file)\n\n        with file.open(FileMode.READ):\n            _obj = file[path]\n            if isinstance(_obj, h5py.Group):\n                return cast(_RT_group, Group(path, file))\n            elif isinstance(_obj, h5py.Dataset):\n                return cast(_RT_group, Dataset(path, file))\n            else:\n                raise ValueError(f\"Object {path} is not a group or dataset\")\n\n    @cached_property\n    def attrs(self) -> AttrsDict[_MT]:\n        return AttrsDict(self._file, self._path)\n\n    @property\n    @with_file_open(FileMode.READ)\n    def parent(self) -> Group[_MT]:\n        return Group(self._obj.parent.name or \"\", self._file)",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "Group": {
                  "name": "Group",
                  "path": "bamboost.core.hdf5.ref.Group",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_group_map",
                      "annotation": null,
                      "description": null,
                      "value": "FilteredFileMap(file.file_map, path)"
                    },
                    {
                      "name": "_status",
                      "annotation": null,
                      "description": null,
                      "value": "RefStatus(_valid)"
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.h5py.Group",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.ref.Group.__init__",
                      "signature": "(self, path, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path, file):\n    super().__init__(path, file)\n\n    # Create a subset view of the file map with all objects\n    self._group_map = FilteredFileMap(file.file_map, path)\n\n    # In addition to the base class, we test if the object is not a group\n    # first check by file map, fallback: check with file operation\n    # Try except for edge case where the file is not created yet.\n    try:\n        _valid = (file.file_map.get(self._path) is h5py.Group) or self._is_valid()\n    except FileNotFoundError:\n        _valid = True\n    self._status = RefStatus(_valid)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.ref.Group.__setitem__",
                      "signature": "(self, key, newvalue)",
                      "description": "Used to set an attribute.\nWill be written as an attribute to the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "newvalue",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Group[Mutable], key, newvalue):\n    \"\"\"Used to set an attribute.\n    Will be written as an attribute to the group.\n    \"\"\"\n    if isinstance(newvalue, np.ndarray):\n        self.add_numerical_dataset(key, np.array(newvalue))\n    else:\n        self.attrs.__setitem__(key, newvalue)"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.ref.Group.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": "Deletes an item.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND)\ndef __delitem__(self: Group[Mutable], key) -> None:\n    \"\"\"Deletes an item.\"\"\"\n    if key in self.attrs.keys():\n        del self.attrs[key]\n    else:\n        self._file.delete_object(self._path / key)"
                    },
                    "__contains__": {
                      "name": "__contains__",
                      "path": "bamboost.core.hdf5.ref.Group.__contains__",
                      "signature": "(self, key) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __contains__(self, key: str) -> bool:\n    return key in self._group_map"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return self.keys()"
                    },
                    "_is_valid": {
                      "name": "_is_valid",
                      "path": "bamboost.core.hdf5.ref.Group._is_valid",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef _is_valid(self):\n    try:\n        obj = self._obj\n        return isinstance(obj, h5py.Group)\n    except KeyError:\n        return False"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.ref.Group.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    for key in self.keys():\n        yield self.__getitem__(key)"
                    },
                    "_assert_file_map_is_valid": {
                      "name": "_assert_file_map_is_valid",
                      "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _assert_file_map_is_valid(self):\n    if not self._group_map.valid:\n        with self._file.open(FileMode.READ):\n            self._group_map.file_map.populate()"
                    },
                    "keys": {
                      "name": "keys",
                      "path": "bamboost.core.hdf5.ref.Group.keys",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def keys(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.keys()"
                    },
                    "groups": {
                      "name": "groups",
                      "path": "bamboost.core.hdf5.ref.Group.groups",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def groups(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.children_groups()"
                    },
                    "datasets": {
                      "name": "datasets",
                      "path": "bamboost.core.hdf5.ref.Group.datasets",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def datasets(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.children_datasets()"
                    },
                    "items": {
                      "name": "items",
                      "path": "bamboost.core.hdf5.ref.Group.items",
                      "signature": "(self, *, filter=None) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "filter",
                          "annotation": "typing.Optional[typing.Literal['groups', 'datasets']]",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def items(\n    self,\n    *,\n    filter: Optional[Literal[\"groups\", \"datasets\"]] = None,\n) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]:\n    if filter:\n        keys = (\n            self._group_map.children_groups()\n            if filter == \"groups\"\n            else self._group_map.children_datasets()\n        )\n    else:\n        keys = self._group_map.children()\n\n    for key in keys:\n        yield key, self.__getitem__(key)"
                    },
                    "_repr_html_": {
                      "name": "_repr_html_",
                      "path": "bamboost.core.hdf5.ref.Group._repr_html_",
                      "signature": "(self)",
                      "description": "Repr showing the content of the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef _repr_html_(self):\n    \"\"\"Repr showing the content of the group.\"\"\"\n    # If the object is not a group, return a simple representation\n    try:\n        _obj = self._obj\n    except ValueError:\n        self._status = RefStatus.INVALID\n        return f\"Invalid HDF5 object: <b>{self._path}</b> is not a group\"\n    except KeyError:\n        self._status = RefStatus.INVALID\n        return f\"Invalid HDF5 object: <b>{self._path}</b> not found in file\"\n\n    from jinja2 import Template\n\n    attrs = self.attrs\n    groups = {key: len(_obj[self._path / key]) for key in self.groups()}  # type: ignore\n    datasets = {\n        key: (_obj[self._path / key].dtype, _obj[self._path / key].shape)  # type: ignore\n        for key in self.datasets()\n    }\n\n    path = self._path\n    path = path if path[0] == \"/\" else \"/\" + path\n\n    html_template = pkgutil.get_data(\n        bamboost.__name__, \"_repr/hdf5_group.html\"\n    ).decode()  # type: ignore\n    icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n    template = Template(html_template)\n\n    return template.render(\n        uid=Path(self._file._filename).parent.name,\n        name=path,\n        icon=icon,\n        version=bamboost.__version__,\n        attrs=attrs,\n        groups=groups,\n        datasets=datasets,\n    )"
                    },
                    "require_self": {
                      "name": "require_self",
                      "path": "bamboost.core.hdf5.ref.Group.require_self",
                      "signature": "(self) -> None",
                      "description": "Create the group if it doesn't exist yet.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND)\ndef require_self(self: Group[Mutable]) -> None:\n    \"\"\"Create the group if it doesn't exist yet.\"\"\"\n    self._file.require_group(self._path)\n    self._file.file_map[self._path] = h5py.Group\n    self._status = RefStatus.VALID"
                    },
                    "require_group": {
                      "name": "require_group",
                      "path": "bamboost.core.hdf5.ref.Group.require_group",
                      "signature": "(self, name, *, return_type=None)",
                      "description": "Create a group if it doesn't exist yet.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "return_type",
                          "annotation": null,
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND, driver=\"mpio\")\ndef require_group(self, name, *, return_type=None):\n    \"\"\"Create a group if it doesn't exist yet.\"\"\"\n    self._obj.require_group(name)\n\n    # update file_map\n    self._group_map[name] = h5py.Group\n\n    return self.new(self._path.joinpath(name), self._file, _type=return_type)"
                    },
                    "require_dataset": {
                      "name": "require_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.require_dataset",
                      "signature": "(self, name, shape, dtype, exact=False, **kwargs) -> h5py.Dataset",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "shape",
                          "annotation": "tuple[int, ...]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "dtype",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exact",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef require_dataset(\n    self: Group[Mutable],\n    name: str,\n    shape: tuple[int, ...],\n    dtype,\n    exact: bool = False,\n    **kwargs,\n) -> h5py.Dataset:\n    grp = self._obj.require_dataset(name, shape, dtype, exact=exact, **kwargs)\n    self._group_map[name] = h5py.Dataset  # type: ignore\n    return grp"
                    },
                    "add_numerical_dataset": {
                      "name": "add_numerical_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset",
                      "signature": "(self, name, vector, attrs=None, dtype=None, *, file_map=True) -> None",
                      "description": "Add a dataset to the group. Error is thrown if attempting to overwrite\nwith different shape than before. If same shape, data is overwritten\n(this is inherited from h5py -> require_dataset)",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Name for the dataset"
                            }
                          ]
                        },
                        {
                          "name": "vector",
                          "annotation": "numpy.numpy.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Data to write (max 2d)"
                            }
                          ]
                        },
                        {
                          "name": "attrs",
                          "annotation": "typing.Optional[typing.Dict[str, typing.Any]]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Attributes of dataset."
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "dtype",
                          "annotation": "typing.Optional[str]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. dtype of dataset. If not specified, uses dtype of inpyt array"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "file_map",
                          "annotation": "bool",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. If True, the dataset is added to the file map. Default is True."
                            }
                          ],
                          "value": "True"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef add_numerical_dataset(\n    self: Group[Mutable],\n    name: str,\n    vector: np.ndarray,\n    attrs: Optional[Dict[str, Any]] = None,\n    dtype: Optional[str] = None,\n    *,\n    file_map: bool = True,\n) -> None:\n    \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n    with different shape than before. If same shape, data is overwritten\n    (this is inherited from h5py -> require_dataset)\n\n    Args:\n        name: Name for the dataset\n        vector: Data to write (max 2d)\n        attrs: Optional. Attributes of dataset.\n        dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n        file_map: Optional. If True, the dataset is added to the file map. Default is True.\n    \"\"\"\n    if attrs is None:\n        attrs = {}\n    length_local = vector.shape[0]\n    length_p = np.array(self._file._comm.allgather(length_local))\n    length = np.sum(length_p)\n    dim = vector.shape[1:]\n    vec_shape = length, *dim\n\n    ranks = np.array([i for i in range(self._file._comm.size)])\n    idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n    idx_end = idx_start + length_local\n\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        dataset = self._obj.require_dataset(\n            name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n        )\n        dataset[idx_start:idx_end] = vector\n\n        def _write_attrs():\n            self._obj[name].attrs.update(attrs)\n\n        self.post_write_instruction(_write_attrs)\n\n    log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n    # update file_map\n    if file_map:\n        self._group_map[name] = h5py.Dataset"
                    },
                    "add_dataset": {
                      "name": "add_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.add_dataset",
                      "signature": "(self, name, data, attrs=None, dtype=None) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "attrs",
                          "annotation": "typing.Optional[typing.Dict[str, typing.Any]]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "dtype",
                          "annotation": "typing.Optional[str]",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef add_dataset(\n    self: Group[Mutable],\n    name: str,\n    data: Any,\n    attrs: Optional[Dict[str, Any]] = None,\n    dtype: Optional[str] = None,\n) -> None:\n    def _write_instruction():\n        self._obj.create_dataset(name, data=data, dtype=dtype)\n        if attrs:\n            self._obj[name].attrs.update(attrs)\n        log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n    self.post_write_instruction(_write_instruction)\n\n    # update file_map\n    self._group_map[name] = h5py.Dataset"
                    }
                  },
                  "source": "class Group(H5Reference[_MT]):\n    def __init__(self, path, file):\n        super().__init__(path, file)\n\n        # Create a subset view of the file map with all objects\n        self._group_map = FilteredFileMap(file.file_map, path)\n\n        # In addition to the base class, we test if the object is not a group\n        # first check by file map, fallback: check with file operation\n        # Try except for edge case where the file is not created yet.\n        try:\n            _valid = (file.file_map.get(self._path) is h5py.Group) or self._is_valid()\n        except FileNotFoundError:\n            _valid = True\n        self._status = RefStatus(_valid)\n\n    @mutable_only\n    def __setitem__(self: Group[Mutable], key, newvalue):\n        \"\"\"Used to set an attribute.\n        Will be written as an attribute to the group.\n        \"\"\"\n        if isinstance(newvalue, np.ndarray):\n            self.add_numerical_dataset(key, np.array(newvalue))\n        else:\n            self.attrs.__setitem__(key, newvalue)\n\n    @mutable_only\n    @with_file_open(FileMode.APPEND)\n    def __delitem__(self: Group[Mutable], key) -> None:\n        \"\"\"Deletes an item.\"\"\"\n        if key in self.attrs.keys():\n            del self.attrs[key]\n        else:\n            self._file.delete_object(self._path / key)\n\n    def __contains__(self, key: str) -> bool:\n        return key in self._group_map\n\n    def _ipython_key_completions_(self):\n        return self.keys()\n\n    @property\n    def _obj(self) -> h5py.Group:\n        _obj = super()._obj\n        if not isinstance(_obj, h5py.Group):\n            raise ValueError(f\"Object {self._path} is not a group\")\n        return _obj\n\n    @with_file_open(FileMode.READ)\n    def _is_valid(self):\n        try:\n            obj = self._obj\n            return isinstance(obj, h5py.Group)\n        except KeyError:\n            return False\n\n    def __iter__(self):\n        for key in self.keys():\n            yield self.__getitem__(key)\n\n    def _assert_file_map_is_valid(self):\n        if not self._group_map.valid:\n            with self._file.open(FileMode.READ):\n                self._group_map.file_map.populate()\n\n    def keys(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.keys()\n\n    def groups(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.children_groups()\n\n    def datasets(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.children_datasets()\n\n    def items(\n        self,\n        *,\n        filter: Optional[Literal[\"groups\", \"datasets\"]] = None,\n    ) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]:\n        if filter:\n            keys = (\n                self._group_map.children_groups()\n                if filter == \"groups\"\n                else self._group_map.children_datasets()\n            )\n        else:\n            keys = self._group_map.children()\n\n        for key in keys:\n            yield key, self.__getitem__(key)\n\n    @with_file_open(FileMode.READ)\n    def _repr_html_(self):\n        \"\"\"Repr showing the content of the group.\"\"\"\n        # If the object is not a group, return a simple representation\n        try:\n            _obj = self._obj\n        except ValueError:\n            self._status = RefStatus.INVALID\n            return f\"Invalid HDF5 object: <b>{self._path}</b> is not a group\"\n        except KeyError:\n            self._status = RefStatus.INVALID\n            return f\"Invalid HDF5 object: <b>{self._path}</b> not found in file\"\n\n        from jinja2 import Template\n\n        attrs = self.attrs\n        groups = {key: len(_obj[self._path / key]) for key in self.groups()}  # type: ignore\n        datasets = {\n            key: (_obj[self._path / key].dtype, _obj[self._path / key].shape)  # type: ignore\n            for key in self.datasets()\n        }\n\n        path = self._path\n        path = path if path[0] == \"/\" else \"/\" + path\n\n        html_template = pkgutil.get_data(\n            bamboost.__name__, \"_repr/hdf5_group.html\"\n        ).decode()  # type: ignore\n        icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n        template = Template(html_template)\n\n        return template.render(\n            uid=Path(self._file._filename).parent.name,\n            name=path,\n            icon=icon,\n            version=bamboost.__version__,\n            attrs=attrs,\n            groups=groups,\n            datasets=datasets,\n        )\n\n    @mutable_only\n    @with_file_open(FileMode.APPEND)\n    def require_self(self: Group[Mutable]) -> None:\n        \"\"\"Create the group if it doesn't exist yet.\"\"\"\n        self._file.require_group(self._path)\n        self._file.file_map[self._path] = h5py.Group\n        self._status = RefStatus.VALID\n\n    @overload\n    def require_group(\n        self: Group[Mutable],\n        name: str,\n        *,\n        return_type: Type[_RT_group],\n    ) -> _RT_group: ...\n    @overload\n    def require_group(self: Group[Mutable], name: str) -> Group[Mutable]: ...\n    @mutable_only\n    @with_file_open(FileMode.APPEND, driver=\"mpio\")\n    def require_group(self, name, *, return_type=None):\n        \"\"\"Create a group if it doesn't exist yet.\"\"\"\n        self._obj.require_group(name)\n\n        # update file_map\n        self._group_map[name] = h5py.Group\n\n        return self.new(self._path.joinpath(name), self._file, _type=return_type)\n\n    @mutable_only\n    def require_dataset(\n        self: Group[Mutable],\n        name: str,\n        shape: tuple[int, ...],\n        dtype,\n        exact: bool = False,\n        **kwargs,\n    ) -> h5py.Dataset:\n        grp = self._obj.require_dataset(name, shape, dtype, exact=exact, **kwargs)\n        self._group_map[name] = h5py.Dataset  # type: ignore\n        return grp\n\n    @mutable_only\n    def add_numerical_dataset(\n        self: Group[Mutable],\n        name: str,\n        vector: np.ndarray,\n        attrs: Optional[Dict[str, Any]] = None,\n        dtype: Optional[str] = None,\n        *,\n        file_map: bool = True,\n    ) -> None:\n        \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n        with different shape than before. If same shape, data is overwritten\n        (this is inherited from h5py -> require_dataset)\n\n        Args:\n            name: Name for the dataset\n            vector: Data to write (max 2d)\n            attrs: Optional. Attributes of dataset.\n            dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n            file_map: Optional. If True, the dataset is added to the file map. Default is True.\n        \"\"\"\n        if attrs is None:\n            attrs = {}\n        length_local = vector.shape[0]\n        length_p = np.array(self._file._comm.allgather(length_local))\n        length = np.sum(length_p)\n        dim = vector.shape[1:]\n        vec_shape = length, *dim\n\n        ranks = np.array([i for i in range(self._file._comm.size)])\n        idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n        idx_end = idx_start + length_local\n\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            dataset = self._obj.require_dataset(\n                name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n            )\n            dataset[idx_start:idx_end] = vector\n\n            def _write_attrs():\n                self._obj[name].attrs.update(attrs)\n\n            self.post_write_instruction(_write_attrs)\n\n        log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n        # update file_map\n        if file_map:\n            self._group_map[name] = h5py.Dataset\n\n    @mutable_only\n    def add_dataset(\n        self: Group[Mutable],\n        name: str,\n        data: Any,\n        attrs: Optional[Dict[str, Any]] = None,\n        dtype: Optional[str] = None,\n    ) -> None:\n        def _write_instruction():\n            self._obj.create_dataset(name, data=data, dtype=dtype)\n            if attrs:\n                self._obj[name].attrs.update(attrs)\n            log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n        self.post_write_instruction(_write_instruction)\n\n        # update file_map\n        self._group_map[name] = h5py.Dataset",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "Dataset": {
                  "name": "Dataset",
                  "path": "bamboost.core.hdf5.ref.Dataset",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_obj",
                      "annotation": "h5py.h5py.Dataset",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "shape",
                      "annotation": "tuple[int, ...]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dtype",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "array",
                      "annotation": "numpy.numpy.ndarray",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.ref.Dataset.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "tuple | slice | int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef __getitem__(self, key: tuple | slice | int) -> Any:\n    return h5py.Dataset.__getitem__(self._obj, key)"
                    }
                  },
                  "source": "class Dataset(H5Reference[_MT]):\n    @property\n    def _obj(self) -> h5py.Dataset:\n        obj = super()._obj\n        if not isinstance(obj, h5py.Dataset):\n            raise ValueError(f\"Object {self._path} is not a dataset\")\n        return obj\n\n    @with_file_open(FileMode.READ)\n    def __getitem__(self, key: tuple | slice | int) -> Any:\n        return h5py.Dataset.__getitem__(self._obj, key)\n\n    @property\n    @with_file_open(FileMode.READ)\n    def shape(self) -> tuple[int, ...]:\n        return self._obj.shape\n\n    @property\n    @with_file_open(FileMode.READ)\n    def dtype(self):\n        return self._obj.dtype\n\n    @property\n    @with_file_open(FileMode.READ)\n    def array(self) -> np.ndarray:\n        return self._obj[()]",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__init__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference._is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "attrsdict": {
              "name": "attrsdict",
              "path": "bamboost.core.hdf5.attrsdict",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/attrsdict.py",
              "description": "This module provides `AttrsDict`, a dictionary-like object that is synced with the\nattributes of a group in the HDF5 file.\n\nKey features:\n- The object is tied to a simulation. If the simulation is read-only, the object is\n  read-only too.\n- Automatic synchronization: Updates to the mapping are pushed to the file immediately\n  when the simulation is mutable.\n- Thread safe and MPI-compatible. Uses the `single_process_queue` of the file object to\n  handle attribute updates.",
              "docstring": [],
              "attributes": [
                {
                  "name": "AttrsEncoder",
                  "annotation": null,
                  "description": null,
                  "value": "_AttrsEncoder()"
                }
              ],
              "modules": {},
              "classes": {
                "_AttrsEncoder": {
                  "name": "_AttrsEncoder",
                  "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_encoders",
                      "annotation": "typing.Dict[typing.Type, typing.Callable[[typing.Any], typing.Any]]",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "_decoders",
                      "annotation": "typing.Dict[typing.Type, typing.Callable[[typing.Any], typing.Any]]",
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder.__init__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self):\n    self._encoders: Dict[Type, Callable[[Any], Any]] = {}\n    self._decoders: Dict[Type, Callable[[Any], Any]] = {}"
                    },
                    "register_encoder": {
                      "name": "register_encoder",
                      "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder.register_encoder",
                      "signature": "(self, typ, encode)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "typ",
                          "annotation": "typing.Union[typing.Type, typing.Sequence[typing.Type]]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "encode",
                          "annotation": "typing.Callable",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def register_encoder(self, typ: Union[Type, Sequence[Type]], encode: Callable):\n    if isinstance(typ, Sequence):\n        for t in typ:\n            self._encoders[t] = encode\n    else:\n        self._encoders[typ] = encode"
                    },
                    "register_decoder": {
                      "name": "register_decoder",
                      "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder.register_decoder",
                      "signature": "(self, typ, decode)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "typ",
                          "annotation": "typing.Union[typing.Type, typing.Sequence[typing.Type]]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "decode",
                          "annotation": "typing.Callable",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def register_decoder(self, typ: Union[Type, Sequence[Type]], decode: Callable):\n    if isinstance(typ, Sequence):\n        for t in typ:\n            self._decoders[t] = decode\n    else:\n        self._decoders[typ] = decode"
                    },
                    "encode": {
                      "name": "encode",
                      "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder.encode",
                      "signature": "(self, obj) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "obj",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def encode(self, obj: Any) -> Any:\n    if isinstance(obj, dict):\n        return {k: self.encode(v) for k, v in obj.items()}\n    elif isinstance(obj, list):\n        return [self.encode(v) for v in obj]\n    else:\n        for typ, encoder in self._encoders.items():\n            if isinstance(obj, typ):\n                encoded = encoder(obj)\n                return json.dumps({\"__type__\": typ.__name__, \"__value__\": encoded})\n        return obj"
                    },
                    "decode": {
                      "name": "decode",
                      "path": "bamboost.core.hdf5.attrsdict._AttrsEncoder.decode",
                      "signature": "(self, obj) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "obj",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def decode(self, obj: Any) -> Any:\n    if isinstance(obj, str):\n        try:\n            decoded_json = json.loads(obj)\n            if (\n                isinstance(decoded_json, dict)\n                and \"__type__\" in decoded_json\n                and \"__value__\" in decoded_json\n            ):\n                typ_name = decoded_json[\"__type__\"]\n                for typ, decoder in self._decoders.items():\n                    if typ.__name__ == typ_name:\n                        return decoder(decoded_json[\"__value__\"])\n            # fallback to return the original string\n            return obj\n        except json.JSONDecodeError:\n            return obj  # Return the original string if not a special encoded type\n    elif isinstance(obj, Mapping):\n        return {k: self.decode(v) for k, v in obj.items()}\n    elif isinstance(obj, Sequence):\n        return [self.decode(v) for v in obj]\n    else:\n        for typ, decoder in self._decoders.items():\n            if isinstance(obj, typ):\n                return decoder(obj)\n    return obj"
                    }
                  },
                  "source": "class _AttrsEncoder:\n    def __init__(self):\n        self._encoders: Dict[Type, Callable[[Any], Any]] = {}\n        self._decoders: Dict[Type, Callable[[Any], Any]] = {}\n\n    def register_encoder(self, typ: Union[Type, Sequence[Type]], encode: Callable):\n        if isinstance(typ, Sequence):\n            for t in typ:\n                self._encoders[t] = encode\n        else:\n            self._encoders[typ] = encode\n\n    def register_decoder(self, typ: Union[Type, Sequence[Type]], decode: Callable):\n        if isinstance(typ, Sequence):\n            for t in typ:\n                self._decoders[t] = decode\n        else:\n            self._decoders[typ] = decode\n\n    def encode(self, obj: Any) -> Any:\n        if isinstance(obj, dict):\n            return {k: self.encode(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [self.encode(v) for v in obj]\n        else:\n            for typ, encoder in self._encoders.items():\n                if isinstance(obj, typ):\n                    encoded = encoder(obj)\n                    return json.dumps({\"__type__\": typ.__name__, \"__value__\": encoded})\n            return obj\n\n    def decode(self, obj: Any) -> Any:\n        if isinstance(obj, str):\n            try:\n                decoded_json = json.loads(obj)\n                if (\n                    isinstance(decoded_json, dict)\n                    and \"__type__\" in decoded_json\n                    and \"__value__\" in decoded_json\n                ):\n                    typ_name = decoded_json[\"__type__\"]\n                    for typ, decoder in self._decoders.items():\n                        if typ.__name__ == typ_name:\n                            return decoder(decoded_json[\"__value__\"])\n                # fallback to return the original string\n                return obj\n            except json.JSONDecodeError:\n                return obj  # Return the original string if not a special encoded type\n        elif isinstance(obj, Mapping):\n            return {k: self.decode(v) for k, v in obj.items()}\n        elif isinstance(obj, Sequence):\n            return [self.decode(v) for v in obj]\n        else:\n            for typ, decoder in self._decoders.items():\n                if isinstance(obj, typ):\n                    return decoder(obj)\n        return obj",
                  "inherited_members": {}
                },
                "AttrsDict": {
                  "name": "AttrsDict",
                  "path": "bamboost.core.hdf5.attrsdict.AttrsDict",
                  "description": "A dictionary-like object for the attributes of a group in the HDF5\nfile.\n\nThis object is tied to a simulation. If the simulation is read-only, the\nobject is immutable. If mutable, changes are pushed to the HDF5 file\nimmediately.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "path to the group in the HDF5 file"
                        }
                      ]
                    }
                  ],
                  "attributes": [
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "_path",
                      "annotation": "str",
                      "description": null,
                      "value": "bamboost.core.hdf5.attrsdict.AttrsDict(path)"
                    },
                    {
                      "name": "_dict",
                      "annotation": "collections.abc.MutableMapping",
                      "description": null,
                      "value": "self.read()"
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.h5py.HLObject",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "set",
                      "annotation": null,
                      "description": [
                        {
                          "kind": "text",
                          "value": "Set an attribute. This method is a an alias for `__setitem__`."
                        },
                        {
                          "kind": "parameters",
                          "value": [
                            {
                              "name": "key",
                              "annotation": null,
                              "description": "attribute name"
                            },
                            {
                              "name": "value",
                              "annotation": null,
                              "description": "attribute value"
                            }
                          ]
                        }
                      ],
                      "value": "bamboost.core.hdf5.attrsdict.AttrsDict.__setitem__"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__new__",
                      "signature": "(cls, *args, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "args",
                          "annotation": null,
                          "description": null,
                          "value": "()"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, *args, **kwargs):\n    if cls is not AttrsDict:\n        return super().__new__(cls)\n\n    # Singleton pattern for base attrs dict class\n    # signature: __new__(cls, file: HDF5File[_MT], path: str)\n    file = args[0] if args else kwargs.get(\"file\")\n    path = HDF5Path(args[1]) if len(args) > 1 else kwargs.get(\"path\")\n\n    instances = file._attrs_dict_instances\n    if path not in instances:\n        instances[path] = super().__new__(cls)\n    return instances[path]"
                    },
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__init__",
                      "signature": "(self, file, path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File[_MT], path: str):\n    super().__init__(file)\n    self._path = path\n    self._dict = self.read()"
                    },
                    "read": {
                      "name": "read",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.read",
                      "signature": "(self) -> dict",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef read(self) -> dict:\n    return dict(AttrsEncoder.decode(self._obj.attrs))"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Any:\n    return self._dict[key]"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return tuple(self._dict.keys())"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    return iter(self._dict)"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__len__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self):\n    return len(self._dict)"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    return self._dict.__repr__()"
                    },
                    "__str__": {
                      "name": "__str__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__str__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __str__(self) -> str:\n    return f\"<AttrsDict(path={self._path})>\""
                    },
                    "_repr_pretty_": {
                      "name": "_repr_pretty_",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict._repr_pretty_",
                      "signature": "(self, p, cycle)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "p",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "cycle",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _repr_pretty_(self, p, cycle):\n    cls_name = type(self).__name__\n    if cycle:\n        p.text(f\"{cls_name}(...)\")\n    else:\n        with p.group(8, f\"{cls_name}(\", \")\"):\n            p.pretty(self._dict)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.attrsdict.AttrsDict[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: AttrsDict[Mutable], key: str, value: Any) -> None:\n    self._dict[key] = value\n    self.post_write_instruction(\n        lambda: self._obj.attrs.__setitem__(key, AttrsEncoder.encode(value))\n    )"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.attrsdict.AttrsDict[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __delitem__(self: AttrsDict[Mutable], key: str) -> None:\n    del self._dict[key]\n    self.post_write_instruction(lambda: self._obj.attrs.__delitem__(key))"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.hdf5.attrsdict.AttrsDict.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the dictionary. This method pushes the update to the HDF5\nfile.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.attrsdict.AttrsDict[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "dict",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new dictionary"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: AttrsDict[Mutable], update_dict: dict) -> None:\n    \"\"\"Update the dictionary. This method pushes the update to the HDF5\n    file.\n\n    Args:\n        update_dict: new dictionary\n    \"\"\"\n    self._dict.update(update_dict)\n    self.post_write_instruction(\n        lambda: self._obj.attrs.update(AttrsEncoder.encode(update_dict))\n    )"
                    }
                  },
                  "source": "class AttrsDict(H5Object[_MT], Mapping):\n    \"\"\"A dictionary-like object for the attributes of a group in the HDF5\n    file.\n\n    This object is tied to a simulation. If the simulation is read-only, the\n    object is immutable. If mutable, changes are pushed to the HDF5 file\n    immediately.\n\n    Args:\n        simulation: the simulation object\n        path: path to the group in the HDF5 file\n    \"\"\"\n\n    mutable: bool = False\n    _path: str\n    _dict: MutableMapping\n\n    def __new__(cls, *args, **kwargs):\n        if cls is not AttrsDict:\n            return super().__new__(cls)\n\n        # Singleton pattern for base attrs dict class\n        # signature: __new__(cls, file: HDF5File[_MT], path: str)\n        file = args[0] if args else kwargs.get(\"file\")\n        path = HDF5Path(args[1]) if len(args) > 1 else kwargs.get(\"path\")\n\n        instances = file._attrs_dict_instances\n        if path not in instances:\n            instances[path] = super().__new__(cls)\n        return instances[path]\n\n    def __init__(self, file: HDF5File[_MT], path: str):\n        super().__init__(file)\n        self._path = path\n        self._dict = self.read()\n\n    @with_file_open(FileMode.READ)\n    def read(self) -> dict:\n        return dict(AttrsEncoder.decode(self._obj.attrs))\n\n    def __getitem__(self, key: str) -> Any:\n        return self._dict[key]\n\n    def _ipython_key_completions_(self):\n        return tuple(self._dict.keys())\n\n    def __iter__(self):\n        return iter(self._dict)\n\n    def __len__(self):\n        return len(self._dict)\n\n    def __repr__(self) -> str:\n        return self._dict.__repr__()\n\n    def __str__(self) -> str:\n        return f\"<AttrsDict(path={self._path})>\"\n\n    def _repr_pretty_(self, p, cycle):\n        cls_name = type(self).__name__\n        if cycle:\n            p.text(f\"{cls_name}(...)\")\n        else:\n            with p.group(8, f\"{cls_name}(\", \")\"):\n                p.pretty(self._dict)\n\n    @property\n    def _obj(self) -> h5py.HLObject:\n        obj = self._file[self._path]\n        return obj\n\n    @mutable_only\n    def __setitem__(self: AttrsDict[Mutable], key: str, value: Any) -> None:\n        self._dict[key] = value\n        self.post_write_instruction(\n            lambda: self._obj.attrs.__setitem__(key, AttrsEncoder.encode(value))\n        )\n\n    set = __setitem__\n    \"\"\"Set an attribute. This method is a an alias for `__setitem__`.\n\n    Args:\n        key: attribute name\n        value: attribute value\n    \"\"\"\n\n    @mutable_only\n    def __delitem__(self: AttrsDict[Mutable], key: str) -> None:\n        del self._dict[key]\n        self.post_write_instruction(lambda: self._obj.attrs.__delitem__(key))\n\n    @mutable_only\n    def update(self: AttrsDict[Mutable], update_dict: dict) -> None:\n        \"\"\"Update the dictionary. This method pushes the update to the HDF5\n        file.\n\n        Args:\n            update_dict: new dictionary\n        \"\"\"\n        self._dict.update(update_dict)\n        self.post_write_instruction(\n            lambda: self._obj.attrs.update(AttrsEncoder.encode(update_dict))\n        )",
                  "inherited_members": {
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "file": {
              "name": "file",
              "path": "bamboost.core.hdf5.file",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/file.py",
              "description": "This module provides an enhanced interface for working with HDF5 files. Its main goal is\nto provide automatic file management with heavy caching to limit file access to a minimum.\n\nKey features:\n- Lazy h5py.File wrapper: `HDF5File` postpones file opening until necessary.\n- Cached file map: `FileMap` caches all groups and datasets in the file. We also implement\n  a singleton pattern for the file map to avoid multiple instances of the same file. This\n  allows to subsequent usage of the file map (and the file in general) while skipping file\n  access.\n- Automatic handling of opening the file when necessary using a context stack, which\n  enables knowing when the file is no longer needed.\n- Queued operations enable the bundling of operations. This is useful to bundle operations\n  which require to be executed on the root process only (such as attribute updating). The\n  queued operations are executed once the serial context is closed. If the file is not\n  used when something is added to the queue, it is executed immediately.\n- Utility classes for working with HDF5 paths.\n- Decorators to handle file opening, and file mutability checks (avoid write when not\n  intended).",
              "docstring": [
                {
                  "kind": "classes",
                  "value": [
                    {
                      "name": "FileMode",
                      "annotation": null,
                      "description": "\nEnum representing different file modes (READ, WRITE, APPEND, etc.)."
                    },
                    {
                      "name": "HDF5Path",
                      "annotation": null,
                      "description": "\nA specialized string class to handle HDF5-style paths."
                    },
                    {
                      "name": "HasFile ",
                      "annotation": "HasFile (Protocol)",
                      "description": "\nProtocol defining objects that have an associated HDF5 file."
                    },
                    {
                      "name": "KeysViewHDF5",
                      "annotation": null,
                      "description": "\nA specialized `KeysView` implementation for HDF5 mappings."
                    },
                    {
                      "name": "FileMap",
                      "annotation": null,
                      "description": "\nManages an in-memory cache of groups and datasets within an HDF5 file."
                    },
                    {
                      "name": "FilteredFileMap",
                      "annotation": null,
                      "description": "\nA filtered view of `FileMap`, allowing scoped access within a subpath."
                    },
                    {
                      "name": "ProcessQueue",
                      "annotation": null,
                      "description": "\nA queue to defer execution of file operations, especially useful in MPI contexts."
                    },
                    {
                      "name": "HDF5File",
                      "annotation": null,
                      "description": "\nA wrapper around `h5py.File` with additional functionality, including:\n- Context-managed opening/closing\n- Deferred process execution\n- Mutability enforcement\n- Custom file path handling"
                    }
                  ]
                },
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "decorators",
                    "description": "mutable_only:\n    Ensures that a method can only be executed if the file is mutable.\nwith_file_open:\n    Opens and closes the file automatically when executing a method.\nadd_to_file_queue:\n    Adds a method call to the process queue instead of executing immediately."
                  },
                  "title": "Decorators"
                }
              ],
              "attributes": [
                {
                  "name": "_T_HasFile",
                  "annotation": null,
                  "description": null,
                  "value": "TypeVar('_T_HasFile', bound=HasFile)"
                },
                {
                  "name": "log",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Logger instance for this module."
                    }
                  ],
                  "annotation": "Logger",
                  "value": "BAMBOOST_LOGGER.getChild('hdf5')"
                },
                {
                  "name": "HDF_MPI_ACTIVE",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "Indicates whether MPI support is available for HDF5."
                    }
                  ],
                  "value": "'mpio' in h5py.h5py.registered_drivers() and h5py.h5py.get_config().mpi and bamboost.mpi.MPI_ON"
                },
                {
                  "name": "_T_H5Object",
                  "annotation": null,
                  "description": null,
                  "value": "TypeVar('_T_H5Object', bound=H5Object)"
                }
              ],
              "modules": {},
              "classes": {
                "HasFile": {
                  "name": "HasFile",
                  "path": "bamboost.core.hdf5.file.HasFile",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class HasFile(Protocol[_MT]):\n    _file: HDF5File[_MT]",
                  "inherited_members": {}
                },
                "FileMode": {
                  "name": "FileMode",
                  "path": "bamboost.core.hdf5.file.FileMode",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "READ",
                      "annotation": null,
                      "description": null,
                      "value": "'r'"
                    },
                    {
                      "name": "READ_WRITE",
                      "annotation": null,
                      "description": null,
                      "value": "'r+'"
                    },
                    {
                      "name": "APPEND",
                      "annotation": null,
                      "description": null,
                      "value": "'a'"
                    },
                    {
                      "name": "WRITE",
                      "annotation": null,
                      "description": null,
                      "value": "'w'"
                    },
                    {
                      "name": "WRITE_FAIL",
                      "annotation": null,
                      "description": null,
                      "value": "'w-'"
                    },
                    {
                      "name": "WRITE_CREATE",
                      "annotation": null,
                      "description": null,
                      "value": "'x'"
                    },
                    {
                      "name": "__hirarchy__",
                      "annotation": null,
                      "description": null,
                      "value": "{'r': 0, 'r+': 1, 'a': 1, 'w': 1, 'w-': 1, 'x': 1}"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__lt__": {
                      "name": "__lt__",
                      "path": "bamboost.core.hdf5.file.FileMode.__lt__",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __lt__(self, other) -> bool:\n    return self.__hirarchy__[self.value] < self.__hirarchy__[other.value]"
                    },
                    "__eq__": {
                      "name": "__eq__",
                      "path": "bamboost.core.hdf5.file.FileMode.__eq__",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __eq__(self, other) -> bool:\n    return self.__hirarchy__[self.value] == self.__hirarchy__[other.value]"
                    }
                  },
                  "source": "@total_ordering\nclass FileMode(Enum):\n    READ = \"r\"\n    READ_WRITE = \"r+\"\n    APPEND = \"a\"\n    WRITE = \"w\"\n    WRITE_FAIL = \"w-\"\n    WRITE_CREATE = \"x\"\n\n    __hirarchy__ = {\"r\": 0, \"r+\": 1, \"a\": 1, \"w\": 1, \"w-\": 1, \"x\": 1}\n\n    def __lt__(self, other) -> bool:\n        return self.__hirarchy__[self.value] < self.__hirarchy__[other.value]\n\n    def __eq__(self, other) -> bool:\n        return self.__hirarchy__[self.value] == self.__hirarchy__[other.value]",
                  "inherited_members": {}
                },
                "H5Object": {
                  "name": "H5Object",
                  "path": "bamboost.core.hdf5.file.H5Object",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": "bamboost.core.hdf5.file.H5Object(file)"
                    },
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "Communicator()"
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.H5Object.__init__",
                      "signature": "(self, file) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File[_MT]) -> None:\n    self._file = file"
                    },
                    "open": {
                      "name": "open",
                      "path": "bamboost.core.hdf5.file.H5Object.open",
                      "signature": "(self, mode='r', driver=None) -> HDF5File[_MT]",
                      "description": "Use this as a context manager in a `with` statement.\nPurpose: keeping the file open to directly access/edit something in the\nHDF5 file of this simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "bamboost.core.hdf5.file.FileMode | str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "file mode (see h5py docs)"
                            }
                          ],
                          "value": "'r'"
                        },
                        {
                          "name": "driver",
                          "annotation": "typing.Optional[typing.Literal['mpio']]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "file driver (see h5py docs)"
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def open(\n    self,\n    mode: FileMode | str = \"r\",\n    driver: Optional[Literal[\"mpio\"]] = None,\n) -> HDF5File[_MT]:\n    \"\"\"Use this as a context manager in a `with` statement.\n    Purpose: keeping the file open to directly access/edit something in the\n    HDF5 file of this simulation.\n\n    Args:\n        mode: file mode (see h5py docs)\n        driver: file driver (see h5py docs)\n    \"\"\"\n    return self._file.open(mode, driver=driver)"
                    },
                    "post_write_instruction": {
                      "name": "post_write_instruction",
                      "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction",
                      "signature": "(self, instruction) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "instruction",
                          "annotation": "typing.Callable[[], None]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef post_write_instruction(self, instruction: Callable[[], None]) -> None:\n    if self._file.available_for_single_process_write():\n        # call instruction immediately\n        return self._file.single_process_queue.apply_instruction(instruction)\n\n    self._file.single_process_queue.add_instruction(instruction)"
                    },
                    "suspend_immediate_write": {
                      "name": "suspend_immediate_write",
                      "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write",
                      "signature": "(self) -> Generator[None, None, None]",
                      "description": "Context manager to suspend immediate write operations. Patches\nself._file.available_for_single_process_write to return False.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@contextmanager\ndef suspend_immediate_write(self) -> Generator[None, None, None]:\n    \"\"\"Context manager to suspend immediate write operations. Patches\n    self._file.available_for_single_process_write to return False.\"\"\"\n    original_method = self._file.available_for_single_process_write\n    self._file.available_for_single_process_write = lambda: False\n    try:\n        yield\n    finally:\n        self._file.available_for_single_process_write = original_method\n        self._file.single_process_queue.apply()"
                    }
                  },
                  "source": "class H5Object(Generic[_MT], ElligibleForPlugin):\n    _file: HDF5File[_MT]\n    _comm = Communicator()\n\n    def __init__(self, file: HDF5File[_MT]) -> None:\n        self._file = file\n\n    @overload\n    def mutable(self: H5Object[Mutable]) -> Literal[True]: ...\n    @overload\n    def mutable(self: H5Object[Immutable]) -> Literal[False]: ...\n    @property\n    def mutable(self) -> bool:\n        return self._file.mutable\n\n    def open(\n        self,\n        mode: FileMode | str = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File[_MT]:\n        \"\"\"Use this as a context manager in a `with` statement.\n        Purpose: keeping the file open to directly access/edit something in the\n        HDF5 file of this simulation.\n\n        Args:\n            mode: file mode (see h5py docs)\n            driver: file driver (see h5py docs)\n        \"\"\"\n        return self._file.open(mode, driver=driver)\n\n    @mutable_only\n    def post_write_instruction(self, instruction: Callable[[], None]) -> None:\n        if self._file.available_for_single_process_write():\n            # call instruction immediately\n            return self._file.single_process_queue.apply_instruction(instruction)\n\n        self._file.single_process_queue.add_instruction(instruction)\n\n    @contextmanager\n    def suspend_immediate_write(self) -> Generator[None, None, None]:\n        \"\"\"Context manager to suspend immediate write operations. Patches\n        self._file.available_for_single_process_write to return False.\"\"\"\n        original_method = self._file.available_for_single_process_write\n        self._file.available_for_single_process_write = lambda: False\n        try:\n            yield\n        finally:\n            self._file.available_for_single_process_write = original_method\n            self._file.single_process_queue.apply()",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ]
                  }
                },
                "SingleProcessQueue": {
                  "name": "SingleProcessQueue",
                  "path": "bamboost.core.hdf5.file.SingleProcessQueue",
                  "description": "A queue to defer execution of write operations that need to be executed on the root\nonly. Only relevant for parallelized code.\n\nThis class is a deque of instructions that are to be executed in order when the file is\navailable for writing (i.e., not open with MPI I/O OR closed). We append instructions\nto the right and pop them from the left.\n\nThis class uses the RootProcessMeta metaclass to ensure that all methods are only\nexecuted on the root process.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "Communicator()"
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.hdf5.file.SingleProcessQueue(file)"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.SingleProcessQueue.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    super().__init__()"
                    },
                    "add_instruction": {
                      "name": "add_instruction",
                      "path": "bamboost.core.hdf5.file.SingleProcessQueue.add_instruction",
                      "signature": "(self, instruction) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "instruction",
                          "annotation": "typing.Callable[[], None]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_instruction(self, instruction: Callable[[], None]) -> None:\n    self.append(instruction)\n    log.debug(f\"Added {type(instruction).__name__} to process queue\")"
                    },
                    "apply_instruction": {
                      "name": "apply_instruction",
                      "path": "bamboost.core.hdf5.file.SingleProcessQueue.apply_instruction",
                      "signature": "(self, instruction) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "instruction",
                          "annotation": "typing.Callable[[], None]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.APPEND)\ndef apply_instruction(self, instruction: Callable[[], None]) -> None:\n    log.debug(f\"Applying {type(instruction).__name__}\")\n    instruction()"
                    },
                    "apply": {
                      "name": "apply",
                      "path": "bamboost.core.hdf5.file.SingleProcessQueue.apply",
                      "signature": "(self) -> None",
                      "description": "Applies all write instructions in the queue.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def apply(self) -> None:\n    \"\"\"Applies all write instructions in the queue.\"\"\"\n    if not self:\n        log.debug(\"SingleProcessQueue is empty\")\n        return\n\n    log.debug(\"Applying process queue\")\n    with self._file.open(FileMode.APPEND):\n        while self:\n            instruction = self.popleft()\n            log.debug(f\"Applying {type(instruction).__name__}\")\n            instruction()"
                    }
                  },
                  "source": "class SingleProcessQueue(deque[Callable[[], None]], metaclass=RootProcessMeta):\n    \"\"\"A queue to defer execution of write operations that need to be executed on the root\n    only. Only relevant for parallelized code.\n\n    This class is a deque of instructions that are to be executed in order when the file is\n    available for writing (i.e., not open with MPI I/O OR closed). We append instructions\n    to the right and pop them from the left.\n\n    This class uses the RootProcessMeta metaclass to ensure that all methods are only\n    executed on the root process.\n    \"\"\"\n\n    _comm = Communicator()\n\n    def __init__(self, file: HDF5File):\n        self._file = file\n        super().__init__()\n\n    def add_instruction(self, instruction: Callable[[], None]) -> None:\n        self.append(instruction)\n        log.debug(f\"Added {type(instruction).__name__} to process queue\")\n\n    @with_file_open(FileMode.APPEND)\n    def apply_instruction(self, instruction: Callable[[], None]) -> None:\n        log.debug(f\"Applying {type(instruction).__name__}\")\n        instruction()\n\n    def apply(self) -> None:\n        \"\"\"Applies all write instructions in the queue.\"\"\"\n        if not self:\n            log.debug(\"SingleProcessQueue is empty\")\n            return\n\n        log.debug(\"Applying process queue\")\n        with self._file.open(FileMode.APPEND):\n            while self:\n                instruction = self.popleft()\n                log.debug(f\"Applying {type(instruction).__name__}\")\n                instruction()",
                  "inherited_members": {}
                },
                "WriteInstruction": {
                  "name": "WriteInstruction",
                  "path": "bamboost.core.hdf5.file.WriteInstruction",
                  "description": "Abstract base class for write instructions. Not useful currently, but could be\nextended in the future (e.g. provide logging).",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.WriteInstruction.__init__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self): ..."
                    },
                    "__call__": {
                      "name": "__call__",
                      "path": "bamboost.core.hdf5.file.WriteInstruction.__call__",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __call__(self) -> None: ..."
                    }
                  },
                  "source": "class WriteInstruction(ABC):\n    \"\"\"Abstract base class for write instructions. Not useful currently, but could be\n    extended in the future (e.g. provide logging).\"\"\"\n\n    def __init__(self): ...\n    def __call__(self) -> None: ...",
                  "inherited_members": {}
                },
                "HDF5File": {
                  "name": "HDF5File",
                  "path": "bamboost.core.hdf5.file.HDF5File",
                  "description": "Lazy `h5py.File` wrapper with deferred process execution and file map caching.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.utilities.StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The path to the HDF5 file."
                        }
                      ]
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The MPI communicator. Defaults to MPI.COMM_WORLD."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Whether the file is mutable. Defaults to False."
                        }
                      ],
                      "value": "False"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_filename",
                      "annotation": "str",
                      "description": null,
                      "value": "bamboost.core.hdf5.file.HDF5File(file).bamboost.core.hdf5.file.HDF5File(file).as_posix() if isinstance(bamboost.core.hdf5.file.HDF5File(file), pathlib.Path) else bamboost.core.hdf5.file.HDF5File(file)"
                    },
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "Communicator()"
                    },
                    {
                      "name": "_context_stack",
                      "annotation": "int",
                      "description": null,
                      "value": "0"
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": "bamboost.core.hdf5.file.HDF5File(mutable)"
                    },
                    {
                      "name": "file_map",
                      "annotation": "bamboost.core.hdf5.filemap.FileMap",
                      "description": null,
                      "value": "FileMap(self)"
                    },
                    {
                      "name": "_is_open_on_root_only",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "_attrs_dict_instances",
                      "annotation": "dict[str, 'AttrsDict[_MT]']",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "_path",
                      "annotation": null,
                      "description": null,
                      "value": "Path(self._filename).absolute()"
                    },
                    {
                      "name": "is_open",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "single_process_queue",
                      "annotation": "bamboost.core.hdf5.file.SingleProcessQueue",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The single process queue of this file object. See `SingleProcessQueue` for\ndetails."
                        }
                      ],
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing._MT]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Returns the root group of the file. Same as `Group(\"/\", file)`"
                        }
                      ],
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.HDF5File.__init__",
                      "signature": "(self, file, comm=None, mutable=False)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.utilities.StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "typing.Optional[bamboost.mpi.Comm]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "mutable",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    file: StrPath,\n    comm: Optional[Comm] = None,\n    mutable: bool = False,\n):\n    self._filename = file.as_posix() if isinstance(file, Path) else file\n    self._path = Path(self._filename).absolute()\n    self.file_map = FileMap(self)\n    self.mutable = mutable\n\n    # if the file is immutable, we immediately check if it exists.\n    # if it doesn't, we raise an exception\n    if not mutable and not self._path.exists():\n        raise FileNotFoundError(f\"File {self._filename} does not exist.\")"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.file.HDF5File.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    mode_info = self.mode if self.is_open else \"proxy\"\n    status = \"open\" if self.is_open else \"closed\"\n    mutability = Mutable if self.mutable else Immutable\n    return (\n        f'<{mutability} HDF5 file \"{self._filename}\" (mode {mode_info}, {status})>'\n    )"
                    },
                    "_create_file": {
                      "name": "_create_file",
                      "path": "bamboost.core.hdf5.file.HDF5File._create_file",
                      "signature": "(self) -> HDF5File[Mutable]",
                      "description": "Opens and closes the file to create it while doing nothing to it.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _create_file(self: HDF5File[Mutable]) -> HDF5File[Mutable]:\n    \"\"\"Opens and closes the file to create it while doing nothing to it.\"\"\"\n    with self.open(\"a\"):\n        pass\n    return self"
                    },
                    "open": {
                      "name": "open",
                      "path": "bamboost.core.hdf5.file.HDF5File.open",
                      "signature": "(self, mode='r', driver=None) -> HDF5File",
                      "description": "Context manager to opens the HDF5 file with the specified mode and\ndriver.\n\nThis method attempts to open the file, and if it's locked, it will\nretry until the file becomes available.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "typing.Union[bamboost.core.hdf5.file.FileMode, str]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The mode to open the file with. Defaults to \"r\" (read-only)."
                            }
                          ],
                          "value": "'r'"
                        },
                        {
                          "name": "driver",
                          "annotation": null,
                          "description": [
                            {
                              "kind": "text",
                              "value": "The driver to use for file I/O. If \"mpio\" and MPI is\nactive, it will use MPI I/O. Defaults to None."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "HDF5File",
                        "annotation": "bamboost.core.hdf5.file.HDF5File",
                        "description": "The opened HDF5 file object."
                      },
                      "docstring": [
                        {
                          "kind": "raises",
                          "value": [
                            {
                              "annotation": "BlockingIOError",
                              "description": "If the file is locked (handled internally with retries)."
                            },
                            {
                              "annotation": "FileNotFoundError",
                              "description": "If the file does not exist and you're trying to open it read-only."
                            }
                          ]
                        }
                      ],
                      "source": "def open(\n    self,\n    mode: Union[FileMode, str] = \"r\",\n    driver=None,\n) -> HDF5File:\n    \"\"\"Context manager to opens the HDF5 file with the specified mode and\n    driver.\n\n    This method attempts to open the file, and if it's locked, it will\n    retry until the file becomes available.\n\n    Args:\n        mode: The mode to open the file with. Defaults to \"r\" (read-only).\n        driver: The driver to use for file I/O. If \"mpio\" and MPI is\n            active, it will use MPI I/O. Defaults to None.\n\n    Returns:\n        HDF5File: The opened HDF5 file object.\n\n    Raises:\n        BlockingIOError: If the file is locked (handled internally with retries).\n        FileNotFoundError: If the file does not exist and you're trying to open it read-only.\n    \"\"\"\n    mode = FileMode(mode)\n\n    if (mode > FileMode.READ) and (not self.mutable):\n        log.error(f\"File is read-only, cannot open with mode {mode.value}\")\n        raise PermissionError(\n            \"Attempted to open read-only file with illegal file mode.\"\n        )\n\n    self._context_stack += 1\n    log.debug(f\"[{id(self)}] context stack + ({self._context_stack})\")\n\n    if self.is_open:\n        if mode > FileMode(self.mode):\n            # if the new operation requires a higher mode, we close the file\n            # to reopen it with the new mode\n            super().close()\n        else:\n            # if the file is already open with the same or higher mode, we\n            # just increase the context stack and return\n            return self\n\n    return self._try_open_repeat(mode, driver)"
                    },
                    "_try_open_repeat": {
                      "name": "_try_open_repeat",
                      "path": "bamboost.core.hdf5.file.HDF5File._try_open_repeat",
                      "signature": "(self, mode, driver=None) -> Self",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "bamboost.core.hdf5.file.FileMode",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "driver",
                          "annotation": "typing.Optional[typing.Literal['mpio']]",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _try_open_repeat(\n    self, mode: FileMode, driver: Optional[Literal[\"mpio\"]] = None\n) -> Self:\n    waiting_logged = False\n\n    # try to open the file until it is available\n    while True:\n        try:\n            if HDF_MPI_ACTIVE and mode > FileMode.READ and driver == \"mpio\":\n                h5py.File.__init__(\n                    self, self._filename, mode.value, driver=driver, comm=self._comm\n                )\n            else:\n                h5py.File.__init__(self, self._filename, mode.value)\n            log.debug(\n                f\"[{id(self)}] opened file (mode {mode.value}) {self._filename}\"\n            )\n\n            # create file map\n            if not self.file_map.valid:\n                self.file_map.populate()\n\n            return self\n        except BlockingIOError:\n            # If the file is locked, we wait and try again\n            if not waiting_logged:\n                level = logging._nameToLevel[config.options.log_file_lock_severity]\n                log.log(\n                    level, f\"[{id(self)}] file locked (waiting) {self._filename}\"\n                )\n            waiting_logged = True\n            time.sleep(0.01)"
                    },
                    "close": {
                      "name": "close",
                      "path": "bamboost.core.hdf5.file.HDF5File.close",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def close(self):\n    self._context_stack = max(0, self._context_stack - 1)\n\n    # if the context stack is 0, we close the file\n    if self._context_stack <= 0:\n        log.debug(f\"[{id(self)}] closed file {self._filename}\")\n        super().close()\n\n        # if the file is mutable, we further apply the single process queue\n        if self.mutable:\n            self.single_process_queue.apply()\n\n    log.debug(f\"[{id(self)}] context stack - ({self._context_stack})\")"
                    },
                    "force_close": {
                      "name": "force_close",
                      "path": "bamboost.core.hdf5.file.HDF5File.force_close",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def force_close(self):\n    super().close()\n    self._context_stack = 0"
                    },
                    "delete_object": {
                      "name": "delete_object",
                      "path": "bamboost.core.hdf5.file.HDF5File.delete_object",
                      "signature": "(self, path) -> None",
                      "description": "Deletes an object in the file. In addition to deleting the object, revoking\nthis method also removes the object from the file map.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "typing.Union[bamboost.core.hdf5.hdf5path.HDF5Path, str]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The path to the object to delete."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def delete_object(self, path: Union[HDF5Path, str]) -> None:\n    \"\"\"Deletes an object in the file. In addition to deleting the object, revoking\n    this method also removes the object from the file map.\n\n    Args:\n        path: The path to the object to delete.\n    \"\"\"\n    # call h5py's delete method\n    super().__delitem__(str(path))\n    # remove from file map\n    del self.file_map[str(path)]"
                    },
                    "available_for_single_process_write": {
                      "name": "available_for_single_process_write",
                      "path": "bamboost.core.hdf5.file.HDF5File.available_for_single_process_write",
                      "signature": "(self) -> bool",
                      "description": "Whether single process write instructions can be executed immediately.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def available_for_single_process_write(self) -> bool:\n    \"\"\"Whether single process write instructions can be executed immediately.\"\"\"\n    return (not self.is_open) or (self.driver != \"mpio\")"
                    }
                  },
                  "source": "class HDF5File(h5py.File, Generic[_MT]):\n    \"\"\"Lazy `h5py.File` wrapper with deferred process execution and file map caching.\n\n    Args:\n        file: The path to the HDF5 file.\n        comm: The MPI communicator. Defaults to MPI.COMM_WORLD.\n        mutable: Whether the file is mutable. Defaults to False.\n    \"\"\"\n\n    _filename: str\n    _comm = Communicator()\n    _context_stack: int = 0\n    mutable: bool\n    file_map: FileMap\n    _is_open_on_root_only: bool = False\n    _attrs_dict_instances: dict[str, \"AttrsDict[_MT]\"] = {}\n\n    @overload\n    def __init__(\n        self: HDF5File[Immutable],\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: Literal[False] = False,\n    ): ...\n    @overload\n    def __init__(\n        self: HDF5File[Mutable],\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: Literal[True] = True,\n    ): ...\n    def __init__(\n        self,\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: bool = False,\n    ):\n        self._filename = file.as_posix() if isinstance(file, Path) else file\n        self._path = Path(self._filename).absolute()\n        self.file_map = FileMap(self)\n        self.mutable = mutable\n\n        # if the file is immutable, we immediately check if it exists.\n        # if it doesn't, we raise an exception\n        if not mutable and not self._path.exists():\n            raise FileNotFoundError(f\"File {self._filename} does not exist.\")\n\n    def __repr__(self) -> str:\n        mode_info = self.mode if self.is_open else \"proxy\"\n        status = \"open\" if self.is_open else \"closed\"\n        mutability = Mutable if self.mutable else Immutable\n        return (\n            f'<{mutability} HDF5 file \"{self._filename}\" (mode {mode_info}, {status})>'\n        )\n\n    def _create_file(self: HDF5File[Mutable]) -> HDF5File[Mutable]:\n        \"\"\"Opens and closes the file to create it while doing nothing to it.\"\"\"\n        with self.open(\"a\"):\n            pass\n        return self\n\n    @overload\n    def open(\n        self: HDF5File[Immutable],\n        mode: Literal[FileMode.READ, \"r\"] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File[Immutable]: ...\n    @overload\n    def open(\n        self: HDF5File[Mutable],\n        mode: Union[FileMode, Literal[\"r\", \"r+\", \"w\", \"w-\", \"x\", \"a\"]] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File[Mutable]: ...\n    @overload\n    def open(\n        self: HDF5File,\n        mode: Union[FileMode, str] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File: ...\n    def open(\n        self,\n        mode: Union[FileMode, str] = \"r\",\n        driver=None,\n    ) -> HDF5File:\n        \"\"\"Context manager to opens the HDF5 file with the specified mode and\n        driver.\n\n        This method attempts to open the file, and if it's locked, it will\n        retry until the file becomes available.\n\n        Args:\n            mode: The mode to open the file with. Defaults to \"r\" (read-only).\n            driver: The driver to use for file I/O. If \"mpio\" and MPI is\n                active, it will use MPI I/O. Defaults to None.\n\n        Returns:\n            HDF5File: The opened HDF5 file object.\n\n        Raises:\n            BlockingIOError: If the file is locked (handled internally with retries).\n            FileNotFoundError: If the file does not exist and you're trying to open it read-only.\n        \"\"\"\n        mode = FileMode(mode)\n\n        if (mode > FileMode.READ) and (not self.mutable):\n            log.error(f\"File is read-only, cannot open with mode {mode.value}\")\n            raise PermissionError(\n                \"Attempted to open read-only file with illegal file mode.\"\n            )\n\n        self._context_stack += 1\n        log.debug(f\"[{id(self)}] context stack + ({self._context_stack})\")\n\n        if self.is_open:\n            if mode > FileMode(self.mode):\n                # if the new operation requires a higher mode, we close the file\n                # to reopen it with the new mode\n                super().close()\n            else:\n                # if the file is already open with the same or higher mode, we\n                # just increase the context stack and return\n                return self\n\n        return self._try_open_repeat(mode, driver)\n\n    def _try_open_repeat(\n        self, mode: FileMode, driver: Optional[Literal[\"mpio\"]] = None\n    ) -> Self:\n        waiting_logged = False\n\n        # try to open the file until it is available\n        while True:\n            try:\n                if HDF_MPI_ACTIVE and mode > FileMode.READ and driver == \"mpio\":\n                    h5py.File.__init__(\n                        self, self._filename, mode.value, driver=driver, comm=self._comm\n                    )\n                else:\n                    h5py.File.__init__(self, self._filename, mode.value)\n                log.debug(\n                    f\"[{id(self)}] opened file (mode {mode.value}) {self._filename}\"\n                )\n\n                # create file map\n                if not self.file_map.valid:\n                    self.file_map.populate()\n\n                return self\n            except BlockingIOError:\n                # If the file is locked, we wait and try again\n                if not waiting_logged:\n                    level = logging._nameToLevel[config.options.log_file_lock_severity]\n                    log.log(\n                        level, f\"[{id(self)}] file locked (waiting) {self._filename}\"\n                    )\n                waiting_logged = True\n                time.sleep(0.01)\n\n    def close(self):\n        self._context_stack = max(0, self._context_stack - 1)\n\n        # if the context stack is 0, we close the file\n        if self._context_stack <= 0:\n            log.debug(f\"[{id(self)}] closed file {self._filename}\")\n            super().close()\n\n            # if the file is mutable, we further apply the single process queue\n            if self.mutable:\n                self.single_process_queue.apply()\n\n        log.debug(f\"[{id(self)}] context stack - ({self._context_stack})\")\n\n    def force_close(self):\n        super().close()\n        self._context_stack = 0\n\n    def delete_object(self, path: Union[HDF5Path, str]) -> None:\n        \"\"\"Deletes an object in the file. In addition to deleting the object, revoking\n        this method also removes the object from the file map.\n\n        Args:\n            path: The path to the object to delete.\n        \"\"\"\n        # call h5py's delete method\n        super().__delitem__(str(path))\n        # remove from file map\n        del self.file_map[str(path)]\n\n    @property\n    def is_open(self) -> bool:\n        return bool(hasattr(self, \"id\") and self.id.valid)\n\n    @property\n    def single_process_queue(self) -> SingleProcessQueue:\n        \"\"\"The single process queue of this file object. See `SingleProcessQueue` for\n        details.\n        \"\"\"\n        try:\n            return self._single_process_queue\n        except AttributeError:\n            self._single_process_queue = SingleProcessQueue(self)\n            return self._single_process_queue\n\n    def available_for_single_process_write(self) -> bool:\n        \"\"\"Whether single process write instructions can be executed immediately.\"\"\"\n        return (not self.is_open) or (self.driver != \"mpio\")\n\n    @property\n    def root(self) -> Group[_MT]:\n        \"\"\"Returns the root group of the file. Same as `Group(\"/\", file)`\"\"\"\n        from .ref import Group\n\n        return Group(\"/\", self)",
                  "inherited_members": {}
                }
              },
              "functions": {
                "mutable_only": {
                  "name": "mutable_only",
                  "path": "bamboost.core.hdf5.file.mutable_only",
                  "signature": "(method) -> Callable[Concatenate[_T_HasFile, _P], _T]",
                  "description": "Decorator to raise an error if the file is not mutable.",
                  "parameters": [
                    {
                      "name": "method",
                      "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file._T_HasFile, bamboost._typing._P], bamboost._typing._T]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def mutable_only(\n    method: Callable[Concatenate[_T_HasFile, _P], _T],\n) -> Callable[Concatenate[_T_HasFile, _P], _T]:\n    \"\"\"Decorator to raise an error if the file is not mutable.\"\"\"\n\n    @wraps(method)\n    def inner(self: _T_HasFile, *args: _P.args, **kwargs: _P.kwargs) -> _T:\n        if not self._file.mutable:\n            raise PermissionError(\"Simulation file is read-only.\")\n        return method(self, *args, **kwargs)\n\n    inner._mutable_only = True  # type: ignore\n    return inner"
                },
                "with_file_open": {
                  "name": "with_file_open",
                  "path": "bamboost.core.hdf5.file.with_file_open",
                  "signature": "(mode=FileMode.READ, driver=None) -> Callable[[Callable[Concatenate[_T_HasFile, _P], _T]], Callable[Concatenate[_T_HasFile, _P], _T]]",
                  "description": "Decorator for context manager to open and close the file for a method of a class\nwith a file attribute (self._file).",
                  "parameters": [
                    {
                      "name": "mode",
                      "annotation": "bamboost.core.hdf5.file.FileMode",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The mode to open the file with. Defaults to FileMode.READ."
                        }
                      ],
                      "value": "bamboost.core.hdf5.file.FileMode.bamboost.core.hdf5.file.FileMode.READ"
                    },
                    {
                      "name": "driver",
                      "annotation": "typing.Optional[typing.Literal['mpio']]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The driver to use for file I/O. If \"mpio\" and MPI is active, it will\nuse MPI I/O. Defaults to None."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def with_file_open(\n    mode: FileMode = FileMode.READ,\n    driver: Optional[Literal[\"mpio\"]] = None,\n) -> Callable[\n    [Callable[Concatenate[_T_HasFile, _P], _T]],\n    Callable[Concatenate[_T_HasFile, _P], _T],\n]:\n    \"\"\"Decorator for context manager to open and close the file for a method of a class\n    with a file attribute (self._file).\n\n    Args:\n        mode: The mode to open the file with. Defaults to FileMode.READ.\n        driver: The driver to use for file I/O. If \"mpio\" and MPI is active, it will\n            use MPI I/O. Defaults to None.\n    \"\"\"\n\n    def decorator(\n        method: Callable[Concatenate[_T_HasFile, _P], _T],\n    ) -> Callable[Concatenate[_T_HasFile, _P], _T]:\n        @wraps(method)\n        def inner(self: _T_HasFile, *args: _P.args, **kwargs: _P.kwargs) -> _T:\n            with self._file.open(mode, driver):\n                return method(self, *args, **kwargs)\n\n        return inner\n\n    return decorator"
                },
                "add_to_file_queue": {
                  "name": "add_to_file_queue",
                  "path": "bamboost.core.hdf5.file.add_to_file_queue",
                  "signature": "(method) -> Callable[Concatenate[_T_H5Object, _P], None]",
                  "description": "Decorator to add a method call to the single process queue of the file object\ninstead of executing it immediately.",
                  "parameters": [
                    {
                      "name": "method",
                      "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file._T_H5Object, bamboost._typing._P], None]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def add_to_file_queue(\n    method: Callable[Concatenate[_T_H5Object, _P], None],\n) -> Callable[Concatenate[_T_H5Object, _P], None]:\n    \"\"\"Decorator to add a method call to the single process queue of the file object\n    instead of executing it immediately.\n    \"\"\"\n\n    @wraps(method)\n    def inner(self: _T_H5Object, *args: _P.args, **kwargs: _P.kwargs) -> None:\n        self.post_write_instruction(lambda: method(self, *args, **kwargs))\n\n    return inner"
                }
              }
            }
          },
          "classes": {},
          "functions": {}
        },
        "simulation": {
          "name": "simulation",
          "path": "bamboost.core.simulation",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/__init__.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {
            "base": {
              "name": "base",
              "path": "bamboost.core.simulation.base",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/base.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild('simulation')"
                }
              ],
              "modules": {},
              "classes": {
                "Status": {
                  "name": "Status",
                  "path": "bamboost.core.simulation.base.Status",
                  "description": "Status of a simulation.",
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "INITIALIZED",
                      "annotation": null,
                      "description": null,
                      "value": "'initialized'"
                    },
                    {
                      "name": "STARTED",
                      "annotation": null,
                      "description": null,
                      "value": "'started'"
                    },
                    {
                      "name": "FINISHED",
                      "annotation": null,
                      "description": null,
                      "value": "'finished'"
                    },
                    {
                      "name": "FAILED",
                      "annotation": null,
                      "description": null,
                      "value": "'failed'"
                    },
                    {
                      "name": "UNKNOWN",
                      "annotation": null,
                      "description": null,
                      "value": "'unknown'"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "format": {
                      "name": "format",
                      "path": "bamboost.core.simulation.base.Status.format",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def format(self) -> str:\n    return self.value"
                    }
                  },
                  "source": "class Status(Enum):\n    \"\"\"Status of a simulation.\"\"\"\n\n    INITIALIZED = \"initialized\"\n    STARTED = \"started\"\n    FINISHED = \"finished\"\n    FAILED = \"failed\"\n    UNKNOWN = \"unknown\"\n\n    def format(self) -> str:\n        return self.value",
                  "inherited_members": {}
                },
                "StatusInfo": {
                  "name": "StatusInfo",
                  "path": "bamboost.core.simulation.base.StatusInfo",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": "bamboost.core.simulation.base.Status",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "message",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "status",
                      "annotation": "bamboost.core.simulation.base.Status",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "message",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "parse": {
                      "name": "parse",
                      "path": "bamboost.core.simulation.base.StatusInfo.parse",
                      "signature": "(cls, status) -> StatusInfo",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "status",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef parse(cls, status: str) -> StatusInfo:\n    import re\n\n    pattern = r\"^(?P<status>\\w+)(?:\\s*\\[(?P<message>.+)\\])?$\"\n    match = re.match(pattern, status.strip())\n\n    if match:\n        status_str = match.group(\"status\").lower()\n        message = match.group(\"message\")\n        try:\n            return cls(Status(status_str), message)\n        except ValueError:\n            return cls(Status.UNKNOWN, status)\n    else:\n        return cls(Status.UNKNOWN, status)"
                    },
                    "format": {
                      "name": "format",
                      "path": "bamboost.core.simulation.base.StatusInfo.format",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def format(self) -> str:\n    return (\n        f\"{self.status.value} [{self.message}]\"\n        if self.message\n        else self.status.value\n    )"
                    },
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.base.StatusInfo.__init__",
                      "signature": "(self, status, message=None) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "status",
                          "annotation": "bamboost.core.simulation.base.Status",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "message",
                          "annotation": "typing.Optional[str]",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": ""
                    }
                  },
                  "source": "@dataclass\nclass StatusInfo:\n    status: Status\n    message: Optional[str] = None\n\n    @classmethod\n    def parse(cls, status: str) -> StatusInfo:\n        import re\n\n        pattern = r\"^(?P<status>\\w+)(?:\\s*\\[(?P<message>.+)\\])?$\"\n        match = re.match(pattern, status.strip())\n\n        if match:\n            status_str = match.group(\"status\").lower()\n            message = match.group(\"message\")\n            try:\n                return cls(Status(status_str), message)\n            except ValueError:\n                return cls(Status.UNKNOWN, status)\n        else:\n            return cls(Status.UNKNOWN, status)\n\n    def format(self) -> str:\n        return (\n            f\"{self.status.value} [{self.message}]\"\n            if self.message\n            else self.status.value\n        )",
                  "inherited_members": {}
                },
                "SimulationName": {
                  "name": "SimulationName",
                  "path": "bamboost.core.simulation.base.SimulationName",
                  "description": "Name of a simulation.",
                  "parameters": [],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.simulation.base.SimulationName.__new__",
                      "signature": "(cls, name=None, length=10)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "typing.Optional[str]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "length",
                          "annotation": "int",
                          "description": null,
                          "value": "10"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, name: Optional[str] = None, length: int = 10):\n    name = name or cls.generate_name(length)\n    return super().__new__(cls, name)"
                    },
                    "generate_name": {
                      "name": "generate_name",
                      "path": "bamboost.core.simulation.base.SimulationName.generate_name",
                      "signature": "(length) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "length",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@staticmethod\ndef generate_name(length: int) -> str:\n    return uuid.uuid4().hex[:length]"
                    }
                  },
                  "source": "class SimulationName(str):\n    \"\"\"Name of a simulation.\"\"\"\n\n    def __new__(cls, name: Optional[str] = None, length: int = 10):\n        name = name or cls.generate_name(length)\n        return super().__new__(cls, name)\n\n    @staticmethod\n    def generate_name(length: int) -> str:\n        return uuid.uuid4().hex[:length]",
                  "inherited_members": {}
                },
                "_Simulation": {
                  "name": "_Simulation",
                  "path": "bamboost.core.simulation.base._Simulation",
                  "description": "Abstract simulation base class. Use `Simulation` or `SimulationWriter` instead.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name for the simulation."
                        }
                      ]
                    },
                    {
                      "name": "parent",
                      "annotation": "bamboost.utilities.StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path to parent/collection directory."
                        }
                      ]
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "MPI communicator. Defaults to MPI.COMM_WORLD."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "typing.Optional[bamboost.index.Index]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Index object. Defaults to the global index file."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": "bamboost.core.simulation.base._Simulation(name)"
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": "Path(parent).joinpath(name).absolute()"
                    },
                    {
                      "name": "_psize",
                      "annotation": "int",
                      "description": null,
                      "value": "bamboost.core.simulation.base._Simulation(self).bamboost.core.simulation.base._Simulation(self)._comm.bamboost.core.simulation.base._Simulation(self)._comm.size"
                    },
                    {
                      "name": "_prank",
                      "annotation": "int",
                      "description": null,
                      "value": "bamboost.core.simulation.base._Simulation(self).bamboost.core.simulation.base._Simulation(self)._comm.bamboost.core.simulation.base._Simulation(self)._comm.rank"
                    },
                    {
                      "name": "_ranks",
                      "annotation": null,
                      "description": null,
                      "value": "np.array([i for i in range(self._psize)])"
                    },
                    {
                      "name": "_index",
                      "annotation": "bamboost.index.Index",
                      "description": null,
                      "value": "bamboost.core.simulation.base._Simulation(index) or bamboost.index.Index(comm=bamboost.core.simulation.base._Simulation(self).bamboost.core.simulation.base._Simulation(self)._comm)"
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "bamboost.index.CollectionUID",
                      "description": null,
                      "value": "bamboost.core.simulation.base._Simulation(kwargs).bamboost.core.simulation.base._Simulation(kwargs).pop('collection_uid', None) or bamboost.core.simulation.base._Simulation(self).bamboost.core.simulation.base._Simulation(self)._index.bamboost.core.simulation.base._Simulation(self)._index.resolve_uid(bamboost.core.simulation.base._Simulation(self).bamboost.core.simulation.base._Simulation(self).path.bamboost.core.simulation.base._Simulation(self).path.parent)"
                    },
                    {
                      "name": "_data_file",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.HDF_DATA_FILE_NAME)"
                    },
                    {
                      "name": "_xdmf_file",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.XDMF_FILE_NAME)"
                    },
                    {
                      "name": "_bash_file",
                      "annotation": "pathlib.Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.RUN_FILE_NAME)"
                    },
                    {
                      "name": "root",
                      "annotation": "bamboost.core.hdf5.ref.Group[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_orm",
                      "annotation": "bamboost.index.sqlmodel.SimulationORM",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The full uid of the simulation (collection_uid:simulation_name)."
                        }
                      ],
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "bamboost.core.simulation.dict.Parameters[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "metadata",
                      "annotation": "bamboost.core.simulation.dict.Metadata[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": "bamboost.core.simulation.base.StatusInfo",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "created_at",
                      "annotation": "datetime.datetime",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "description",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "links",
                      "annotation": "bamboost.core.simulation.dict.Links[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "files",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "git",
                      "annotation": "bamboost.core.simulation.groups.GroupGit[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Return the default data series."
                        }
                      ],
                      "value": null
                    },
                    {
                      "name": "meshes",
                      "annotation": "bamboost.core.simulation.groups.GroupMeshes[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mesh",
                      "annotation": "bamboost.core.simulation.groups.GroupMesh",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [
                    {
                      "kind": "raises",
                      "value": [
                        {
                          "annotation": "FileNotFoundError",
                          "description": "If the simulation doesn't exist."
                        }
                      ]
                    }
                  ],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.base._Simulation.__init__",
                      "signature": "(self, name, parent, comm=None, index=None, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "bamboost.utilities.StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "typing.Optional[bamboost.mpi.Comm]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "index",
                          "annotation": "typing.Optional[bamboost.index.Index]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    name: str,\n    parent: StrPath,\n    comm: Optional[Comm] = None,\n    index: Optional[Index] = None,\n    **kwargs,\n):\n    self.name: str = name\n    self.path: Path = Path(parent).joinpath(name).absolute()\n    if not self.path.is_dir():\n        raise FileNotFoundError(\n            f\"Simulation {self.name} does not exist in {self.path}.\"\n        )\n\n    # MPI information\n    self._psize: int = self._comm.size\n    self._prank: int = self._comm.rank\n    self._ranks = np.array([i for i in range(self._psize)])\n\n    # Reference to the database\n    # 06.03.2025: Maybe use the default index instance instead of a new one...\n    self._index: Index = index or Index(comm=self._comm)\n\n    # Shortcut to collection uid if available, otherwise resolve it\n    self.collection_uid: CollectionUID = kwargs.pop(\n        \"collection_uid\", None\n    ) or self._index.resolve_uid(self.path.parent)\n\n    self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n    self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n    self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)"
                    },
                    "__eq__": {
                      "name": "__eq__",
                      "path": "bamboost.core.simulation.base._Simulation.__eq__",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "bamboost.core.simulation.base._Simulation",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __eq__(self, other: _Simulation, /) -> bool:\n    return (\n        self.uid == other.uid\n        and self.name == other.name\n        and self.path == other.path\n        and self.mutable == other.mutable\n    )"
                    },
                    "_repr_html_": {
                      "name": "_repr_html_",
                      "path": "bamboost.core.simulation.base._Simulation._repr_html_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _repr_html_(self):\n    import pkgutil\n\n    from jinja2 import Template\n\n    metadata = self.metadata\n    parameters_filtered = {\n        k: \"...\"\n        if isinstance(v, Sized) and not isinstance(v, str) and len(v) > 5\n        else v\n        for k, v in self.parameters.items()\n    }\n\n    def get_pill_div(text: str, color: str) -> str:\n        return (\n            f'<div class=\"status\" style=\"background-color:'\n            f'var(--bb-{color});\">{text}</div>'\n        )\n\n    def get_status_pill(status: StatusInfo) -> str:\n        if status.status == Status.FAILED:\n            return get_pill_div(status.format(), \"red\")\n        elif status.status == Status.FINISHED:\n            return get_pill_div(status.format(), \"green\")\n        elif status.status in (Status.INITIALIZED, Status.UNKNOWN):\n            return get_pill_div(status.format(), \"grey\")\n        elif status.status == Status.STARTED:\n            return get_pill_div(status.format(), \"orange\")\n        else:\n            return get_pill_div(status.format(), \"grey\")\n\n    def get_submitted_pill(submitted: bool) -> str:\n        return (\n            get_pill_div(\"Submitted\", \"green\")\n            if submitted\n            else get_pill_div(\"Not submitted\", \"grey\")\n        )\n\n    html_string = pkgutil.get_data(\"bamboost\", \"_repr/simulation.html\").decode()\n    icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n    template = Template(html_string)\n    file_tree = str(self.files).replace(\"\\n\", \"</br>\").replace(\" \", \"&nbsp;\")\n\n    return template.render(\n        uid=self.name,\n        icon=icon,\n        tree=file_tree,\n        parameters=parameters_filtered,\n        note=metadata.get(\"description\"),\n        status=get_status_pill(self.status),\n        submitted=get_submitted_pill(metadata.get(\"submitted\", False)),\n        timestamp=metadata.get(\"created_at\", \"N/A\"),\n    )"
                    },
                    "from_uid": {
                      "name": "from_uid",
                      "path": "bamboost.core.simulation.base._Simulation.from_uid",
                      "signature": "(cls, uid, **kwargs) -> Self",
                      "description": "Return the `Simulation` with given UID.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "the full id (Collection uid : simulation name)"
                            }
                          ]
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef from_uid(cls, uid: str, **kwargs) -> Self:\n    \"\"\"Return the `Simulation` with given UID.\n\n    Args:\n        uid: the full id (Collection uid : simulation name)\n        **kwargs: additional arguments to pass to the constructor\n    \"\"\"\n    collection_uid, name = uid.split(constants.UID_SEPARATOR)\n    index = kwargs.pop(\"index\", None) or Index.default\n    collection_path = index.resolve_path(collection_uid)\n    return cls(name, collection_path, index=index, **kwargs)"
                    },
                    "edit": {
                      "name": "edit",
                      "path": "bamboost.core.simulation.base._Simulation.edit",
                      "signature": "(self) -> SimulationWriter",
                      "description": "Return an object with writing rights to edit the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def edit(self) -> SimulationWriter:\n    \"\"\"Return an object with writing rights to edit the simulation.\"\"\"\n    return SimulationWriter(\n        self.name,\n        self.path.parent,\n        self._comm,\n        self._index,\n        collection_uid=self.collection_uid,\n    )"
                    },
                    "update_database": {
                      "name": "update_database",
                      "path": "bamboost.core.simulation.base._Simulation.update_database",
                      "signature": "(self, *, metadata=None, parameters=None) -> None",
                      "description": "Push update to sqlite database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "metadata",
                          "annotation": "typing.Optional[typing.Mapping]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "metadata dictionary to insert"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "parameters",
                          "annotation": "typing.Optional[typing.Mapping]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "parameter dictionary to insert"
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def update_database(\n    self,\n    *,\n    metadata: Optional[Mapping] = None,\n    parameters: Optional[Mapping] = None,\n) -> None:\n    \"\"\"Push update to sqlite database.\n\n    Args:\n        metadata: metadata dictionary to insert\n        parameters: parameter dictionary to insert\n    \"\"\"\n    if not config.index.syncTables:\n        return\n\n    if metadata:\n        self._index.update_simulation_metadata(\n            self.collection_uid, self.name, metadata\n        )\n    if parameters:\n        self._index.update_simulation_parameters(\n            self.collection_uid, self.name, parameters\n        )"
                    },
                    "open_in_paraview": {
                      "name": "open_in_paraview",
                      "path": "bamboost.core.simulation.base._Simulation.open_in_paraview",
                      "signature": "(self) -> None",
                      "description": "Open the xdmf file in paraview.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def open_in_paraview(self) -> None:\n    \"\"\"Open the xdmf file in paraview.\"\"\"\n    subprocess.call([\"paraview\", self._xdmf_file])"
                    },
                    "enter_path": {
                      "name": "enter_path",
                      "path": "bamboost.core.simulation.base._Simulation.enter_path",
                      "signature": "(self)",
                      "description": "A context manager for changing the working directory to this simulations' path.\n\n>>> with sim.working_directory():\n>>>     ...",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@contextmanager\ndef enter_path(self):\n    \"\"\"A context manager for changing the working directory to this simulations' path.\n\n    >>> with sim.working_directory():\n    >>>     ...\n    \"\"\"\n\n    current_dir = os.getcwd()\n    try:\n        os.chdir(self.path)\n        yield\n    finally:\n        os.chdir(current_dir)"
                    },
                    "require_series": {
                      "name": "require_series",
                      "path": "bamboost.core.simulation.base._Simulation.require_series",
                      "signature": "(self, path) -> Series[_MT]",
                      "description": "Return a series object for the given path.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "path to the series"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def require_series(self, path: str) -> Series[_MT]:\n    \"\"\"Return a series object for the given path.\n\n    Args:\n        path: path to the series\n    \"\"\"\n    return Series(self, path=path)"
                    },
                    "create_xdmf": {
                      "name": "create_xdmf",
                      "path": "bamboost.core.simulation.base._Simulation.create_xdmf",
                      "signature": "(self, field_names=None, timesteps=None, *, series=None, filename=None, mesh_name=constants.DEFAULT_MESH_NAME)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field_names",
                          "annotation": "typing.Optional[typing.Iterable[str]]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "timesteps",
                          "annotation": "typing.Optional[typing.Iterable[float]]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "series",
                          "annotation": "typing.Optional[bamboost.core.simulation.series.Series[bamboost._typing._MT]]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "filename",
                          "annotation": "typing.Optional[bamboost.utilities.StrPath]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": "bamboost.constants.bamboost.constants.DEFAULT_MESH_NAME"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def create_xdmf(\n    self,\n    field_names: Optional[Iterable[str]] = None,\n    timesteps: Optional[Iterable[float]] = None,\n    *,\n    series: Optional[Series[_MT]] = None,\n    filename: Optional[StrPath] = None,\n    mesh_name: str = constants.DEFAULT_MESH_NAME,\n):\n    from bamboost.core.simulation.xdmf import XDMFWriter\n\n    series = series or self.data\n    fields = series.get_fields(*field_names if field_names else [])\n    filename = filename or self.path.joinpath(constants.XDMF_FILE_NAME)\n    timesteps = timesteps if timesteps is not None else series.values\n\n    def _create_xdmf():\n        xdmf = XDMFWriter(self._file)\n        xdmf.add_mesh(self.meshes[mesh_name])\n        xdmf.add_timeseries(timesteps, fields, mesh_name)\n        xdmf.write_file(filename)\n        log.debug(f\"produced XDMF file at {filename}\")\n\n    self.post_write_instruction(_create_xdmf)"
                    }
                  },
                  "source": "class _Simulation(H5Object[_MT]):\n    \"\"\"Abstract simulation base class. Use `Simulation` or `SimulationWriter` instead.\n\n    Args:\n        name: Name for the simulation.\n        parent: Path to parent/collection directory.\n        comm: MPI communicator. Defaults to MPI.COMM_WORLD.\n        index: Index object. Defaults to the global index file.\n\n    Raises:\n        FileNotFoundError: If the simulation doesn't exist.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        parent: StrPath,\n        comm: Optional[Comm] = None,\n        index: Optional[Index] = None,\n        **kwargs,\n    ):\n        self.name: str = name\n        self.path: Path = Path(parent).joinpath(name).absolute()\n        if not self.path.is_dir():\n            raise FileNotFoundError(\n                f\"Simulation {self.name} does not exist in {self.path}.\"\n            )\n\n        # MPI information\n        self._psize: int = self._comm.size\n        self._prank: int = self._comm.rank\n        self._ranks = np.array([i for i in range(self._psize)])\n\n        # Reference to the database\n        # 06.03.2025: Maybe use the default index instance instead of a new one...\n        self._index: Index = index or Index(comm=self._comm)\n\n        # Shortcut to collection uid if available, otherwise resolve it\n        self.collection_uid: CollectionUID = kwargs.pop(\n            \"collection_uid\", None\n        ) or self._index.resolve_uid(self.path.parent)\n\n        self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n        self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n        self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)\n\n    def __eq__(self, other: _Simulation, /) -> bool:\n        return (\n            self.uid == other.uid\n            and self.name == other.name\n            and self.path == other.path\n            and self.mutable == other.mutable\n        )\n\n    def _repr_html_(self):\n        import pkgutil\n\n        from jinja2 import Template\n\n        metadata = self.metadata\n        parameters_filtered = {\n            k: \"...\"\n            if isinstance(v, Sized) and not isinstance(v, str) and len(v) > 5\n            else v\n            for k, v in self.parameters.items()\n        }\n\n        def get_pill_div(text: str, color: str) -> str:\n            return (\n                f'<div class=\"status\" style=\"background-color:'\n                f'var(--bb-{color});\">{text}</div>'\n            )\n\n        def get_status_pill(status: StatusInfo) -> str:\n            if status.status == Status.FAILED:\n                return get_pill_div(status.format(), \"red\")\n            elif status.status == Status.FINISHED:\n                return get_pill_div(status.format(), \"green\")\n            elif status.status in (Status.INITIALIZED, Status.UNKNOWN):\n                return get_pill_div(status.format(), \"grey\")\n            elif status.status == Status.STARTED:\n                return get_pill_div(status.format(), \"orange\")\n            else:\n                return get_pill_div(status.format(), \"grey\")\n\n        def get_submitted_pill(submitted: bool) -> str:\n            return (\n                get_pill_div(\"Submitted\", \"green\")\n                if submitted\n                else get_pill_div(\"Not submitted\", \"grey\")\n            )\n\n        html_string = pkgutil.get_data(\"bamboost\", \"_repr/simulation.html\").decode()\n        icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n        template = Template(html_string)\n        file_tree = str(self.files).replace(\"\\n\", \"</br>\").replace(\" \", \"&nbsp;\")\n\n        return template.render(\n            uid=self.name,\n            icon=icon,\n            tree=file_tree,\n            parameters=parameters_filtered,\n            note=metadata.get(\"description\"),\n            status=get_status_pill(self.status),\n            submitted=get_submitted_pill(metadata.get(\"submitted\", False)),\n            timestamp=metadata.get(\"created_at\", \"N/A\"),\n        )\n\n    @cached_property\n    def root(self) -> Group[_MT]:\n        return Group(\"/\", self._file)\n\n    @property\n    @abstractmethod\n    def _file(self) -> HDF5File[_MT]: ...\n\n    @property\n    def mutable(self) -> bool:\n        return self._file.mutable\n\n    @property\n    def _orm(self) -> SimulationORM:\n        return self._index.simulation(self.collection_uid, self.name)\n\n    @classmethod\n    def from_uid(cls, uid: str, **kwargs) -> Self:\n        \"\"\"Return the `Simulation` with given UID.\n\n        Args:\n            uid: the full id (Collection uid : simulation name)\n            **kwargs: additional arguments to pass to the constructor\n        \"\"\"\n        collection_uid, name = uid.split(constants.UID_SEPARATOR)\n        index = kwargs.pop(\"index\", None) or Index.default\n        collection_path = index.resolve_path(collection_uid)\n        return cls(name, collection_path, index=index, **kwargs)\n\n    @property\n    def uid(self) -> str:\n        \"\"\"The full uid of the simulation (collection_uid:simulation_name).\"\"\"\n        return f\"{self.collection_uid}{constants.UID_SEPARATOR}{self.name}\"\n\n    def edit(self) -> SimulationWriter:\n        \"\"\"Return an object with writing rights to edit the simulation.\"\"\"\n        return SimulationWriter(\n            self.name,\n            self.path.parent,\n            self._comm,\n            self._index,\n            collection_uid=self.collection_uid,\n        )\n\n    def update_database(\n        self,\n        *,\n        metadata: Optional[Mapping] = None,\n        parameters: Optional[Mapping] = None,\n    ) -> None:\n        \"\"\"Push update to sqlite database.\n\n        Args:\n            metadata: metadata dictionary to insert\n            parameters: parameter dictionary to insert\n        \"\"\"\n        if not config.index.syncTables:\n            return\n\n        if metadata:\n            self._index.update_simulation_metadata(\n                self.collection_uid, self.name, metadata\n            )\n        if parameters:\n            self._index.update_simulation_parameters(\n                self.collection_uid, self.name, parameters\n            )\n\n    @cached_property\n    def parameters(self) -> Parameters[_MT]:\n        return Parameters(self)\n\n    @cached_property\n    def metadata(self) -> Metadata[_MT]:\n        return Metadata(self)\n\n    @property\n    def status(self) -> StatusInfo:\n        try:\n            return StatusInfo.parse(self.metadata.__getitem__(\"status\"))\n        except KeyError:\n            return StatusInfo(Status.UNKNOWN)\n\n    @property\n    def created_at(self) -> datetime:\n        return self.metadata.__getitem__(\"created_at\")\n\n    @property\n    def description(self) -> str:\n        return self.metadata.__getitem__(\"description\")\n\n    @cached_property\n    def links(self) -> Links[_MT]:\n        return Links(self)\n\n    @cached_property\n    def files(self):\n        return utilities.FilePicker(self.path)\n\n    @cached_property\n    def git(self) -> GroupGit[_MT]:\n        return GroupGit(self)\n\n    @cached_property\n    def data(self) -> Series[_MT]:\n        \"\"\"Return the default data series.\"\"\"\n        return Series(self, path=constants.PATH_DATA)\n\n    @cached_property\n    def meshes(self) -> GroupMeshes[_MT]:\n        return GroupMeshes(self)\n\n    @cached_property\n    def mesh(self) -> GroupMesh:\n        return GroupMesh(self, constants.DEFAULT_MESH_NAME)\n\n    def open_in_paraview(self) -> None:\n        \"\"\"Open the xdmf file in paraview.\"\"\"\n        subprocess.call([\"paraview\", self._xdmf_file])\n\n    @contextmanager\n    def enter_path(self):\n        \"\"\"A context manager for changing the working directory to this simulations' path.\n\n        >>> with sim.working_directory():\n        >>>     ...\n        \"\"\"\n\n        current_dir = os.getcwd()\n        try:\n            os.chdir(self.path)\n            yield\n        finally:\n            os.chdir(current_dir)\n\n    def require_series(self, path: str) -> Series[_MT]:\n        \"\"\"Return a series object for the given path.\n\n        Args:\n            path: path to the series\n        \"\"\"\n        return Series(self, path=path)\n\n    def create_xdmf(\n        self,\n        field_names: Optional[Iterable[str]] = None,\n        timesteps: Optional[Iterable[float]] = None,\n        *,\n        series: Optional[Series[_MT]] = None,\n        filename: Optional[StrPath] = None,\n        mesh_name: str = constants.DEFAULT_MESH_NAME,\n    ):\n        from bamboost.core.simulation.xdmf import XDMFWriter\n\n        series = series or self.data\n        fields = series.get_fields(*field_names if field_names else [])\n        filename = filename or self.path.joinpath(constants.XDMF_FILE_NAME)\n        timesteps = timesteps if timesteps is not None else series.values\n\n        def _create_xdmf():\n            xdmf = XDMFWriter(self._file)\n            xdmf.add_mesh(self.meshes[mesh_name])\n            xdmf.add_timeseries(timesteps, fields, mesh_name)\n            xdmf.write_file(filename)\n            log.debug(f\"produced XDMF file at {filename}\")\n\n        self.post_write_instruction(_create_xdmf)",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "Simulation": {
                  "name": "Simulation",
                  "path": "bamboost.core.simulation.base.Simulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "bamboost.utilities.StrPath",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "typing.Optional[bamboost.index.Index]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing.Immutable]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class Simulation(_Simulation[Immutable]):\n    @cached_property\n    def _file(self) -> HDF5File[Immutable]:\n        return HDF5File(self._data_file, comm=self._comm, mutable=False)",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.simulation.base._Simulation": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.__init__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.name"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._psize"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._prank"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._ranks"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._data_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._bash_file"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.__eq__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.root"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._orm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.from_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.uid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.edit"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.update_database"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.parameters"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.metadata"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.created_at"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.description"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.links"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.files"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.git"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.meshes"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mesh"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.enter_path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.require_series"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.create_xdmf"
                      }
                    ]
                  }
                },
                "SimulationWriter": {
                  "name": "SimulationWriter",
                  "path": "bamboost.core.simulation.base.SimulationWriter",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "bamboost.utilities.StrPath",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "typing.Optional[bamboost.index.Index]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing.Mutable]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__init__",
                      "signature": "(self, name, parent, comm=None, index=None, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "bamboost.utilities.StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "typing.Optional[bamboost.mpi.Comm]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "index",
                          "annotation": "typing.Optional[bamboost.index.Index]",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    name: str,\n    parent: StrPath,\n    comm: Optional[Comm] = None,\n    index: Optional[Index] = None,\n    **kwargs,\n):\n    super().__init__(name, parent, comm, index, **kwargs)"
                    },
                    "__enter__": {
                      "name": "__enter__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__enter__",
                      "signature": "(self) -> SimulationWriter",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __enter__(self) -> SimulationWriter:\n    self.status = Status.STARTED\n    return self"
                    },
                    "__exit__": {
                      "name": "__exit__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__exit__",
                      "signature": "(self, exc_type, exc_val, exc_tb)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_type",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_val",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_tb",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __exit__(self, exc_type, exc_val, exc_tb):\n    if exc_type:\n        self.status = StatusInfo(Status.FAILED, str(exc_val))\n        log.error(\n            f\"Simulation failed with {exc_type.__name__}: {exc_val}\\nTraceback: {exc_tb}\"\n        )\n        return\n    self.status = Status.FINISHED"
                    },
                    "initialize": {
                      "name": "initialize",
                      "path": "bamboost.core.simulation.base.SimulationWriter.initialize",
                      "signature": "(self) -> None",
                      "description": "Initialize the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def initialize(self) -> None:\n    \"\"\"Initialize the simulation.\"\"\"\n    # create the data file\n    with self._file.open(FileMode.APPEND, driver=\"mpio\") as f:\n        self.metadata.update(\n            {\n                \"status\": Status.INITIALIZED.value,\n                \"created_at\": datetime.now(),\n            }\n        )\n        # create groups\n        f.create_group(constants.PATH_PARAMETERS)\n        f.create_group(constants.PATH_LINKS)\n        f.create_group(constants.PATH_MESH)\n\n        # create default series ('data')\n        self._initialize_series(constants.PATH_DATA)\n\n    self._comm.barrier()"
                    },
                    "_initialize_series": {
                      "name": "_initialize_series",
                      "path": "bamboost.core.simulation.base.SimulationWriter._initialize_series",
                      "signature": "(self, path) -> None",
                      "description": "Create the groups for a series. Does not manage file state.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "path of the series"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _initialize_series(self, path: str) -> None:\n    \"\"\"Create the groups for a series. Does not manage file state.\n\n    Args:\n        path: path of the series\n    \"\"\"\n    # add series to metadata for easier retrieval\n    all_series = set(self.metadata.get(\".series_paths\", []))\n    all_series.add(str(path))\n    self.metadata.set(\".series_paths\", list(all_series))\n\n    f = self._file\n    grp = f.require_group(path)\n    grp.attrs[\".series\"] = True\n    grp.require_group(constants.RELATIVE_PATH_FIELD_DATA)\n    grp.require_group(constants.RELATIVE_PATH_SCALAR_DATA)"
                    },
                    "status": {
                      "name": "status",
                      "path": "bamboost.core.simulation.base.SimulationWriter.status",
                      "signature": "(self, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "typing.Union[bamboost.core.simulation.base.StatusInfo, bamboost.core.simulation.base.Status]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@_Simulation.status.setter\ndef status(self, value: Union[StatusInfo, Status]) -> None:\n    self.metadata.__setitem__(\"status\", value.format())"
                    },
                    "description": {
                      "name": "description",
                      "path": "bamboost.core.simulation.base.SimulationWriter.description",
                      "signature": "(self, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@_Simulation.description.setter\ndef description(self, value: str) -> None:\n    self.metadata.__setitem__(\"description\", value)"
                    },
                    "require_series": {
                      "name": "require_series",
                      "path": "bamboost.core.simulation.base.SimulationWriter.require_series",
                      "signature": "(self, path) -> Series[Mutable]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def require_series(self, path: str) -> Series[Mutable]:\n    # require the group in the HDF5 file\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        if path not in self.root.keys():\n            self._initialize_series(path)\n    return super().require_series(path)"
                    },
                    "copy_files": {
                      "name": "copy_files",
                      "path": "bamboost.core.simulation.base.SimulationWriter.copy_files",
                      "signature": "(self, files) -> None",
                      "description": "Copy files to the simulation folder.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "files",
                          "annotation": "typing.Iterable[bamboost.utilities.StrPath]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "list of files/directories to copy"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def copy_files(self, files: Iterable[StrPath]) -> None:\n    \"\"\"Copy files to the simulation folder.\n\n    Args:\n        files: list of files/directories to copy\n    \"\"\"\n    import shutil\n\n    for file in files:\n        path = Path(file)\n        if path.is_file():\n            shutil.copy(path, self.path)\n        elif path.is_dir():\n            shutil.copytree(path, self.path)"
                    },
                    "create_run_script": {
                      "name": "create_run_script",
                      "path": "bamboost.core.simulation.base.SimulationWriter.create_run_script",
                      "signature": "(self, commands, euler=False, sbatch_kwargs=None) -> None",
                      "description": "Create a batch job and put it into the folder.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "commands",
                          "annotation": "list[str]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A list of strings being the user defined commands to run"
                            }
                          ]
                        },
                        {
                          "name": "euler",
                          "annotation": "bool",
                          "description": [
                            {
                              "kind": "text",
                              "value": "If false, a local bash script will be written"
                            }
                          ],
                          "value": "False"
                        },
                        {
                          "name": "sbatch_kwargs",
                          "annotation": "typing.Optional[bamboost.core.simulation.dict[str, typing.Any]]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Additional sbatch arguments.\nThis parameter allows you to provide additional arguments to the `sbatch` command\nwhen submitting jobs to a Slurm workload manager. The arguments should be provided\nin the format of a dict of sbatch option name and values.\n\nUse this parameter to specify various job submission options such as the number of\ntasks, CPU cores, memory requirements, email notifications, and other sbatch options\nthat are not covered by default settings.\nBy default, the following sbatch options are set:\n- `--output`: The output file is set to `<uid>.out`.\n- `--job-name`: The job name is set to `<full_uid>`.\n\nThe following arguments should bring you far:\n- `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n- `--mem-per-cpu`: The memory required per CPU core.\n- `--time`: The maximum time the job is allowed to run.\n- `--tmp`: Temporary scratch space to use for the job."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def create_run_script(\n    self,\n    commands: list[str],\n    euler: bool = False,\n    sbatch_kwargs: Optional[dict[str, Any]] = None,\n) -> None:\n    \"\"\"Create a batch job and put it into the folder.\n\n    Args:\n        commands: A list of strings being the user defined commands to run\n        euler: If false, a local bash script will be written\n        sbatch_kwargs: Additional sbatch arguments.\n            This parameter allows you to provide additional arguments to the `sbatch` command\n            when submitting jobs to a Slurm workload manager. The arguments should be provided\n            in the format of a dict of sbatch option name and values.\n\n            Use this parameter to specify various job submission options such as the number of\n            tasks, CPU cores, memory requirements, email notifications, and other sbatch options\n            that are not covered by default settings.\n            By default, the following sbatch options are set:\n            - `--output`: The output file is set to `<uid>.out`.\n            - `--job-name`: The job name is set to `<full_uid>`.\n\n            The following arguments should bring you far:\n            - `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n            - `--mem-per-cpu`: The memory required per CPU core.\n            - `--time`: The maximum time the job is allowed to run.\n            - `--tmp`: Temporary scratch space to use for the job.\n    \"\"\"\n    script = \"#!/bin/bash\\n\\n\"\n\n    # Add sbatch options\n    if euler:\n        if sbatch_kwargs is None:\n            sbatch_kwargs = {}\n\n        sbatch_kwargs.setdefault(\n            \"--output\", f\"{self.path.joinpath(self.name + '.out')}\"\n        )\n        sbatch_kwargs.setdefault(\"--job-name\", self.uid)\n\n        for key, value in sbatch_kwargs.items():\n            script += f\"#SBATCH {key}={value}\\n\"\n\n    # Add environment variables\n    script += \"\\n\"\n    script += (\n        f\"export SIMULATION_DIR={self.path.as_posix()}\\n\"\n        f\"export SIMULATION_ID={self.uid}\\n\\n\"\n    )\n    script += \"\\n\".join(commands)\n\n    with self._bash_file.open(\"w\") as file:\n        file.write(script)\n\n    self.metadata[\"submitted\"] = False"
                    },
                    "run_simulation": {
                      "name": "run_simulation",
                      "path": "bamboost.core.simulation.base.SimulationWriter.run_simulation",
                      "signature": "(self, executable='bash') -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "executable",
                          "annotation": "str",
                          "description": null,
                          "value": "'bash'"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def run_simulation(self, executable: str = \"bash\") -> None:\n    assert not MPI_ON, \"This method is not available during MPI execution.\"\n\n    if not self._bash_file.exists():\n        raise FileNotFoundError(\n            f\"Run script {self._bash_file} does not exist. Create one with `create_run_script`.\"\n        )\n\n    env = os.environ.copy()\n    _ = env.pop(\"BAMBOOST_MPI\", None)  # remove bamboost MPI environment variable\n    subprocess.run([executable, self._bash_file.as_posix()], env=env)\n    log.info(f'Simulation \"{self.name}\" submitted.')\n    self.metadata[\"submitted\"] = True"
                    },
                    "submit_simulation": {
                      "name": "submit_simulation",
                      "path": "bamboost.core.simulation.base.SimulationWriter.submit_simulation",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def submit_simulation(self) -> None:\n    self.run_simulation(executable=\"sbatch\")"
                    }
                  },
                  "source": "class SimulationWriter(_Simulation[Mutable]):\n    def __init__(\n        self,\n        name: str,\n        parent: StrPath,\n        comm: Optional[Comm] = None,\n        index: Optional[Index] = None,\n        **kwargs,\n    ):\n        super().__init__(name, parent, comm, index, **kwargs)\n\n    def __enter__(self) -> SimulationWriter:\n        self.status = Status.STARTED\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            self.status = StatusInfo(Status.FAILED, str(exc_val))\n            log.error(\n                f\"Simulation failed with {exc_type.__name__}: {exc_val}\\nTraceback: {exc_tb}\"\n            )\n            return\n        self.status = Status.FINISHED\n\n    @cached_property\n    def _file(self) -> HDF5File[Mutable]:\n        return HDF5File(self._data_file, comm=self._comm, mutable=True)\n\n    def initialize(self) -> None:\n        \"\"\"Initialize the simulation.\"\"\"\n        # create the data file\n        with self._file.open(FileMode.APPEND, driver=\"mpio\") as f:\n            self.metadata.update(\n                {\n                    \"status\": Status.INITIALIZED.value,\n                    \"created_at\": datetime.now(),\n                }\n            )\n            # create groups\n            f.create_group(constants.PATH_PARAMETERS)\n            f.create_group(constants.PATH_LINKS)\n            f.create_group(constants.PATH_MESH)\n\n            # create default series ('data')\n            self._initialize_series(constants.PATH_DATA)\n\n        self._comm.barrier()\n\n    def _initialize_series(self, path: str) -> None:\n        \"\"\"Create the groups for a series. Does not manage file state.\n\n        Args:\n            path: path of the series\n        \"\"\"\n        # add series to metadata for easier retrieval\n        all_series = set(self.metadata.get(\".series_paths\", []))\n        all_series.add(str(path))\n        self.metadata.set(\".series_paths\", list(all_series))\n\n        f = self._file\n        grp = f.require_group(path)\n        grp.attrs[\".series\"] = True\n        grp.require_group(constants.RELATIVE_PATH_FIELD_DATA)\n        grp.require_group(constants.RELATIVE_PATH_SCALAR_DATA)\n\n    @_Simulation.status.setter\n    def status(self, value: Union[StatusInfo, Status]) -> None:\n        self.metadata.__setitem__(\"status\", value.format())\n\n    @_Simulation.description.setter\n    def description(self, value: str) -> None:\n        self.metadata.__setitem__(\"description\", value)\n\n    def require_series(self, path: str) -> Series[Mutable]:\n        # require the group in the HDF5 file\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            if path not in self.root.keys():\n                self._initialize_series(path)\n        return super().require_series(path)\n\n    def copy_files(self, files: Iterable[StrPath]) -> None:\n        \"\"\"Copy files to the simulation folder.\n\n        Args:\n            files: list of files/directories to copy\n        \"\"\"\n        import shutil\n\n        for file in files:\n            path = Path(file)\n            if path.is_file():\n                shutil.copy(path, self.path)\n            elif path.is_dir():\n                shutil.copytree(path, self.path)\n\n    def create_run_script(\n        self,\n        commands: list[str],\n        euler: bool = False,\n        sbatch_kwargs: Optional[dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"Create a batch job and put it into the folder.\n\n        Args:\n            commands: A list of strings being the user defined commands to run\n            euler: If false, a local bash script will be written\n            sbatch_kwargs: Additional sbatch arguments.\n                This parameter allows you to provide additional arguments to the `sbatch` command\n                when submitting jobs to a Slurm workload manager. The arguments should be provided\n                in the format of a dict of sbatch option name and values.\n\n                Use this parameter to specify various job submission options such as the number of\n                tasks, CPU cores, memory requirements, email notifications, and other sbatch options\n                that are not covered by default settings.\n                By default, the following sbatch options are set:\n                - `--output`: The output file is set to `<uid>.out`.\n                - `--job-name`: The job name is set to `<full_uid>`.\n\n                The following arguments should bring you far:\n                - `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n                - `--mem-per-cpu`: The memory required per CPU core.\n                - `--time`: The maximum time the job is allowed to run.\n                - `--tmp`: Temporary scratch space to use for the job.\n        \"\"\"\n        script = \"#!/bin/bash\\n\\n\"\n\n        # Add sbatch options\n        if euler:\n            if sbatch_kwargs is None:\n                sbatch_kwargs = {}\n\n            sbatch_kwargs.setdefault(\n                \"--output\", f\"{self.path.joinpath(self.name + '.out')}\"\n            )\n            sbatch_kwargs.setdefault(\"--job-name\", self.uid)\n\n            for key, value in sbatch_kwargs.items():\n                script += f\"#SBATCH {key}={value}\\n\"\n\n        # Add environment variables\n        script += \"\\n\"\n        script += (\n            f\"export SIMULATION_DIR={self.path.as_posix()}\\n\"\n            f\"export SIMULATION_ID={self.uid}\\n\\n\"\n        )\n        script += \"\\n\".join(commands)\n\n        with self._bash_file.open(\"w\") as file:\n            file.write(script)\n\n        self.metadata[\"submitted\"] = False\n\n    def run_simulation(self, executable: str = \"bash\") -> None:\n        assert not MPI_ON, \"This method is not available during MPI execution.\"\n\n        if not self._bash_file.exists():\n            raise FileNotFoundError(\n                f\"Run script {self._bash_file} does not exist. Create one with `create_run_script`.\"\n            )\n\n        env = os.environ.copy()\n        _ = env.pop(\"BAMBOOST_MPI\", None)  # remove bamboost MPI environment variable\n        subprocess.run([executable, self._bash_file.as_posix()], env=env)\n        log.info(f'Simulation \"{self.name}\" submitted.')\n        self.metadata[\"submitted\"] = True\n\n    def submit_simulation(self) -> None:\n        self.run_simulation(executable=\"sbatch\")",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.simulation.base._Simulation": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.name"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._psize"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._prank"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._ranks"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._data_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._bash_file"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.__eq__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.root"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._orm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.from_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.uid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.edit"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.update_database"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.parameters"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.metadata"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.created_at"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.links"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.files"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.git"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.meshes"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mesh"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.enter_path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.create_xdmf"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "groups": {
              "name": "groups",
              "path": "bamboost.core.simulation.groups",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/groups.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild(__name__)"
                }
              ],
              "modules": {},
              "classes": {
                "GroupMeshes": {
                  "name": "GroupMeshes",
                  "path": "bamboost.core.simulation.groups.GroupMeshes",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.simulation.groups.GroupMeshes(simulation)"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\"):\n    super().__init__(PATH_MESH, simulation._file)\n    self._simulation = simulation"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.__getitem__",
                      "signature": "(self, key) -> GroupMesh[_MT]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> GroupMesh[_MT]:\n    return GroupMesh(self._simulation, key)"
                    },
                    "add": {
                      "name": "add",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.add",
                      "signature": "(self, nodes, cells, name=DEFAULT_MESH_NAME, cell_type=CellType.TRIANGLE) -> None",
                      "description": "Add a mesh with the given name to the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.groups.GroupMeshes[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "nodes",
                          "annotation": "numpy.numpy.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Node coordinates"
                            }
                          ]
                        },
                        {
                          "name": "cells",
                          "annotation": "numpy.numpy.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Cell connectivity"
                            }
                          ]
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Name of the mesh"
                            }
                          ],
                          "value": "bamboost.constants.DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "cell_type",
                          "annotation": "bamboost.core.simulation.CellType",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Cell type (default: \"triangle\"). In general, we do not care about\nthe cell type and leave it up to the user to make sense of the data they\nprovide. However, the cell type specified is needed for writing an XDMF\nfile. For possible types, consult the XDMF/paraview manual."
                            }
                          ],
                          "value": "bamboost.core.simulation.CellType.bamboost.core.simulation.CellType.TRIANGLE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add(\n    self: GroupMeshes[Mutable],\n    nodes: np.ndarray,\n    cells: np.ndarray,\n    name: str = DEFAULT_MESH_NAME,\n    cell_type: CellType = CellType.TRIANGLE,\n) -> None:\n    \"\"\"Add a mesh with the given name to the simulation.\n\n    Args:\n        nodes: Node coordinates\n        cells: Cell connectivity\n        name: Name of the mesh\n        cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n            the cell type and leave it up to the user to make sense of the data they\n            provide. However, the cell type specified is needed for writing an XDMF\n            file. For possible types, consult the XDMF/paraview manual.\n    \"\"\"\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        new_grp = self.require_group(name)\n        new_grp.add_numerical_dataset(\"coordinates\", vector=nodes)\n        new_grp.add_numerical_dataset(\n            \"topology\", vector=cells, attrs={\"cell_type\": cell_type.value}\n        )"
                    }
                  },
                  "source": "class GroupMeshes(Group[_MT]):\n    def __init__(self, simulation: \"_Simulation\"):\n        super().__init__(PATH_MESH, simulation._file)\n        self._simulation = simulation\n\n    def __getitem__(self, key: str) -> GroupMesh[_MT]:\n        return GroupMesh(self._simulation, key)\n\n    def add(\n        self: GroupMeshes[Mutable],\n        nodes: np.ndarray,\n        cells: np.ndarray,\n        name: str = DEFAULT_MESH_NAME,\n        cell_type: CellType = CellType.TRIANGLE,\n    ) -> None:\n        \"\"\"Add a mesh with the given name to the simulation.\n\n        Args:\n            nodes: Node coordinates\n            cells: Cell connectivity\n            name: Name of the mesh\n            cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n                the cell type and leave it up to the user to make sense of the data they\n                provide. However, the cell type specified is needed for writing an XDMF\n                file. For possible types, consult the XDMF/paraview manual.\n        \"\"\"\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            new_grp = self.require_group(name)\n            new_grp.add_numerical_dataset(\"coordinates\", vector=nodes)\n            new_grp.add_numerical_dataset(\n                \"topology\", vector=cells, attrs={\"cell_type\": cell_type.value}\n            )",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._is_valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__contains__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GroupMesh": {
                  "name": "GroupMesh",
                  "path": "bamboost.core.simulation.groups.GroupMesh",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "NODES",
                      "annotation": null,
                      "description": null,
                      "value": "'coordinates'"
                    },
                    {
                      "name": "CELLS",
                      "annotation": null,
                      "description": null,
                      "value": "'topology'"
                    },
                    {
                      "name": "coordinates",
                      "annotation": "numpy.numpy.ndarray[tuple[int, ...], numpy.numpy.dtype[numpy.numpy.float64]]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "cells",
                      "annotation": "numpy.numpy.ndarray[tuple[int, ...], numpy.numpy.dtype[numpy.numpy.int64]]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "cell_type",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupMesh.__init__",
                      "signature": "(self, simulation, name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\", name: str):\n    super().__init__(f\"{PATH_MESH}/{name}\", simulation._file)"
                    }
                  },
                  "source": "class GroupMesh(Group[_MT]):\n    NODES = \"coordinates\"\n    CELLS = \"topology\"\n\n    def __init__(self, simulation: \"_Simulation\", name: str):\n        super().__init__(f\"{PATH_MESH}/{name}\", simulation._file)\n\n    @property\n    def coordinates(self) -> np.ndarray[tuple[int, ...], np.dtype[np.float64]]:\n        return self[self.NODES][:]\n\n    @property\n    def cells(self) -> np.ndarray[tuple[int, ...], np.dtype[np.int64]]:\n        return self[self.CELLS][:]\n\n    @property\n    def cell_type(self) -> str:\n        return self.attrs[\"cell_type\"]",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._is_valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__contains__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "_GitStatus": {
                  "name": "_GitStatus",
                  "path": "bamboost.core.simulation.groups._GitStatus",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "origin",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "commit",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "branch",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "patch",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class _GitStatus(TypedDict):\n    origin: str\n    commit: str\n    branch: str\n    patch: str",
                  "inherited_members": {}
                },
                "GroupGit": {
                  "name": "GroupGit",
                  "path": "bamboost.core.simulation.groups.GroupGit",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation[_MT]'",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupGit.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation[_MT]'",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation[_MT]\"):\n    super().__init__(\".git\", simulation._file)"
                    },
                    "add": {
                      "name": "add",
                      "path": "bamboost.core.simulation.groups.GroupGit.add",
                      "signature": "(self, repo_name, repo_path) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.groups.GroupGit[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "repo_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "repo_path",
                          "annotation": "bamboost._typing.StrPath",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add(self: GroupGit[Mutable], repo_name: str, repo_path: StrPath) -> None:\n    # Make sure the .git group exists\n    self.require_self()\n\n    status = get_git_status(repo_path)\n    if repo_name in self.keys():  # delete if already exists\n        del self[repo_name]\n\n    new_grp = self.require_group(repo_name)\n    new_grp.attrs.update(\n        {k: v for k, v in status.items() if k in {\"origin\", \"commit\", \"branch\"}}\n    )\n    new_grp.add_dataset(\"patch\", data=status[\"patch\"])"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupGit.__getitem__",
                      "signature": "(self, key) -> GitItem",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> GitItem:\n    grp = super().__getitem__((key, Group[_MT]))\n    return GitItem(key, grp.attrs._dict, grp[\"patch\"][()])"
                    }
                  },
                  "source": "class GroupGit(Group[_MT]):\n    def __init__(self, simulation: \"_Simulation[_MT]\"):\n        super().__init__(\".git\", simulation._file)\n\n    def add(self: GroupGit[Mutable], repo_name: str, repo_path: StrPath) -> None:\n        # Make sure the .git group exists\n        self.require_self()\n\n        status = get_git_status(repo_path)\n        if repo_name in self.keys():  # delete if already exists\n            del self[repo_name]\n\n        new_grp = self.require_group(repo_name)\n        new_grp.attrs.update(\n            {k: v for k, v in status.items() if k in {\"origin\", \"commit\", \"branch\"}}\n        )\n        new_grp.add_dataset(\"patch\", data=status[\"patch\"])\n\n    def __getitem__(self, key: str) -> GitItem:\n        grp = super().__getitem__((key, Group[_MT]))\n        return GitItem(key, grp.attrs._dict, grp[\"patch\"][()])",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._is_valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__contains__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GitItem": {
                  "name": "GitItem",
                  "path": "bamboost.core.simulation.groups.GitItem",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attrs",
                      "annotation": "bamboost.core.simulation.dict[str, str]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "patch",
                      "annotation": "bytes",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "name",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.simulation.groups.GitItem(name)"
                    },
                    {
                      "name": "branch",
                      "annotation": null,
                      "description": null,
                      "value": "status['branch']"
                    },
                    {
                      "name": "commit",
                      "annotation": null,
                      "description": null,
                      "value": "status['commit']"
                    },
                    {
                      "name": "origin",
                      "annotation": null,
                      "description": null,
                      "value": "status['origin']"
                    },
                    {
                      "name": "patch",
                      "annotation": null,
                      "description": null,
                      "value": "patch.decode()"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GitItem.__init__",
                      "signature": "(self, name, attrs, patch)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "attrs",
                          "annotation": "bamboost.core.simulation.dict[str, str]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "patch",
                          "annotation": "bytes",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, name: str, attrs: dict[str, str], patch: bytes):\n    self.name = name\n    status: _GitStatus = cast(_GitStatus, attrs)\n    self.branch = status[\"branch\"]\n    self.commit = status[\"commit\"]\n    self.origin = status[\"origin\"]\n    self.patch = patch.decode()"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.simulation.groups.GitItem.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    return f\"GitItem(name={self.name}, branch={self.branch}, commit={self.commit}, origin={self.origin}, patch={self.patch[:10]}...)\""
                    }
                  },
                  "source": "class GitItem:\n    def __init__(self, name: str, attrs: dict[str, str], patch: bytes):\n        self.name = name\n        status: _GitStatus = cast(_GitStatus, attrs)\n        self.branch = status[\"branch\"]\n        self.commit = status[\"commit\"]\n        self.origin = status[\"origin\"]\n        self.patch = patch.decode()\n\n    def __repr__(self) -> str:\n        return f\"GitItem(name={self.name}, branch={self.branch}, commit={self.commit}, origin={self.origin}, patch={self.patch[:10]}...)\"",
                  "inherited_members": {}
                }
              },
              "functions": {
                "get_git_status": {
                  "name": "get_git_status",
                  "path": "bamboost.core.simulation.groups.get_git_status",
                  "signature": "(repo_path) -> _GitStatus",
                  "description": null,
                  "parameters": [
                    {
                      "name": "repo_path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_git_status(repo_path) -> _GitStatus:\n    import subprocess\n\n    def run_git_command(command: str) -> str:\n        res = \"\"\n        if Communicator._active_comm.rank == 0:\n            try:\n                res = subprocess.run(\n                    [\"git\", \"-C\", str(repo_path), *command.split()],\n                    capture_output=True,\n                    text=True,\n                    check=True,\n                ).stdout.strip()\n            except CalledProcessError:\n                res = \"Git command has failed\"\n        return Communicator._active_comm.bcast(res, root=0)\n\n    return {\n        \"origin\": run_git_command(\"remote get-url origin\"),\n        \"commit\": run_git_command(\"rev-parse HEAD\"),\n        \"branch\": run_git_command(\"rev-parse --abbrev-ref HEAD\"),\n        \"patch\": run_git_command(\"diff HEAD\"),\n    }"
                }
              }
            },
            "dict": {
              "name": "dict",
              "path": "bamboost.core.simulation.dict",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/dict.py",
              "description": null,
              "docstring": [],
              "attributes": [],
              "modules": {},
              "classes": {
                "Parameters": {
                  "name": "Parameters",
                  "path": "bamboost.core.simulation.dict.Parameters",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation",
                      "description": null,
                      "value": "bamboost.core.simulation.dict.Parameters(simulation)"
                    },
                    {
                      "name": "_dict",
                      "annotation": "bamboost._typing.SimulationParameterT",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.h5py.Group",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Parameters.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT]):\n    super().__init__(simulation._file, constants.PATH_PARAMETERS)\n    self._simulation = simulation"
                    },
                    "read": {
                      "name": "read",
                      "path": "bamboost.core.simulation.dict.Parameters.read",
                      "signature": "(self) -> dict",
                      "description": "Read the parameters from the HDF5 file.\n\nIn addition to the attributes from the group, this method also reads in\nall datasets in the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef read(self) -> dict:\n    \"\"\"Read the parameters from the HDF5 file.\n\n    In addition to the attributes from the group, this method also reads in\n    all datasets in the group.\n    \"\"\"\n    tmp_dict = dict()\n\n    try:\n        grp = cast(h5py.Group, self._file[self._path])\n    except KeyError:\n        raise KeyError(\n            f\"Group {self._path} not found in file {self._file._filename}.\"\n        )\n\n    # Read in attributes\n    tmp_dict.update(AttrsEncoder.decode(grp.attrs))\n\n    # Read in datasets\n    for key, value in grp.items():\n        if not isinstance(value, h5py.Dataset):\n            continue\n        tmp_dict.update({key: value[()]})\n\n    return utilities.unflatten_dict(tmp_dict)"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.simulation.dict.Parameters._ipython_key_completions_",
                      "signature": "(self) -> Generator[str, None, None]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self) -> Generator[str, None, None]:\n    for key, obj in self._dict.items():\n        yield key\n        if isinstance(obj, dict):\n            for subkey in obj.keys():\n                yield f\"{key}.{subkey}\""
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.dict.Parameters.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": "Get a parameter. Can use nested access with dot notation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Any:\n    \"\"\"Get a parameter. Can use nested access with dot notation.\"\"\"\n    return reduce(lambda obj, k: obj[k], key.split(\".\"), self._dict)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.simulation.dict.Parameters.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.dict.Parameters[bamboost.core.hdf5.file.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Parameters[Mutable], key: str, value: Any) -> None:\n    active_dict = reduce(lambda obj, k: obj[k], key.split(\".\")[:-1], self._dict)\n    active_dict[key.split(\".\")[-1]] = value\n\n    def _write_item():\n        # because values can be stored as datasets or attributes, we need\n        # to check if the key already exists and remove it before writing\n        # the new value -> to avoid duplicates\n        try:\n            del self._obj.attrs[key]  # remove existing attribute\n        except KeyError:\n            pass\n        try:\n            del self._obj[key]  # remove existing dataset\n        except KeyError:\n            pass\n\n        if isinstance(value, np.ndarray):  # write arrays as datasets\n            self._obj.create_dataset(key, data=value)\n        else:  # any other type as attribute\n            self._obj.attrs[key] = value\n\n    self.post_write_instruction(_write_item)\n\n    # also send the updated parameter to the SQL database\n    self._simulation.update_database(parameters={key: value})"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.simulation.dict.Parameters.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the parameters dictionary. This method pushes the update to\nthe HDF5 file, and the SQL database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.dict.Parameters[bamboost.core.hdf5.file.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "typing.Mapping",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new parameters"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: Parameters[Mutable], update_dict: Mapping) -> None:\n    \"\"\"Update the parameters dictionary. This method pushes the update to\n    the HDF5 file, and the SQL database.\n\n    Args:\n        update_dict: new parameters\n    \"\"\"\n    # flatten dictionary\n    flattened_dict = utilities.flatten_dict(update_dict)\n\n    # update dictionary in memory\n    self._dict.update(update_dict)\n\n    # try update the sql database\n    self._simulation.update_database(parameters=update_dict)\n\n    # Filter out numpy arrays\n    arrays = {}\n    attributes = {}\n    for k, v in flattened_dict.items():\n        if isinstance(v, np.ndarray):\n            arrays[k] = flattened_dict.get(k)\n        else:\n            attributes[k] = flattened_dict.get(k)\n\n    with self._file.open(FileMode.APPEND):\n        # write arrays as datasets\n        for k, v in arrays.items():\n            if k in self._obj:\n                del self._obj[k]\n            self._obj.create_dataset(k, data=v)\n\n        # write the rest\n        self.post_write_instruction(\n            lambda: self._obj.attrs.update(AttrsEncoder.encode(attributes))\n        )"
                    }
                  },
                  "source": "class Parameters(AttrsDict[_MT]):\n    _simulation: _Simulation\n    _dict: SimulationParameterT\n\n    def __init__(self, simulation: _Simulation[_MT]):\n        super().__init__(simulation._file, constants.PATH_PARAMETERS)\n        self._simulation = simulation\n\n    @property\n    def _obj(self) -> h5py.Group:\n        obj = self._file[self._path]\n        assert isinstance(obj, h5py.Group), f\"Expected a group, got {type(obj)}\"\n        return obj\n\n    @with_file_open(FileMode.READ)\n    def read(self) -> dict:\n        \"\"\"Read the parameters from the HDF5 file.\n\n        In addition to the attributes from the group, this method also reads in\n        all datasets in the group.\n        \"\"\"\n        tmp_dict = dict()\n\n        try:\n            grp = cast(h5py.Group, self._file[self._path])\n        except KeyError:\n            raise KeyError(\n                f\"Group {self._path} not found in file {self._file._filename}.\"\n            )\n\n        # Read in attributes\n        tmp_dict.update(AttrsEncoder.decode(grp.attrs))\n\n        # Read in datasets\n        for key, value in grp.items():\n            if not isinstance(value, h5py.Dataset):\n                continue\n            tmp_dict.update({key: value[()]})\n\n        return utilities.unflatten_dict(tmp_dict)\n\n    def _ipython_key_completions_(self) -> Generator[str, None, None]:\n        for key, obj in self._dict.items():\n            yield key\n            if isinstance(obj, dict):\n                for subkey in obj.keys():\n                    yield f\"{key}.{subkey}\"\n\n    def __getitem__(self, key: str) -> Any:\n        \"\"\"Get a parameter. Can use nested access with dot notation.\"\"\"\n        return reduce(lambda obj, k: obj[k], key.split(\".\"), self._dict)\n\n    @mutable_only\n    def __setitem__(self: Parameters[Mutable], key: str, value: Any) -> None:\n        active_dict = reduce(lambda obj, k: obj[k], key.split(\".\")[:-1], self._dict)\n        active_dict[key.split(\".\")[-1]] = value\n\n        def _write_item():\n            # because values can be stored as datasets or attributes, we need\n            # to check if the key already exists and remove it before writing\n            # the new value -> to avoid duplicates\n            try:\n                del self._obj.attrs[key]  # remove existing attribute\n            except KeyError:\n                pass\n            try:\n                del self._obj[key]  # remove existing dataset\n            except KeyError:\n                pass\n\n            if isinstance(value, np.ndarray):  # write arrays as datasets\n                self._obj.create_dataset(key, data=value)\n            else:  # any other type as attribute\n                self._obj.attrs[key] = value\n\n        self.post_write_instruction(_write_item)\n\n        # also send the updated parameter to the SQL database\n        self._simulation.update_database(parameters={key: value})\n\n    @mutable_only\n    def update(self: Parameters[Mutable], update_dict: Mapping) -> None:\n        \"\"\"Update the parameters dictionary. This method pushes the update to\n        the HDF5 file, and the SQL database.\n\n        Args:\n            update_dict: new parameters\n        \"\"\"\n        # flatten dictionary\n        flattened_dict = utilities.flatten_dict(update_dict)\n\n        # update dictionary in memory\n        self._dict.update(update_dict)\n\n        # try update the sql database\n        self._simulation.update_database(parameters=update_dict)\n\n        # Filter out numpy arrays\n        arrays = {}\n        attributes = {}\n        for k, v in flattened_dict.items():\n            if isinstance(v, np.ndarray):\n                arrays[k] = flattened_dict.get(k)\n            else:\n                attributes[k] = flattened_dict.get(k)\n\n        with self._file.open(FileMode.APPEND):\n            # write arrays as datasets\n            for k, v in arrays.items():\n                if k in self._obj:\n                    del self._obj[k]\n                self._obj.create_dataset(k, data=v)\n\n            # write the rest\n            self.post_write_instruction(\n                lambda: self._obj.attrs.update(AttrsEncoder.encode(attributes))\n            )",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrsdict.AttrsDict": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__new__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.set"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__delitem__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "Links": {
                  "name": "Links",
                  "path": "bamboost.core.simulation.dict.Links",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Links.__init__",
                      "signature": "(self, simulation) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT]) -> None:\n    super().__init__(simulation._file, constants.PATH_LINKS)"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.dict.Links.__getitem__",
                      "signature": "(self, key) -> '_Simulation'",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> \"_Simulation\":\n    from bamboost.core.simulation import Simulation\n\n    return Simulation.from_uid(super().__getitem__(key))"
                    }
                  },
                  "source": "class Links(AttrsDict[_MT]):\n    def __init__(self, simulation: _Simulation[_MT]) -> None:\n        super().__init__(simulation._file, constants.PATH_LINKS)\n\n    def __getitem__(self, key: str) -> \"_Simulation\":\n        from bamboost.core.simulation import Simulation\n\n        return Simulation.from_uid(super().__getitem__(key))",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrsdict.AttrsDict": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__new__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._dict"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.read"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__setitem__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.set"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.update"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "Metadata": {
                  "name": "Metadata",
                  "path": "bamboost.core.simulation.dict.Metadata",
                  "description": "The metadata of a simulation are the attributes of the root group.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "the simulation object"
                        }
                      ]
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation",
                      "description": null,
                      "value": "bamboost.core.simulation.dict.Metadata(simulation)"
                    }
                  ],
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "special-metadata-that-is-handled-by-bamboost",
                        "description": "status: Status of the simulation\ncreated_at: Creation date of the simulation\ndescription: Optional description of the simulation"
                      },
                      "title": "Special metadata that is handled by bamboost"
                    }
                  ],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Metadata.__init__",
                      "signature": "(self, simulation) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "bamboost.core.simulation.base._Simulation[bamboost.core.hdf5.file._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT]) -> None:\n    super().__init__(simulation._file, \"/\")\n    self._simulation = simulation"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.simulation.dict.Metadata.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.dict.Metadata[bamboost.core.hdf5.file.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "typing.Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Metadata[Mutable], key: str, value: Any) -> None:\n    super().__setitem__(key, value)\n\n    # also send the updated parameter to the SQL database\n    self._simulation.update_database(metadata={key: value})"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.simulation.dict.Metadata.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the metadata dictionary. This method pushes the update to the\nHDF5 file, and the SQL database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.dict.Metadata[bamboost.core.hdf5.file.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "bamboost.core.simulation.dict",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new metadata"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: Metadata[Mutable], update_dict: dict) -> None:\n    \"\"\"Update the metadata dictionary. This method pushes the update to the\n    HDF5 file, and the SQL database.\n\n    Args:\n        update_dict: new metadata\n    \"\"\"\n    # update dictionary in memory and hdf5 file\n    super().update(update_dict)\n\n    # try update the sql database\n    self._simulation.update_database(metadata=update_dict)"
                    }
                  },
                  "source": "class Metadata(AttrsDict[_MT]):\n    \"\"\"The metadata of a simulation are the attributes of the root group.\n\n    Special metadata that is handled by bamboost:\n        status: Status of the simulation\n        created_at: Creation date of the simulation\n        description: Optional description of the simulation\n\n    Args:\n        simulation: the simulation object\n    \"\"\"\n\n    _simulation: _Simulation\n\n    def __init__(self, simulation: _Simulation[_MT]) -> None:\n        super().__init__(simulation._file, \"/\")\n        self._simulation = simulation\n\n    @mutable_only\n    def __setitem__(self: Metadata[Mutable], key: str, value: Any) -> None:\n        super().__setitem__(key, value)\n\n        # also send the updated parameter to the SQL database\n        self._simulation.update_database(metadata={key: value})\n\n    @mutable_only\n    def update(self: Metadata[Mutable], update_dict: dict) -> None:\n        \"\"\"Update the metadata dictionary. This method pushes the update to the\n        HDF5 file, and the SQL database.\n\n        Args:\n            update_dict: new metadata\n        \"\"\"\n        # update dictionary in memory and hdf5 file\n        super().update(update_dict)\n\n        # try update the sql database\n        self._simulation.update_database(metadata=update_dict)",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrsdict.AttrsDict": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__new__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._dict"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.read"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.set"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrsdict.AttrsDict.__delitem__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "xdmf": {
              "name": "xdmf",
              "path": "bamboost.core.simulation.xdmf",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/xdmf.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "__all__",
                  "annotation": null,
                  "description": null,
                  "value": "['XDMFWriter']"
                },
                {
                  "name": "numpy_to_xdmf_dtype",
                  "annotation": null,
                  "description": null,
                  "value": "{'int8': ('Int', '1'), 'int16': ('Int', '2'), 'int32': ('Int', '4'), 'int64': ('Int', '8'), 'uint8': ('UInt', '1'), 'uint16': ('UInt', '2'), 'uint32': ('UInt', '4'), 'uint64': ('UInt', '8'), 'float32': ('Float', '4'), 'float64': ('Float', '8')}"
                }
              ],
              "modules": {},
              "classes": {
                "XDMFWriter": {
                  "name": "XDMFWriter",
                  "path": "bamboost.core.simulation.xdmf.XDMFWriter",
                  "description": "Write xdmf file for a subset of the stored data in the H5 file.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "bamboost.core.hdf5.file.HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "Communicator()"
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.simulation.xdmf.XDMFWriter(file)"
                    },
                    {
                      "name": "root_element",
                      "annotation": null,
                      "description": null,
                      "value": "ET.Element('Xdmf', Version='3.0')"
                    },
                    {
                      "name": "domain",
                      "annotation": null,
                      "description": null,
                      "value": "ET.SubElement(self.root_element, 'Domain')"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "bamboost.core.hdf5.file.HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    self.root_element = ET.Element(\"Xdmf\", Version=\"3.0\")\n    self.domain = ET.SubElement(self.root_element, \"Domain\")\n    ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")"
                    },
                    "write_file": {
                      "name": "write_file",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.write_file",
                      "signature": "(self, filename)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "filename",
                          "annotation": "bamboost._typing.StrPath",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def write_file(self, filename: StrPath):\n    filename = Path(filename)\n    tree = ET.ElementTree(self.root_element)\n    self._pretty_print(tree.getroot())\n    tree.write(filename)"
                    },
                    "_pretty_print": {
                      "name": "_pretty_print",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._pretty_print",
                      "signature": "(self, elem, level=0)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "elem",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "level",
                          "annotation": null,
                          "description": null,
                          "value": "0"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _pretty_print(self, elem, level=0):\n    indent = \"  \"  # 4 spaces\n    if len(elem):\n        if not elem.text or not elem.text.strip():\n            elem.text = \"\\n\" + indent * (level + 1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = \"\\n\" + indent * level\n        for elem in elem:\n            self._pretty_print(elem, level + 1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = \"\\n\" + indent * level\n    else:\n        if level and (not elem.tail or not elem.tail.strip()):\n            elem.tail = \"\\n\" + indent * level"
                    },
                    "add_mesh": {
                      "name": "add_mesh",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.add_mesh",
                      "signature": "(self, mesh)",
                      "description": "Add the mesh to the xdmf tree.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh",
                          "annotation": "bamboost.core.simulation.groups.GroupMesh",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_mesh(self, mesh: \"GroupMesh\"):\n    \"\"\"Add the mesh to the xdmf tree.\n\n    Args:\n        nodes_location: String to geometry/nodes in hdf file\n        cells_location: String to topology/cells in hdf file\n    \"\"\"\n    grid = ET.SubElement(\n        self.domain, \"Grid\", Name=mesh._path.basename, GridType=\"Uniform\"\n    )\n    with self._file.open(FileMode.READ):\n        self._add_nodes(grid, mesh._path.joinpath(\"coordinates\"))\n        self._add_cells(grid, mesh._path.joinpath(\"topology\"))"
                    },
                    "_add_nodes": {
                      "name": "_add_nodes",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_nodes",
                      "signature": "(self, grid, nodes_path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "xml.etree.ElementTree.xml.etree.ElementTree.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "nodes_path",
                          "annotation": "bamboost.core.hdf5.file.HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_nodes(self, grid: ET.Element, nodes_path: HDF5Path):\n    geometry_type = \"XY\"\n\n    points = cast(h5py.Dataset, self._file[nodes_path])\n    geo = ET.SubElement(grid, \"Geometry\", GeometryType=geometry_type)\n    dtype, precission = numpy_to_xdmf_dtype[points.dtype.name]\n    dim = \"{} {}\".format(*points.shape)\n    data_item = ET.SubElement(\n        geo,\n        \"DataItem\",\n        DataType=dtype,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=precission,\n    )\n    data_item.text = f\"{self._file._path.name}:{nodes_path}\""
                    },
                    "_add_cells": {
                      "name": "_add_cells",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_cells",
                      "signature": "(self, grid, cells_path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "xml.etree.ElementTree.xml.etree.ElementTree.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "cells_path",
                          "annotation": "bamboost.core.hdf5.file.HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_cells(self, grid: ET.Element, cells_path: HDF5Path):\n    cells = cast(h5py.Dataset, self._file[cells_path])\n    nb_cells = cells.shape[0]\n    topo = ET.SubElement(\n        grid,\n        \"Topology\",\n        TopologyType=cells.attrs.get(\"cell_type\", \"Triangle\"),\n        NumberOfElements=str(nb_cells),\n    )\n    dim = \"{} {}\".format(*cells.shape)\n    dt, prec = numpy_to_xdmf_dtype[cells.dtype.name]\n    data_item = ET.SubElement(\n        topo,\n        \"DataItem\",\n        DataType=dt,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=prec,\n    )\n    data_item.text = f\"{self._file._path.name}:{cells_path}\""
                    },
                    "add_timeseries": {
                      "name": "add_timeseries",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.add_timeseries",
                      "signature": "(self, timesteps, fields, mesh_name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "timesteps",
                          "annotation": "typing.Iterable[float]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "list[bamboost.core.simulation.series.FieldData]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_timeseries(\n    self, timesteps: Iterable[float], fields: \"list[FieldData]\", mesh_name: str\n):\n    # if no timesteps, return\n    if not timesteps:\n        return\n\n    collection = ET.SubElement(\n        self.domain,\n        \"Grid\",\n        Name=\"TimeSeries\",\n        GridType=\"Collection\",\n        CollectionType=\"Temporal\",\n    )\n\n    with self._file.open(FileMode.READ):\n        for i, t in enumerate(timesteps):\n            self._add_step(i, t, fields, collection, mesh_name)"
                    },
                    "_add_step": {
                      "name": "_add_step",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_step",
                      "signature": "(self, step, time, fields, collection, mesh_name)",
                      "description": "Write the data array for time t.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "list[bamboost.core.simulation.series.FieldData]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "collection",
                          "annotation": "xml.etree.ElementTree.xml.etree.ElementTree.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_step(\n    self,\n    step: int,\n    time: float,\n    fields: \"list[FieldData]\",\n    collection: ET.Element,\n    mesh_name: str,\n):\n    \"\"\"Write the data array for time t.\n\n    Args:\n        t (float): time\n        data_location (str): String to data in h5 file\n        name (str): Name for the field in the Xdmf file\n    \"\"\"\n    # avoid time = NaN in xdmf\n    if np.isnan(time):\n        time = step\n\n    grid = ET.SubElement(collection, \"Grid\")\n    ptr = (\n        f'xpointer(//Grid[@Name=\"{mesh_name}\"]/*[self::Topology or self::Geometry])'\n    )\n\n    ET.SubElement(grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr)\n    ET.SubElement(grid, \"Time\", Value=str(time))\n\n    for field in fields:\n        self._add_attribute(grid, field, step)"
                    },
                    "_add_attribute": {
                      "name": "_add_attribute",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_attribute",
                      "signature": "(self, grid, field, step) -> None",
                      "description": "Write an attribute/field.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "xml.etree.ElementTree.xml.etree.ElementTree.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field",
                          "annotation": "bamboost.core.simulation.series.FieldData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_attribute(self, grid: ET.Element, field: \"FieldData\", step: int) -> None:\n    \"\"\"Write an attribute/field.\"\"\"\n    data = field._obj[str(step)]\n    assert isinstance(data, h5py.Dataset), \"Data is not a dataset\"\n\n    if data.ndim == 1 or data.shape[1] <= 1:\n        att_type = \"Scalar\"\n    elif data.ndim == 2:\n        att_type = \"Vector\"\n    elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n        # Square shape -> Tensor\n        att_type = \"Tensor\"\n    else:\n        att_type = \"Matrix\"\n\n    # Cell or Node data\n    data_type = FieldType(field._obj.attrs.get(\"field_type\", FieldType.NODE))\n\n    att = ET.SubElement(\n        grid,\n        \"Attribute\",\n        Name=field.name,\n        AttributeType=att_type,\n        Center=data_type.value,\n    )\n\n    dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n    dim = \" \".join([str(i) for i in data.shape])\n\n    data_item = ET.SubElement(\n        att,\n        \"DataItem\",\n        DataType=dt,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=prec,\n    )\n    data_item.text = f\"{self._file._path.name}:{field._path}/{step}\""
                    }
                  },
                  "source": "class XDMFWriter(metaclass=RootProcessMeta):\n    \"\"\"Write xdmf file for a subset of the stored data in the H5 file.\n\n    Args:\n        filename (str): xdmf file path\n        h5file (str): h5 file path\n    \"\"\"\n\n    _comm = Communicator()\n\n    def __init__(self, file: HDF5File):\n        self._file = file\n        self.root_element = ET.Element(\"Xdmf\", Version=\"3.0\")\n        self.domain = ET.SubElement(self.root_element, \"Domain\")\n        ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")\n\n    def write_file(self, filename: StrPath):\n        filename = Path(filename)\n        tree = ET.ElementTree(self.root_element)\n        self._pretty_print(tree.getroot())\n        tree.write(filename)\n\n    def _pretty_print(self, elem, level=0):\n        indent = \"  \"  # 4 spaces\n        if len(elem):\n            if not elem.text or not elem.text.strip():\n                elem.text = \"\\n\" + indent * (level + 1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = \"\\n\" + indent * level\n            for elem in elem:\n                self._pretty_print(elem, level + 1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = \"\\n\" + indent * level\n        else:\n            if level and (not elem.tail or not elem.tail.strip()):\n                elem.tail = \"\\n\" + indent * level\n\n    def add_mesh(self, mesh: \"GroupMesh\"):\n        \"\"\"Add the mesh to the xdmf tree.\n\n        Args:\n            nodes_location: String to geometry/nodes in hdf file\n            cells_location: String to topology/cells in hdf file\n        \"\"\"\n        grid = ET.SubElement(\n            self.domain, \"Grid\", Name=mesh._path.basename, GridType=\"Uniform\"\n        )\n        with self._file.open(FileMode.READ):\n            self._add_nodes(grid, mesh._path.joinpath(\"coordinates\"))\n            self._add_cells(grid, mesh._path.joinpath(\"topology\"))\n\n    def _add_nodes(self, grid: ET.Element, nodes_path: HDF5Path):\n        geometry_type = \"XY\"\n\n        points = cast(h5py.Dataset, self._file[nodes_path])\n        geo = ET.SubElement(grid, \"Geometry\", GeometryType=geometry_type)\n        dtype, precission = numpy_to_xdmf_dtype[points.dtype.name]\n        dim = \"{} {}\".format(*points.shape)\n        data_item = ET.SubElement(\n            geo,\n            \"DataItem\",\n            DataType=dtype,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=precission,\n        )\n        data_item.text = f\"{self._file._path.name}:{nodes_path}\"\n\n    def _add_cells(self, grid: ET.Element, cells_path: HDF5Path):\n        cells = cast(h5py.Dataset, self._file[cells_path])\n        nb_cells = cells.shape[0]\n        topo = ET.SubElement(\n            grid,\n            \"Topology\",\n            TopologyType=cells.attrs.get(\"cell_type\", \"Triangle\"),\n            NumberOfElements=str(nb_cells),\n        )\n        dim = \"{} {}\".format(*cells.shape)\n        dt, prec = numpy_to_xdmf_dtype[cells.dtype.name]\n        data_item = ET.SubElement(\n            topo,\n            \"DataItem\",\n            DataType=dt,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=prec,\n        )\n        data_item.text = f\"{self._file._path.name}:{cells_path}\"\n\n    def add_timeseries(\n        self, timesteps: Iterable[float], fields: \"list[FieldData]\", mesh_name: str\n    ):\n        # if no timesteps, return\n        if not timesteps:\n            return\n\n        collection = ET.SubElement(\n            self.domain,\n            \"Grid\",\n            Name=\"TimeSeries\",\n            GridType=\"Collection\",\n            CollectionType=\"Temporal\",\n        )\n\n        with self._file.open(FileMode.READ):\n            for i, t in enumerate(timesteps):\n                self._add_step(i, t, fields, collection, mesh_name)\n\n    def _add_step(\n        self,\n        step: int,\n        time: float,\n        fields: \"list[FieldData]\",\n        collection: ET.Element,\n        mesh_name: str,\n    ):\n        \"\"\"Write the data array for time t.\n\n        Args:\n            t (float): time\n            data_location (str): String to data in h5 file\n            name (str): Name for the field in the Xdmf file\n        \"\"\"\n        # avoid time = NaN in xdmf\n        if np.isnan(time):\n            time = step\n\n        grid = ET.SubElement(collection, \"Grid\")\n        ptr = (\n            f'xpointer(//Grid[@Name=\"{mesh_name}\"]/*[self::Topology or self::Geometry])'\n        )\n\n        ET.SubElement(grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr)\n        ET.SubElement(grid, \"Time\", Value=str(time))\n\n        for field in fields:\n            self._add_attribute(grid, field, step)\n\n    def _add_attribute(self, grid: ET.Element, field: \"FieldData\", step: int) -> None:\n        \"\"\"Write an attribute/field.\"\"\"\n        data = field._obj[str(step)]\n        assert isinstance(data, h5py.Dataset), \"Data is not a dataset\"\n\n        if data.ndim == 1 or data.shape[1] <= 1:\n            att_type = \"Scalar\"\n        elif data.ndim == 2:\n            att_type = \"Vector\"\n        elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n            # Square shape -> Tensor\n            att_type = \"Tensor\"\n        else:\n            att_type = \"Matrix\"\n\n        # Cell or Node data\n        data_type = FieldType(field._obj.attrs.get(\"field_type\", FieldType.NODE))\n\n        att = ET.SubElement(\n            grid,\n            \"Attribute\",\n            Name=field.name,\n            AttributeType=att_type,\n            Center=data_type.value,\n        )\n\n        dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n        dim = \" \".join([str(i) for i in data.shape])\n\n        data_item = ET.SubElement(\n            att,\n            \"DataItem\",\n            DataType=dt,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=prec,\n        )\n        data_item.text = f\"{self._file._path.name}:{field._path}/{step}\"",
                  "inherited_members": {}
                }
              },
              "functions": {}
            },
            "series": {
              "name": "series",
              "path": "bamboost.core.simulation.series",
              "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/core/simulation/series.py",
              "description": "Module for handling time series data in HDF5 files. The notion of time is used to\ndescribe Series, but it can be used for any data that changes with a single parameter.\n\nThe default time series is stored at `/data` in the HDF5 file. You can create additional\nseries' with `bamboost.core.simulation.base.Simulation.create_series`.\n\nThis module provides classes for managing time series data stored in HDF5 files:\n- Series: Main class for managing a series, including fields and global values\n- FieldData: Handles a particular field (e.g., nodal or element data) and its timesteps\n- GlobalData: Manages the global data that varies with time. This refers to data that is\n  not tied to a mesh.\n- StepWriter: Helper class for writing data at specific timesteps\n\nThe data is organized hierarchically in the HDF5 file with separate sections for\nfield data and global/scalar data. Fields typically represent spatial data like\ndisplacements or stresses, while globals are used for scalar quantities like\nenergy or convergence metrics.",
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild(__name__)"
                }
              ],
              "modules": {},
              "classes": {
                "NotASeriesError": {
                  "name": "NotASeriesError",
                  "path": "bamboost.core.simulation.series.NotASeriesError",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.series.NotASeriesError.__init__",
                      "signature": "(self, path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path: str):\n    super().__init__(f\"Path {path} exists, but is not a Series.\")"
                    }
                  },
                  "source": "class NotASeriesError(ValueError):\n    def __init__(self, path: str):\n        super().__init__(f\"Path {path} exists, but is not a Series.\")",
                  "inherited_members": {}
                },
                "Series": {
                  "name": "Series",
                  "path": "bamboost.core.simulation.series.Series",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "bamboost.core.simulation.base._Simulation[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": "bamboost.constants.PATH_DATA"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_obj",
                      "annotation": "h5py.h5py.Group",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_field_instances",
                      "annotation": "bamboost.core.simulation.dict[str, bamboost.core.simulation.series.FieldData[bamboost._typing._MT]]",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "last_step",
                      "annotation": "typing.Union[int, None]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "globals",
                      "annotation": "bamboost.core.simulation.series.GlobalData[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "values",
                      "annotation": "numpy.numpy.ndarray",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Return the values of the series. In the default time series, this returns the\ntime values of the steps."
                        }
                      ],
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.series.Series.__init__",
                      "signature": "(self, simulation, path=PATH_DATA)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "bamboost.core.simulation.base._Simulation[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": "bamboost.constants.PATH_DATA"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT], path: str = PATH_DATA):\n    super().__init__(path, simulation._file)\n\n    # if this is not tagged a series, we raise an error\n    if not self.attrs.get(\".series\"):\n        raise NotASeriesError(path)\n    self._field_instances: dict[str, FieldData[_MT]] = {}"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.simulation.series.Series.__len__",
                      "signature": "(self) -> int",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self) -> int:\n    try:\n        return self._values().shape[0]\n    except (InvalidReferenceError, KeyError):\n        return 0"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.series.Series.__getitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key):\n    if isinstance(key, str):\n        return self.get_field(key)\n    if isinstance(key, tuple) and len(key) == 0:\n        return self.get_fields()\n    # else the key is a iterable of strings\n    return [self.get_field(k) for k in key]"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.simulation.series.Series._ipython_key_completions_",
                      "signature": "(self) -> list[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self) -> list[HDF5Path]:\n    return self.get_field_names()"
                    },
                    "_repr_html_": {
                      "name": "_repr_html_",
                      "path": "bamboost.core.simulation.series.Series._repr_html_",
                      "signature": "(self)",
                      "description": "Repr showing the content of the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef _repr_html_(self):\n    \"\"\"Repr showing the content of the group.\"\"\"\n    from jinja2 import Template\n\n    html_template = pkgutil.get_data(\n        bamboost.__name__, \"_repr/series.html\"\n    ).decode()  # type: ignore\n    icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n    template = Template(html_template)\n\n    return template.render(\n        uid=Path(self._file._filename).parent.name,\n        name=self._path,\n        icon=icon,\n        version=bamboost.__version__,\n        attrs=self.attrs,\n        globals=[(k, self.globals[k].shape) for k in self.globals.keys()],\n        fields=self.get_field_names(),\n        size=len(self),\n    )"
                    },
                    "get_field_names": {
                      "name": "get_field_names",
                      "path": "bamboost.core.simulation.series.Series.get_field_names",
                      "signature": "(self) -> list[HDF5Path]",
                      "description": "Return all the name of the fields in the series.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_field_names(self) -> list[HDF5Path]:\n    \"\"\"Return all the name of the fields in the series.\"\"\"\n    if not hasattr(self, \"__fields_group\"):\n        self.__fields_group = Group(\n            self._path.joinpath(RELATIVE_PATH_FIELD_DATA), self._file\n        )\n    return list(self.__fields_group._group_map.children())"
                    },
                    "get_field": {
                      "name": "get_field",
                      "path": "bamboost.core.simulation.series.Series.get_field",
                      "signature": "(self, name) -> FieldData[_MT]",
                      "description": "Get a field by name.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The name of the field."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_field(self, name: str) -> FieldData[_MT]:\n    \"\"\"Get a field by name.\n\n    Args:\n        name: The name of the field.\n    \"\"\"\n    if name not in self._field_instances:\n        self._field_instances[name] = FieldData(self, name)\n    return self._field_instances[name]"
                    },
                    "get_fields": {
                      "name": "get_fields",
                      "path": "bamboost.core.simulation.series.Series.get_fields",
                      "signature": "(self, *glob) -> list[FieldData[_MT]]",
                      "description": "Get multiple fields by name or glob pattern. If no arguments are given, all\nfields are returned.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "glob",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A list of glob patterns to filter the field names."
                            }
                          ],
                          "value": "()"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_fields(self, *glob: str) -> list[FieldData[_MT]]:\n    \"\"\"Get multiple fields by name or glob pattern. If no arguments are given, all\n    fields are returned.\n\n    Args:\n        glob: A list of glob patterns to filter the field names.\n    \"\"\"\n    if not glob:\n        return [self.get_field(name) for name in self.get_field_names()]\n\n    import fnmatch\n\n    matching_fields = set()\n    for g in glob:\n        matching_fields.update(fnmatch.filter(self.get_field_names(), g))\n    return [self.get_field(name) for name in matching_fields]"
                    },
                    "_values": {
                      "name": "_values",
                      "path": "bamboost.core.simulation.series.Series._values",
                      "signature": "(self) -> Dataset[_MT]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _values(self) -> Dataset[_MT]:\n    return super().__getitem__((constants.DS_NAME_TIMESTEPS, Dataset))"
                    },
                    "require_step": {
                      "name": "require_step",
                      "path": "bamboost.core.simulation.series.Series.require_step",
                      "signature": "(self, value=np.nan, step=None) -> StepWriter",
                      "description": "Create a new step in the series. If the step is not given, we append one.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "float",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The value of the step. This is typically the time value."
                            }
                          ],
                          "value": "numpy.numpy.nan"
                        },
                        {
                          "name": "step",
                          "annotation": "typing.Optional[int]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The step number. If not given, a step is appended after the last one."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef require_step(\n    self: Series[Mutable],\n    value: float = np.nan,\n    step: Optional[int] = None,\n) -> StepWriter:\n    \"\"\"Create a new step in the series. If the step is not given, we append one.\n\n    Args:\n        value: The value of the step. This is typically the time value.\n        step: The step number. If not given, a step is appended after the last one.\n    \"\"\"\n    if step is None:\n        step = self.last_step + 1 if self.last_step is not None else 0\n\n    # store the timestep if given\n    with self.suspend_immediate_write():\n        self._store_value(step, value)\n        self.last_step = step\n\n    return StepWriter(self, step)"
                    },
                    "_store_value": {
                      "name": "_store_value",
                      "path": "bamboost.core.simulation.series.Series._store_value",
                      "signature": "(self, step, time) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef _store_value(self: Series[Mutable], step: int, time: float) -> None:\n    def _write_instruction():\n        # require the dataset for the timesteps\n        dataset = self._obj.require_dataset(\n            constants.DS_NAME_TIMESTEPS,\n            shape=(step + 1,),\n            dtype=np.float64,\n            chunks=True,\n            maxshape=(None,),\n            fillvalue=np.nan,\n        )\n\n        # resize the dataset and store the time\n        new_size = max(step + 1, dataset.shape[0])\n        log.debug(f\"Resizing dataset {dataset.name} to {new_size}\")\n        dataset.resize(new_size, axis=0)\n\n        log.debug(f\"Storing timestep {time} for step {step}\")\n        dataset[step] = time\n\n    self.post_write_instruction(_write_instruction)"
                    }
                  },
                  "source": "class Series(H5Reference[_MT]):\n    _obj: h5py.Group\n\n    def __init__(self, simulation: _Simulation[_MT], path: str = PATH_DATA):\n        super().__init__(path, simulation._file)\n\n        # if this is not tagged a series, we raise an error\n        if not self.attrs.get(\".series\"):\n            raise NotASeriesError(path)\n        self._field_instances: dict[str, FieldData[_MT]] = {}\n\n    def __len__(self) -> int:\n        try:\n            return self._values().shape[0]\n        except (InvalidReferenceError, KeyError):\n            return 0\n\n    @overload\n    def __getitem__(self, key: tuple[()]) -> list[FieldData[_MT]]: ...\n    @overload\n    def __getitem__(\n        self, key: Union[list[str], tuple[str], set[str]]\n    ) -> list[FieldData[_MT]]: ...\n    @overload\n    def __getitem__(self, key: str) -> FieldData[_MT]: ...\n    def __getitem__(self, key):\n        if isinstance(key, str):\n            return self.get_field(key)\n        if isinstance(key, tuple) and len(key) == 0:\n            return self.get_fields()\n        # else the key is a iterable of strings\n        return [self.get_field(k) for k in key]\n\n    def _ipython_key_completions_(self) -> list[HDF5Path]:\n        return self.get_field_names()\n\n    @with_file_open(FileMode.READ)\n    def _repr_html_(self):\n        \"\"\"Repr showing the content of the group.\"\"\"\n        from jinja2 import Template\n\n        html_template = pkgutil.get_data(\n            bamboost.__name__, \"_repr/series.html\"\n        ).decode()  # type: ignore\n        icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n        template = Template(html_template)\n\n        return template.render(\n            uid=Path(self._file._filename).parent.name,\n            name=self._path,\n            icon=icon,\n            version=bamboost.__version__,\n            attrs=self.attrs,\n            globals=[(k, self.globals[k].shape) for k in self.globals.keys()],\n            fields=self.get_field_names(),\n            size=len(self),\n        )\n\n    @property\n    def last_step(self) -> Union[int, None]:\n        if not hasattr(self, \"_last_step\"):\n            try:\n                self._last_step = self._values().shape[0] - 1\n            except KeyError:\n                self._last_step = None\n        return self._last_step\n\n    @last_step.setter\n    def last_step(self, value: int):\n        self._last_step = value\n\n    def get_field_names(self) -> list[HDF5Path]:\n        \"\"\"Return all the name of the fields in the series.\"\"\"\n        if not hasattr(self, \"__fields_group\"):\n            self.__fields_group = Group(\n                self._path.joinpath(RELATIVE_PATH_FIELD_DATA), self._file\n            )\n        return list(self.__fields_group._group_map.children())\n\n    def get_field(self, name: str) -> FieldData[_MT]:\n        \"\"\"Get a field by name.\n\n        Args:\n            name: The name of the field.\n        \"\"\"\n        if name not in self._field_instances:\n            self._field_instances[name] = FieldData(self, name)\n        return self._field_instances[name]\n\n    def get_fields(self, *glob: str) -> list[FieldData[_MT]]:\n        \"\"\"Get multiple fields by name or glob pattern. If no arguments are given, all\n        fields are returned.\n\n        Args:\n            glob: A list of glob patterns to filter the field names.\n        \"\"\"\n        if not glob:\n            return [self.get_field(name) for name in self.get_field_names()]\n\n        import fnmatch\n\n        matching_fields = set()\n        for g in glob:\n            matching_fields.update(fnmatch.filter(self.get_field_names(), g))\n        return [self.get_field(name) for name in matching_fields]\n\n    @cached_property\n    def globals(self) -> GlobalData[_MT]:\n        return GlobalData(self)\n\n    @property\n    @with_file_open(FileMode.READ)\n    def values(self) -> np.ndarray:\n        \"\"\"Return the values of the series. In the default time series, this returns the\n        time values of the steps.\"\"\"\n        try:\n            return self._values()[:]\n        except InvalidReferenceError:\n            return np.array([])\n\n    def _values(self) -> Dataset[_MT]:\n        return super().__getitem__((constants.DS_NAME_TIMESTEPS, Dataset))\n\n    @mutable_only\n    def require_step(\n        self: Series[Mutable],\n        value: float = np.nan,\n        step: Optional[int] = None,\n    ) -> StepWriter:\n        \"\"\"Create a new step in the series. If the step is not given, we append one.\n\n        Args:\n            value: The value of the step. This is typically the time value.\n            step: The step number. If not given, a step is appended after the last one.\n        \"\"\"\n        if step is None:\n            step = self.last_step + 1 if self.last_step is not None else 0\n\n        # store the timestep if given\n        with self.suspend_immediate_write():\n            self._store_value(step, value)\n            self.last_step = step\n\n        return StepWriter(self, step)\n\n    @mutable_only\n    def _store_value(self: Series[Mutable], step: int, time: float) -> None:\n        def _write_instruction():\n            # require the dataset for the timesteps\n            dataset = self._obj.require_dataset(\n                constants.DS_NAME_TIMESTEPS,\n                shape=(step + 1,),\n                dtype=np.float64,\n                chunks=True,\n                maxshape=(None,),\n                fillvalue=np.nan,\n            )\n\n            # resize the dataset and store the time\n            new_size = max(step + 1, dataset.shape[0])\n            log.debug(f\"Resizing dataset {dataset.name} to {new_size}\")\n            dataset.resize(new_size, axis=0)\n\n            log.debug(f\"Storing timestep {time} for step {step}\")\n            dataset[step] = time\n\n        self.post_write_instruction(_write_instruction)",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference._is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "StepWriter": {
                  "name": "StepWriter",
                  "path": "bamboost.core.simulation.series.StepWriter",
                  "description": "A class to write data for a specific step in a series.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "series",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The series to which the step belongs."
                        }
                      ]
                    },
                    {
                      "name": "step",
                      "annotation": "int",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The step number."
                        }
                      ]
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_series",
                      "annotation": null,
                      "description": [
                        {
                          "kind": "text",
                          "value": "The series to which the step belongs."
                        }
                      ],
                      "value": "bamboost.core.simulation.series.StepWriter(series)"
                    },
                    {
                      "name": "_step",
                      "annotation": null,
                      "description": [
                        {
                          "kind": "text",
                          "value": "The step number."
                        }
                      ],
                      "value": "bamboost.core.simulation.series.StepWriter(step)"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.series.StepWriter.__init__",
                      "signature": "(self, series, step)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "series",
                          "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, series: Series[Mutable], step: int):\n    super().__init__(series._file)\n    self._series = series\n    \"\"\"The series to which the step belongs.\"\"\"\n    self._step = step\n    \"\"\"The step number.\"\"\""
                    },
                    "add_field": {
                      "name": "add_field",
                      "path": "bamboost.core.simulation.series.StepWriter.add_field",
                      "signature": "(self, name, data, *, mesh_name=DEFAULT_MESH_NAME, field_type=FieldType.NODE) -> None",
                      "description": "Add a field to the step.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The name of the field."
                            }
                          ]
                        },
                        {
                          "name": "data",
                          "annotation": "numpy.numpy.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The data for the field."
                            }
                          ]
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The name of the mesh to which the field belongs."
                            }
                          ],
                          "value": "bamboost.constants.DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "field_type",
                          "annotation": "bamboost.core.simulation.FieldType",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The type of the field (default: FieldType.NODE). This is only\nrelevant for XDMF writing."
                            }
                          ],
                          "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_field(\n    self,\n    name: str,\n    data: np.ndarray,\n    *,\n    mesh_name: str = DEFAULT_MESH_NAME,\n    field_type: FieldType = FieldType.NODE,\n) -> None:\n    \"\"\"Add a field to the step.\n\n    Args:\n        name: The name of the field.\n        data: The data for the field.\n        mesh_name: The name of the mesh to which the field belongs.\n        field_type: The type of the field (default: FieldType.NODE). This is only\n            relevant for XDMF writing.\n    \"\"\"\n    field = self._series.get_field(name)\n    field.require_self()\n    field.add_numerical_dataset(\n        str(self._step),\n        data,\n        file_map=True,\n        attrs={\"mesh\": mesh_name, \"type\": field_type.value},\n    )\n    log.debug(f\"Added field {name} for step {self._step}\")"
                    },
                    "add_fields": {
                      "name": "add_fields",
                      "path": "bamboost.core.simulation.series.StepWriter.add_fields",
                      "signature": "(self, fields, mesh_name=DEFAULT_MESH_NAME, field_type=FieldType.NODE) -> None",
                      "description": "Add multiple fields to the step.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "bamboost.core.simulation.dict[str, numpy.numpy.ndarray]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A dictionary of field names and their data."
                            }
                          ]
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The name of the mesh to which the fields belong."
                            }
                          ],
                          "value": "bamboost.constants.DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "field_type",
                          "annotation": "bamboost.core.simulation.FieldType",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The type of the fields (default: FieldType.NODE). This is only\nrelevant for XDMF writing."
                            }
                          ],
                          "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_fields(\n    self,\n    fields: dict[str, np.ndarray],\n    mesh_name: str = DEFAULT_MESH_NAME,\n    field_type: FieldType = FieldType.NODE,\n) -> None:\n    \"\"\"Add multiple fields to the step.\n\n    Args:\n        fields: A dictionary of field names and their data.\n        mesh_name: The name of the mesh to which the fields belong.\n        field_type: The type of the fields (default: FieldType.NODE). This is only\n            relevant for XDMF writing.\n    \"\"\"\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        for name, data in fields.items():\n            self.add_field(name, data, mesh_name=mesh_name, field_type=field_type)"
                    },
                    "add_scalar": {
                      "name": "add_scalar",
                      "path": "bamboost.core.simulation.series.StepWriter.add_scalar",
                      "signature": "(self, name, data) -> None",
                      "description": "Add a scalar to the step. Scalar data is typically a single value or a small\narray. The shape must be consistent across all steps.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The name of the scalar."
                            }
                          ]
                        },
                        {
                          "name": "data",
                          "annotation": "typing.Union[int, float, typing.Iterable]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The data for the scalar."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [
                        {
                          "kind": "raises",
                          "value": [
                            {
                              "annotation": "ValueError",
                              "description": "If the shape of the data is not consistent with the existing data."
                            }
                          ]
                        }
                      ],
                      "source": "def add_scalar(self, name: str, data: Union[int, float, Iterable]) -> None:\n    \"\"\"Add a scalar to the step. Scalar data is typically a single value or a small\n    array. The shape must be consistent across all steps.\n\n    Args:\n        name: The name of the scalar.\n        data: The data for the scalar.\n\n    Raises:\n        ValueError: If the shape of the data is not consistent with the existing data.\n    \"\"\"\n\n    @dataclass\n    class AddScalarInstruction(WriteInstruction):\n        series: Series\n        name: str\n        data_arr: np.ndarray\n        step: int\n\n        def __call__(self):\n            log.info(f\"Adding scalar {self.name} for step {self.step}\")\n            dataset = self.series.globals.require_dataset(\n                self.name,\n                shape=(1, *self.data_arr.shape),\n                dtype=float,\n                maxshape=(None, *self.data_arr.shape),\n                chunks=True,\n                fillvalue=np.nan,\n            )\n            new_size = max(self.step + 1, dataset.shape[0])\n            if new_size > dataset.shape[0]:\n                log.info(f\"Resizing dataset {dataset.name} to {new_size}\")\n            dataset.resize(new_size, axis=0)\n            dataset[self.step] = self.data_arr\n\n    self.post_write_instruction(\n        AddScalarInstruction(self._series, name, np.array(data), self._step)\n    )"
                    },
                    "add_scalars": {
                      "name": "add_scalars",
                      "path": "bamboost.core.simulation.series.StepWriter.add_scalars",
                      "signature": "(self, scalars) -> None",
                      "description": "Add multiple scalars to the step. See `add_scalar` for more information.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "scalars",
                          "annotation": "bamboost.core.simulation.dict[str, typing.Union[int, float, typing.Iterable]]",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A dictionary of scalar names and their data."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_scalars(self, scalars: dict[str, Union[int, float, Iterable]]) -> None:\n    \"\"\"Add multiple scalars to the step. See `add_scalar` for more information.\n\n    Args:\n        scalars: A dictionary of scalar names and their data.\n    \"\"\"\n    with self.suspend_immediate_write():\n        for name, data in scalars.items():\n            self.add_scalar(name, data)\n\n    self._file.single_process_queue.apply()"
                    }
                  },
                  "source": "class StepWriter(H5Object[Mutable]):\n    \"\"\"A class to write data for a specific step in a series.\n\n    Args:\n        series: The series to which the step belongs.\n        step: The step number.\n    \"\"\"\n\n    def __init__(self, series: Series[Mutable], step: int):\n        super().__init__(series._file)\n        self._series = series\n        \"\"\"The series to which the step belongs.\"\"\"\n        self._step = step\n        \"\"\"The step number.\"\"\"\n\n    def add_field(\n        self,\n        name: str,\n        data: np.ndarray,\n        *,\n        mesh_name: str = DEFAULT_MESH_NAME,\n        field_type: FieldType = FieldType.NODE,\n    ) -> None:\n        \"\"\"Add a field to the step.\n\n        Args:\n            name: The name of the field.\n            data: The data for the field.\n            mesh_name: The name of the mesh to which the field belongs.\n            field_type: The type of the field (default: FieldType.NODE). This is only\n                relevant for XDMF writing.\n        \"\"\"\n        field = self._series.get_field(name)\n        field.require_self()\n        field.add_numerical_dataset(\n            str(self._step),\n            data,\n            file_map=True,\n            attrs={\"mesh\": mesh_name, \"type\": field_type.value},\n        )\n        log.debug(f\"Added field {name} for step {self._step}\")\n\n    def add_fields(\n        self,\n        fields: dict[str, np.ndarray],\n        mesh_name: str = DEFAULT_MESH_NAME,\n        field_type: FieldType = FieldType.NODE,\n    ) -> None:\n        \"\"\"Add multiple fields to the step.\n\n        Args:\n            fields: A dictionary of field names and their data.\n            mesh_name: The name of the mesh to which the fields belong.\n            field_type: The type of the fields (default: FieldType.NODE). This is only\n                relevant for XDMF writing.\n        \"\"\"\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            for name, data in fields.items():\n                self.add_field(name, data, mesh_name=mesh_name, field_type=field_type)\n\n    def add_scalar(self, name: str, data: Union[int, float, Iterable]) -> None:\n        \"\"\"Add a scalar to the step. Scalar data is typically a single value or a small\n        array. The shape must be consistent across all steps.\n\n        Args:\n            name: The name of the scalar.\n            data: The data for the scalar.\n\n        Raises:\n            ValueError: If the shape of the data is not consistent with the existing data.\n        \"\"\"\n\n        @dataclass\n        class AddScalarInstruction(WriteInstruction):\n            series: Series\n            name: str\n            data_arr: np.ndarray\n            step: int\n\n            def __call__(self):\n                log.info(f\"Adding scalar {self.name} for step {self.step}\")\n                dataset = self.series.globals.require_dataset(\n                    self.name,\n                    shape=(1, *self.data_arr.shape),\n                    dtype=float,\n                    maxshape=(None, *self.data_arr.shape),\n                    chunks=True,\n                    fillvalue=np.nan,\n                )\n                new_size = max(self.step + 1, dataset.shape[0])\n                if new_size > dataset.shape[0]:\n                    log.info(f\"Resizing dataset {dataset.name} to {new_size}\")\n                dataset.resize(new_size, axis=0)\n                dataset[self.step] = self.data_arr\n\n        self.post_write_instruction(\n            AddScalarInstruction(self._series, name, np.array(data), self._step)\n        )\n\n    def add_scalars(self, scalars: dict[str, Union[int, float, Iterable]]) -> None:\n        \"\"\"Add multiple scalars to the step. See `add_scalar` for more information.\n\n        Args:\n            scalars: A dictionary of scalar names and their data.\n        \"\"\"\n        with self.suspend_immediate_write():\n            for name, data in scalars.items():\n                self.add_scalar(name, data)\n\n        self._file.single_process_queue.apply()",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ]
                  }
                },
                "FieldData": {
                  "name": "FieldData",
                  "path": "bamboost.core.simulation.series.FieldData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "series",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_parent",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                      "description": null,
                      "value": "bamboost.core.simulation.series.FieldData(series)"
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": "bamboost.core.simulation.series.FieldData(name)"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.series.FieldData.__init__",
                      "signature": "(self, series, name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "series",
                          "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, series: Series[_MT], name: str):\n    super().__init__(\n        series._path.joinpath(RELATIVE_PATH_FIELD_DATA, name), series._file\n    )\n    self._parent = series\n    self.name = name"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.series.FieldData.__getitem__",
                      "signature": "(self, key) -> np.ndarray",
                      "description": "Get data of the field for a specific step or steps using standard slice\nnotation. First index is the step number.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "typing.Union[int, slice, tuple[slice | int, ...]]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(\n    self, key: Union[int, slice, tuple[slice | int, ...]]\n) -> np.ndarray:\n    \"\"\"Get data of the field for a specific step or steps using standard slice\n    notation. First index is the step number.\n    \"\"\"\n    if isinstance(key, Iterable):\n        step = key[0]\n        rest = key[1:]\n    else:\n        step = key\n        rest = ()\n\n    with self._file.open(FileMode.READ):\n        if isinstance(step, int):\n            step_positive = self._handle_negative_index(step)\n            try:\n                return self._obj[str(step_positive)][rest]  # type: ignore\n            except KeyError:\n                raise IndexError(\n                    f\"Index ({step_positive}) out of range for (0-{self._parent.last_step})\"\n                )\n        else:\n            try:\n                return np.array(\n                    [self._obj[i][rest] for i in self._slice_step(step)]  # pyright: ignore[reportIndexIssue]\n                )\n            except ValueError:  # The data has an inhomogeneous shape (different shape at different steps)\n                return np.array(\n                    [self._obj[i][rest] for i in self._slice_step(step)],  # pyright: ignore[reportIndexIssue]\n                    dtype=object,\n                )"
                    },
                    "at": {
                      "name": "at",
                      "path": "bamboost.core.simulation.series.FieldData.at",
                      "signature": "(self, step) -> Dataset[_MT]",
                      "description": "Get the dataset for a specific step without reading the data itself.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The step number."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def at(self, step: int) -> Dataset[_MT]:\n    \"\"\"Get the dataset for a specific step without reading the data itself.\n\n    Args:\n        step: The step number.\n    \"\"\"\n    step_positive = self._handle_negative_index(step)\n    try:\n        return self.new(\n            self._path.joinpath(str(step_positive)), self._file, Dataset\n        )\n    except KeyError:\n        raise IndexError(\n            f\"Index ({step_positive}) out of range for (0-{self._parent.last_step})\"\n        )"
                    },
                    "_handle_negative_index": {
                      "name": "_handle_negative_index",
                      "path": "bamboost.core.simulation.series.FieldData._handle_negative_index",
                      "signature": "(self, index) -> int",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "index",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _handle_negative_index(self, index: int) -> int:\n    if index < 0:\n        return (self._parent.last_step or 0) + index + 1\n    return index"
                    },
                    "_slice_step": {
                      "name": "_slice_step",
                      "path": "bamboost.core.simulation.series.FieldData._slice_step",
                      "signature": "(self, step) -> list[str]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "slice",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _slice_step(self, step: slice) -> list[str]:\n    indices = [\n        str(i) for i in range(*step.indices((self._parent.last_step or 0) + 1))\n    ]\n    return indices"
                    }
                  },
                  "source": "class FieldData(Group[_MT]):\n    _parent: Series[_MT]\n    name: str\n\n    def __init__(self, series: Series[_MT], name: str):\n        super().__init__(\n            series._path.joinpath(RELATIVE_PATH_FIELD_DATA, name), series._file\n        )\n        self._parent = series\n        self.name = name\n\n    def __getitem__(\n        self, key: Union[int, slice, tuple[slice | int, ...]]\n    ) -> np.ndarray:\n        \"\"\"Get data of the field for a specific step or steps using standard slice\n        notation. First index is the step number.\n        \"\"\"\n        if isinstance(key, Iterable):\n            step = key[0]\n            rest = key[1:]\n        else:\n            step = key\n            rest = ()\n\n        with self._file.open(FileMode.READ):\n            if isinstance(step, int):\n                step_positive = self._handle_negative_index(step)\n                try:\n                    return self._obj[str(step_positive)][rest]  # type: ignore\n                except KeyError:\n                    raise IndexError(\n                        f\"Index ({step_positive}) out of range for (0-{self._parent.last_step})\"\n                    )\n            else:\n                try:\n                    return np.array(\n                        [self._obj[i][rest] for i in self._slice_step(step)]  # pyright: ignore[reportIndexIssue]\n                    )\n                except ValueError:  # The data has an inhomogeneous shape (different shape at different steps)\n                    return np.array(\n                        [self._obj[i][rest] for i in self._slice_step(step)],  # pyright: ignore[reportIndexIssue]\n                        dtype=object,\n                    )\n\n    def at(self, step: int) -> Dataset[_MT]:\n        \"\"\"Get the dataset for a specific step without reading the data itself.\n\n        Args:\n            step: The step number.\n        \"\"\"\n        step_positive = self._handle_negative_index(step)\n        try:\n            return self.new(\n                self._path.joinpath(str(step_positive)), self._file, Dataset\n            )\n        except KeyError:\n            raise IndexError(\n                f\"Index ({step_positive}) out of range for (0-{self._parent.last_step})\"\n            )\n\n    def _handle_negative_index(self, index: int) -> int:\n        if index < 0:\n            return (self._parent.last_step or 0) + index + 1\n        return index\n\n    def _slice_step(self, step: slice) -> list[str]:\n        indices = [\n            str(i) for i in range(*step.indices((self._parent.last_step or 0) + 1))\n        ]\n        return indices",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._is_valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__contains__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GlobalData": {
                  "name": "GlobalData",
                  "path": "bamboost.core.simulation.series.GlobalData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "series",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_series",
                      "annotation": null,
                      "description": null,
                      "value": "bamboost.core.simulation.series.GlobalData(series)"
                    },
                    {
                      "name": "df",
                      "annotation": "pandas.pandas.DataFrame",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.series.GlobalData.__init__",
                      "signature": "(self, series)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "series",
                          "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, series: Series[_MT]):\n    super().__init__(series._path.joinpath(RELATIVE_PATH_SCALAR_DATA), series._file)\n    self._series = series"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.series.GlobalData.__getitem__",
                      "signature": "(self, key) -> Dataset[_MT]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Dataset[_MT]:\n    return super().__getitem__((key, Dataset[_MT]))"
                    },
                    "get": {
                      "name": "get",
                      "path": "bamboost.core.simulation.series.GlobalData.get",
                      "signature": "(self, *glob) -> tuple[tuple[np.ndarray, ...], tuple[str, ...]]",
                      "description": "Get the data for many scalars by name or glob pattern. If no arguments are\ngiven, all scalars are read and returned.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "glob",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A list of glob patterns to filter the scalar names."
                            }
                          ],
                          "value": "()"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get(self, *glob: str) -> tuple[tuple[np.ndarray, ...], tuple[str, ...]]:\n    \"\"\"Get the data for many scalars by name or glob pattern. If no arguments are\n    given, all scalars are read and returned.\n\n    Args:\n        glob: A list of glob patterns to filter the scalar names.\n    \"\"\"\n    if not glob:\n        dataset_names = self.datasets()\n        return tuple(self.__getitem__(name).array for name in dataset_names), tuple(\n            map(str, dataset_names)\n        )\n\n    import fnmatch\n\n    matching_datasets = set()\n    for g in glob:\n        matching_datasets.update(fnmatch.filter(self.datasets(), g))\n    matching_datasets = tuple(matching_datasets)\n    return tuple(\n        self.__getitem__(name).array for name in matching_datasets\n    ), matching_datasets"
                    }
                  },
                  "source": "class GlobalData(Group[_MT]):\n    def __init__(self, series: Series[_MT]):\n        super().__init__(series._path.joinpath(RELATIVE_PATH_SCALAR_DATA), series._file)\n        self._series = series\n\n    def __getitem__(self, key: str) -> Dataset[_MT]:\n        return super().__getitem__((key, Dataset[_MT]))\n\n    @property\n    def df(self) -> pd.DataFrame:\n        from pandas import DataFrame\n\n        return DataFrame(\n            {\"values\": self._series.values} | {k: list(v[:]) for k, v in self.items()}\n        )\n\n    def get(self, *glob: str) -> tuple[tuple[np.ndarray, ...], tuple[str, ...]]:\n        \"\"\"Get the data for many scalars by name or glob pattern. If no arguments are\n        given, all scalars are read and returned.\n\n        Args:\n            glob: A list of glob patterns to filter the scalar names.\n        \"\"\"\n        if not glob:\n            dataset_names = self.datasets()\n            return tuple(self.__getitem__(name).array for name in dataset_names), tuple(\n                map(str, dataset_names)\n            )\n\n        import fnmatch\n\n        matching_datasets = set()\n        for g in glob:\n            matching_datasets.update(fnmatch.filter(self.datasets(), g))\n        matching_datasets = tuple(matching_datasets)\n        return tuple(\n            self.__getitem__(name).array for name in matching_datasets\n        ), matching_datasets",
                  "inherited_members": {
                    "bamboost.plugins.ElligibleForPlugin": [
                      {
                        "kind": "function",
                        "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                      }
                    ],
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      }
                    ],
                    "bamboost.core.hdf5.file.H5Object": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.file.H5Object.mutable"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._status"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._is_valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__contains__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            }
          },
          "classes": {
            "FieldType": {
              "name": "FieldType",
              "path": "bamboost.core.simulation.FieldType",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "NODE",
                  "annotation": null,
                  "description": null,
                  "value": "'Node'"
                },
                {
                  "name": "ELEMENT",
                  "annotation": null,
                  "description": null,
                  "value": "'Cell'"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class FieldType(Enum):\n    NODE = \"Node\"\n    ELEMENT = \"Cell\"",
              "inherited_members": {}
            },
            "CellType": {
              "name": "CellType",
              "path": "bamboost.core.simulation.CellType",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "VERTEX",
                  "annotation": null,
                  "description": null,
                  "value": "'Vertex'"
                },
                {
                  "name": "LINE",
                  "annotation": null,
                  "description": null,
                  "value": "'Line'"
                },
                {
                  "name": "TRIANGLE",
                  "annotation": null,
                  "description": null,
                  "value": "'Triangle'"
                },
                {
                  "name": "QUAD",
                  "annotation": null,
                  "description": null,
                  "value": "'Quadrilateral'"
                },
                {
                  "name": "TETRAHEDRON",
                  "annotation": null,
                  "description": null,
                  "value": "'Tetrahedron'"
                },
                {
                  "name": "HEXAHEDRON",
                  "annotation": null,
                  "description": null,
                  "value": "'Hexahedron'"
                },
                {
                  "name": "WEDGE",
                  "annotation": null,
                  "description": null,
                  "value": "'Wedge'"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class CellType(Enum):\n    # 2D types\n    VERTEX = \"Vertex\"\n    LINE = \"Line\"\n    TRIANGLE = \"Triangle\"\n    QUAD = \"Quadrilateral\"\n\n    # 3D types\n    TETRAHEDRON = \"Tetrahedron\"\n    HEXAHEDRON = \"Hexahedron\"\n    WEDGE = \"Wedge\"",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "mpi": {
      "name": "mpi",
      "path": "bamboost.mpi",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/mpi/__init__.py",
      "description": "This module handles the detection and selection of the appropriate MPI implementation for\nBamboost, either using `mpi4py` for real MPI environments or falling back to a mock MPI\nimplementation for non-MPI environments.\n\nThe detection logic considers user configuration options, environment variables, and the\npresence of common MPI-related environment variables.\n\nIf `mpi4py` is unavailable in an MPI environment, a fallback to the mock implementation is\nalso provided.",
      "docstring": [
        {
          "kind": "admonition",
          "value": {
            "annotation": "usage",
            "description": "Instead of importing `mpi4py.MPI` directly, import `bamboost.mpi.MPI` to use the\nappropriate MPI module based on the current environment.\n\n>>> from bamboost.mpi import MPI"
          },
          "title": "Usage"
        },
        {
          "kind": "admonition",
          "value": {
            "annotation": "type-aliases",
            "description": "Comm: Union of real and mock MPI communicators, available under TYPE_CHECKING."
          },
          "title": "Type Aliases"
        }
      ],
      "attributes": [
        {
          "name": "Comm",
          "annotation": "typing_extensions.TypeAlias",
          "description": null,
          "value": "typing.Union[mpi4py.MPI.Comm, bamboost.mpi.mock.Comm]"
        },
        {
          "name": "log",
          "description": [
            {
              "kind": "text",
              "value": "Logger instance for this module."
            }
          ],
          "annotation": "Logger",
          "value": "BAMBOOST_LOGGER.getChild(__name__.split('.')[-1])"
        },
        {
          "name": "MPI_ON",
          "description": [
            {
              "kind": "text",
              "value": "Flag indicating whether MPI is detected and enabled."
            }
          ],
          "annotation": "bool",
          "value": "_detect_if_mpi_needed()"
        },
        {
          "name": "MPI",
          "description": [
            {
              "kind": "text",
              "value": "The selected MPI module (`mpi4py.MPI` or `bamboost.mpi.mock`)."
            }
          ],
          "annotation": "module",
          "value": "_get_mpi_module()"
        }
      ],
      "modules": {
        "mock": {
          "name": "mock",
          "path": "bamboost.mpi.mock",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/mpi/mock.py",
          "description": "Mock module for `mpi4py.MPI` to be used when MPI is not available or usage not desired.\nNot importing MPI increases launch speed significantly, which is important for CLI\napplications.",
          "docstring": [],
          "attributes": [
            {
              "name": "SUM",
              "annotation": null,
              "description": null,
              "value": "lambda a, b: a + b"
            },
            {
              "name": "COMM_WORLD",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_WORLD`"
                }
              ],
              "annotation": "bamboost.mpi.mock.Comm",
              "value": "Comm()"
            },
            {
              "name": "COMM_SELF",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_SELF`"
                }
              ],
              "annotation": "bamboost.mpi.mock.Comm",
              "value": "bamboost.mpi.mock.COMM_WORLD"
            },
            {
              "name": "COMM_NULL",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_NULL`"
                }
              ],
              "annotation": "bamboost.mpi.mock.Comm",
              "value": "bamboost.mpi.mock.COMM_WORLD"
            }
          ],
          "modules": {},
          "classes": {
            "Comm": {
              "name": "Comm",
              "path": "bamboost.mpi.mock.Comm",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "size",
                  "annotation": null,
                  "description": null,
                  "value": "1"
                },
                {
                  "name": "rank",
                  "annotation": null,
                  "description": null,
                  "value": "0"
                },
                {
                  "name": "comm",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "is_mpi",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "is_master",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.mpi.mock.Comm.__init__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self):\n    self.size = 1\n    self.rank = 0\n    self.comm = None\n    self.is_mpi = False\n    self.is_master = True"
                },
                "barrier": {
                  "name": "barrier",
                  "path": "bamboost.mpi.mock.Comm.barrier",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def barrier(self):\n    pass"
                },
                "finalize": {
                  "name": "finalize",
                  "path": "bamboost.mpi.mock.Comm.finalize",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def finalize(self):\n    pass"
                },
                "bcast": {
                  "name": "bcast",
                  "path": "bamboost.mpi.mock.Comm.bcast",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def bcast(self, data, root=0):\n    return data"
                },
                "scatter": {
                  "name": "scatter",
                  "path": "bamboost.mpi.mock.Comm.scatter",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def scatter(self, data, root=0):\n    return data"
                },
                "gather": {
                  "name": "gather",
                  "path": "bamboost.mpi.mock.Comm.gather",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def gather(self, data, root=0):\n    return data"
                },
                "allgather": {
                  "name": "allgather",
                  "path": "bamboost.mpi.mock.Comm.allgather",
                  "signature": "(self, data)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def allgather(self, data):\n    return [data]"
                },
                "allreduce": {
                  "name": "allreduce",
                  "path": "bamboost.mpi.mock.Comm.allreduce",
                  "signature": "(self, data, op)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "op",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def allreduce(self, data, op):\n    return data"
                },
                "reduce": {
                  "name": "reduce",
                  "path": "bamboost.mpi.mock.Comm.reduce",
                  "signature": "(self, data, op, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "op",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def reduce(self, data, op, root=0):\n    return data"
                },
                "send": {
                  "name": "send",
                  "path": "bamboost.mpi.mock.Comm.send",
                  "signature": "(self, data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def send(self, data, dest, tag=0):\n    pass"
                },
                "recv": {
                  "name": "recv",
                  "path": "bamboost.mpi.mock.Comm.recv",
                  "signature": "(self, source, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "source",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def recv(self, source, tag=0):\n    return None"
                },
                "recv_any_source": {
                  "name": "recv_any_source",
                  "path": "bamboost.mpi.mock.Comm.recv_any_source",
                  "signature": "(self, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def recv_any_source(self, tag=0):\n    return None"
                },
                "sendrecv": {
                  "name": "sendrecv",
                  "path": "bamboost.mpi.mock.Comm.sendrecv",
                  "signature": "(self, send_data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "send_data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sendrecv(self, send_data, dest, tag=0):\n    return None"
                },
                "sendrecv_replace": {
                  "name": "sendrecv_replace",
                  "path": "bamboost.mpi.mock.Comm.sendrecv_replace",
                  "signature": "(self, data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sendrecv_replace(self, data, dest, tag=0):\n    return data"
                },
                "get_processor_name": {
                  "name": "get_processor_name",
                  "path": "bamboost.mpi.mock.Comm.get_processor_name",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_processor_name(self):\n    return \"localhost\""
                },
                "get_version": {
                  "name": "get_version",
                  "path": "bamboost.mpi.mock.Comm.get_version",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_version(self):\n    return \"0.0.0\""
                },
                "get_library_version": {
                  "name": "get_library_version",
                  "path": "bamboost.mpi.mock.Comm.get_library_version",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_library_version(self):\n    return \"0.0.0\""
                },
                "get_error_string": {
                  "name": "get_error_string",
                  "path": "bamboost.mpi.mock.Comm.get_error_string",
                  "signature": "(self, errorcode)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "errorcode",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_error_string(self, errorcode):\n    return \"No error\""
                },
                "get_exception_class": {
                  "name": "get_exception_class",
                  "path": "bamboost.mpi.mock.Comm.get_exception_class",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_exception_class(self):\n    return Exception"
                },
                "get_exception_string": {
                  "name": "get_exception_string",
                  "path": "bamboost.mpi.mock.Comm.get_exception_string",
                  "signature": "(self, errorcode)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "errorcode",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_exception_string(self, errorcode):\n    return \"No error\""
                },
                "get_count": {
                  "name": "get_count",
                  "path": "bamboost.mpi.mock.Comm.get_count",
                  "signature": "(self, status, datatype)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "datatype",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_count(self, status, datatype):\n    return 0"
                },
                "get_status": {
                  "name": "get_status",
                  "path": "bamboost.mpi.mock.Comm.get_status",
                  "signature": "(self, request)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "request",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_status(self, request):\n    return None"
                },
                "get_source": {
                  "name": "get_source",
                  "path": "bamboost.mpi.mock.Comm.get_source",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_source(self, status):\n    return 0"
                },
                "get_tag": {
                  "name": "get_tag",
                  "path": "bamboost.mpi.mock.Comm.get_tag",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_tag(self, status):\n    return 0"
                },
                "get_elements": {
                  "name": "get_elements",
                  "path": "bamboost.mpi.mock.Comm.get_elements",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_elements(self, status):\n    return 0"
                },
                "get_bytes": {
                  "name": "get_bytes",
                  "path": "bamboost.mpi.mock.Comm.get_bytes",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_bytes(self, status):\n    return 0"
                },
                "get_cancelled": {
                  "name": "get_cancelled",
                  "path": "bamboost.mpi.mock.Comm.get_cancelled",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_cancelled(self, status):\n    return False"
                },
                "get_topo": {
                  "name": "get_topo",
                  "path": "bamboost.mpi.mock.Comm.get_topo",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_topo(self):\n    return None"
                },
                "get_cart": {
                  "name": "get_cart",
                  "path": "bamboost.mpi.mock.Comm.get_cart",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_cart(self):\n    return None"
                },
                "get_dims": {
                  "name": "get_dims",
                  "path": "bamboost.mpi.mock.Comm.get_dims",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_dims(self):\n    return None"
                },
                "get_coords": {
                  "name": "get_coords",
                  "path": "bamboost.mpi.mock.Comm.get_coords",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_coords(self):\n    return None"
                },
                "get_rank": {
                  "name": "get_rank",
                  "path": "bamboost.mpi.mock.Comm.get_rank",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_rank(self):\n    return 0"
                },
                "get_size": {
                  "name": "get_size",
                  "path": "bamboost.mpi.mock.Comm.get_size",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_size(self):\n    return 1"
                },
                "Get_size": {
                  "name": "Get_size",
                  "path": "bamboost.mpi.mock.Comm.Get_size",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def Get_size(self):\n    return 1"
                }
              },
              "source": "class Comm:\n    def __init__(self):\n        self.size = 1\n        self.rank = 0\n        self.comm = None\n        self.is_mpi = False\n        self.is_master = True\n\n    def barrier(self):\n        pass\n\n    def finalize(self):\n        pass\n\n    def bcast(self, data, root=0):\n        return data\n\n    def scatter(self, data, root=0):\n        return data\n\n    def gather(self, data, root=0):\n        return data\n\n    def allgather(self, data):\n        return [data]\n\n    def allreduce(self, data, op):\n        return data\n\n    def reduce(self, data, op, root=0):\n        return data\n\n    def send(self, data, dest, tag=0):\n        pass\n\n    def recv(self, source, tag=0):\n        return None\n\n    def recv_any_source(self, tag=0):\n        return None\n\n    def sendrecv(self, send_data, dest, tag=0):\n        return None\n\n    def sendrecv_replace(self, data, dest, tag=0):\n        return data\n\n    def get_processor_name(self):\n        return \"localhost\"\n\n    def get_version(self):\n        return \"0.0.0\"\n\n    def get_library_version(self):\n        return \"0.0.0\"\n\n    def get_error_string(self, errorcode):\n        return \"No error\"\n\n    def get_exception_class(self):\n        return Exception\n\n    def get_exception_string(self, errorcode):\n        return \"No error\"\n\n    def get_count(self, status, datatype):\n        return 0\n\n    def get_status(self, request):\n        return None\n\n    def get_source(self, status):\n        return 0\n\n    def get_tag(self, status):\n        return 0\n\n    def get_elements(self, status):\n        return 0\n\n    def get_bytes(self, status):\n        return 0\n\n    def get_cancelled(self, status):\n        return False\n\n    def get_topo(self):\n        return None\n\n    def get_cart(self):\n        return None\n\n    def get_dims(self):\n        return None\n\n    def get_coords(self):\n        return None\n\n    def get_rank(self):\n        return 0\n\n    def get_size(self):\n        return 1\n\n    def Get_size(self):\n        return 1",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "utilities": {
          "name": "utilities",
          "path": "bamboost.mpi.utilities",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/mpi/utilities.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "HasComm": {
              "name": "HasComm",
              "path": "bamboost.mpi.utilities.HasComm",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "_comm",
                  "annotation": "bamboost.mpi.Comm",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class HasComm(Protocol):\n    _comm: \"Comm\"",
              "inherited_members": {}
            },
            "RootProcessMeta": {
              "name": "RootProcessMeta",
              "path": "bamboost.mpi.utilities.RootProcessMeta",
              "description": "A metaclass that makes classes MPI-safe by ensuring methods are only executed on\nthe root process. The class implementing this metaclass must have a `_comm` attribute\nthat is an MPI communicator.\n\nThis metaclass modifies class methods to either use broadcast communication\n(if decorated with @bcast) or to only execute on the root process (rank 0).",
              "parameters": [],
              "attributes": [
                {
                  "name": "__exclude__",
                  "annotation": null,
                  "description": null,
                  "value": "{'__init__', '__new__'}"
                }
              ],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.__new__",
                  "signature": "(mcs, name, bases, attrs)",
                  "description": "Create a new class with MPI-safe methods.",
                  "parameters": [
                    {
                      "name": "mcs",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The name of the class being created."
                        }
                      ]
                    },
                    {
                      "name": "bases",
                      "annotation": "tuple",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The base classes of the class being created."
                        }
                      ]
                    },
                    {
                      "name": "attrs",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The attributes of the class being created."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "type",
                    "annotation": null,
                    "description": "The new class with MPI-safe methods."
                  },
                  "docstring": [],
                  "source": "def __new__(mcs, name: str, bases: tuple, attrs: dict):\n    \"\"\"Create a new class with MPI-safe methods.\n\n    Args:\n        name: The name of the class being created.\n        bases: The base classes of the class being created.\n        attrs: The attributes of the class being created.\n\n    Returns:\n        type: The new class with MPI-safe methods.\n    \"\"\"\n    for attr_name, attr_value in attrs.items():\n        if (\n            callable(attr_value)\n            # and not attr_name.startswith(\"__\")\n            and attr_name not in mcs.__exclude__\n        ):\n            if hasattr(\n                attr_value, \"_mpi_bcast_\"\n            ):  # check for @cast_result decorator\n                continue\n            if hasattr(attr_value, \"_mpi_on_all_\"):  # check for @exclude decorator\n                continue\n            else:\n                attrs[attr_name] = mcs._root_only_default(attr_value)\n    return super().__new__(mcs, name, bases, attrs)"
                },
                "_root_only_default": {
                  "name": "_root_only_default",
                  "path": "bamboost.mpi.utilities.RootProcessMeta._root_only_default",
                  "signature": "(func)",
                  "description": "Decorator that ensures a method is only executed on the root process (rank 0).",
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": "callable",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The method to be decorated."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "callable",
                    "annotation": null,
                    "description": "The wrapped method that only executes on the root process."
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _root_only_default(func):\n    \"\"\"Decorator that ensures a method is only executed on the root process (rank 0).\n\n    Args:\n        func (callable): The method to be decorated.\n\n    Returns:\n        callable: The wrapped method that only executes on the root process.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(self: HasComm, *args, **kwargs):\n        result = None\n\n        if self._comm.rank == 0:\n            with RootProcessMeta.comm_self(self):\n                result = func(self, *args, **kwargs)\n\n        # dummy broadcast to ensure synchronization\n        self._comm.bcast(result, root=0)\n        return result\n\n    return wrapper"
                },
                "comm_self": {
                  "name": "comm_self",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.comm_self",
                  "signature": "(instance) -> Generator[None, None, None]",
                  "description": "Context manager to temporarily change the communicator to MPI.COMM_SELF.",
                  "parameters": [
                    {
                      "name": "instance",
                      "annotation": "bamboost.mpi.utilities.HasComm",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "yields",
                      "value": [
                        {
                          "name": "",
                          "annotation": "None",
                          "description": "None"
                        }
                      ]
                    }
                  ],
                  "source": "@staticmethod\n@contextmanager\ndef comm_self(instance: HasComm) -> Generator[None, None, None]:\n    \"\"\"Context manager to temporarily change the communicator to MPI.COMM_SELF.\n\n    Args:\n        comm: The MPI communicator.\n\n    Yields:\n        None\n    \"\"\"\n    prev_comm = instance._comm\n    try:\n        instance._comm = MPI.COMM_SELF\n        yield\n    finally:\n        instance._comm = prev_comm"
                },
                "bcast_result": {
                  "name": "bcast_result",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.bcast_result",
                  "signature": "(func)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef bcast_result(func):\n    @wraps(func)\n    def wrapper(self: HasComm, *args, **kwargs):\n        result = None\n\n        if self._comm.rank == 0:\n            with RootProcessMeta.comm_self(self):\n                result = func(self, *args, **kwargs)\n\n        result = self._comm.bcast(result, root=0)\n        return result\n\n    wrapper._mpi_bcast_ = True  # type: ignore\n    return wrapper"
                },
                "exclude": {
                  "name": "exclude",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.exclude",
                  "signature": "(func)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef exclude(func):\n    func._mpi_on_all_ = True\n    return func"
                }
              },
              "source": "class RootProcessMeta(type):\n    \"\"\"A metaclass that makes classes MPI-safe by ensuring methods are only executed on\n    the root process. The class implementing this metaclass must have a `_comm` attribute\n    that is an MPI communicator.\n\n    This metaclass modifies class methods to either use broadcast communication\n    (if decorated with @bcast) or to only execute on the root process (rank 0).\n    \"\"\"\n\n    __exclude__ = {\"__init__\", \"__new__\"}\n\n    def __new__(mcs, name: str, bases: tuple, attrs: dict):\n        \"\"\"Create a new class with MPI-safe methods.\n\n        Args:\n            name: The name of the class being created.\n            bases: The base classes of the class being created.\n            attrs: The attributes of the class being created.\n\n        Returns:\n            type: The new class with MPI-safe methods.\n        \"\"\"\n        for attr_name, attr_value in attrs.items():\n            if (\n                callable(attr_value)\n                # and not attr_name.startswith(\"__\")\n                and attr_name not in mcs.__exclude__\n            ):\n                if hasattr(\n                    attr_value, \"_mpi_bcast_\"\n                ):  # check for @cast_result decorator\n                    continue\n                if hasattr(attr_value, \"_mpi_on_all_\"):  # check for @exclude decorator\n                    continue\n                else:\n                    attrs[attr_name] = mcs._root_only_default(attr_value)\n        return super().__new__(mcs, name, bases, attrs)\n\n    @staticmethod\n    def _root_only_default(func):\n        \"\"\"Decorator that ensures a method is only executed on the root process (rank 0).\n\n        Args:\n            func (callable): The method to be decorated.\n\n        Returns:\n            callable: The wrapped method that only executes on the root process.\n        \"\"\"\n\n        @wraps(func)\n        def wrapper(self: HasComm, *args, **kwargs):\n            result = None\n\n            if self._comm.rank == 0:\n                with RootProcessMeta.comm_self(self):\n                    result = func(self, *args, **kwargs)\n\n            # dummy broadcast to ensure synchronization\n            self._comm.bcast(result, root=0)\n            return result\n\n        return wrapper\n\n    @staticmethod\n    @contextmanager\n    def comm_self(instance: HasComm) -> Generator[None, None, None]:\n        \"\"\"Context manager to temporarily change the communicator to MPI.COMM_SELF.\n\n        Args:\n            comm: The MPI communicator.\n\n        Yields:\n            None\n        \"\"\"\n        prev_comm = instance._comm\n        try:\n            instance._comm = MPI.COMM_SELF\n            yield\n        finally:\n            instance._comm = prev_comm\n\n    @staticmethod\n    def bcast_result(func):\n        @wraps(func)\n        def wrapper(self: HasComm, *args, **kwargs):\n            result = None\n\n            if self._comm.rank == 0:\n                with RootProcessMeta.comm_self(self):\n                    result = func(self, *args, **kwargs)\n\n            result = self._comm.bcast(result, root=0)\n            return result\n\n        wrapper._mpi_bcast_ = True  # type: ignore\n        return wrapper\n\n    @staticmethod\n    def exclude(func):\n        func._mpi_on_all_ = True\n        return func",
              "inherited_members": {}
            }
          },
          "functions": {
            "on_rank": {
              "name": "on_rank",
              "path": "bamboost.mpi.utilities.on_rank",
              "signature": "(func, comm, rank) -> Callable[_P, _T]",
              "description": "Decorator to run a function on a specific rank and broadcast the result.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "typing.Callable[bamboost._typing._P, bamboost._typing._T]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                },
                {
                  "name": "comm",
                  "annotation": "bamboost.mpi.Comm",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The MPI communicator."
                    }
                  ]
                },
                {
                  "name": "rank",
                  "annotation": "int",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The rank to run the function on."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def on_rank(func: Callable[_P, _T], comm: \"Comm\", rank: int) -> Callable[_P, _T]:\n    \"\"\"Decorator to run a function on a specific rank and broadcast the result.\n\n    Args:\n        func: The function to decorate.\n        comm: The MPI communicator.\n        rank: The rank to run the function on.\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args, **kwargs) -> _T:\n        result = None\n        if comm.rank == rank:\n            result = func(*args, **kwargs)\n        return cast(_T, comm.bcast(result, root=rank))\n\n    return inner"
            },
            "on_root": {
              "name": "on_root",
              "path": "bamboost.mpi.utilities.on_root",
              "signature": "(func, comm) -> Callable[_P, _T]",
              "description": "Decorator to run a function on the root rank and broadcast the result.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "typing.Callable[bamboost._typing._P, bamboost._typing._T]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                },
                {
                  "name": "comm",
                  "annotation": "bamboost.mpi.Comm",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The MPI communicator."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def on_root(func: Callable[_P, _T], comm: \"Comm\") -> Callable[_P, _T]:\n    \"\"\"Decorator to run a function on the root rank and broadcast the result.\n\n    Args:\n        func: The function to decorate.\n        comm: The MPI communicator.\n    \"\"\"\n    return on_rank(func, comm, 0)"
            }
          }
        }
      },
      "classes": {
        "Communicator": {
          "name": "Communicator",
          "path": "bamboost.mpi.Communicator",
          "description": null,
          "parameters": [],
          "attributes": [
            {
              "name": "_active_comm",
              "annotation": null,
              "description": null,
              "value": "bamboost.mpi.MPI.bamboost.mpi.MPI.COMM_WORLD"
            }
          ],
          "docstring": [],
          "functions": {
            "__set__": {
              "name": "__set__",
              "path": "bamboost.mpi.Communicator.__set__",
              "signature": "(self, instance, value)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __set__(self, instance, value):\n    Communicator._active_comm = value"
            },
            "__get__": {
              "name": "__get__",
              "path": "bamboost.mpi.Communicator.__get__",
              "signature": "(self, instance, owner) -> Comm",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "owner",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __get__(self, instance, owner) -> Comm:\n    return Communicator._active_comm"
            },
            "__delete__": {
              "name": "__delete__",
              "path": "bamboost.mpi.Communicator.__delete__",
              "signature": "(self, instance)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "instance",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __delete__(self, instance):\n    raise AttributeError(\"Cannot delete the communicator.\")"
            }
          },
          "source": "class Communicator:\n    _active_comm = MPI.COMM_WORLD\n\n    def __set__(self, instance, value):\n        Communicator._active_comm = value\n\n    def __get__(self, instance, owner) -> Comm:\n        return Communicator._active_comm\n\n    def __delete__(self, instance):\n        raise AttributeError(\"Cannot delete the communicator.\")",
          "inherited_members": {}
        }
      },
      "functions": {
        "_detect_if_mpi_needed": {
          "name": "_detect_if_mpi_needed",
          "path": "bamboost.mpi._detect_if_mpi_needed",
          "signature": "() -> bool",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _detect_if_mpi_needed() -> bool:\n    if not config.options.mpi:  # user has disabled MPI via config\n        return False\n    if os.environ.get(\"BAMBOOST_MPI\", None) == \"0\":  # user has disabled MPI via env\n        return False\n\n    # Check if any of the common MPI environment variables are set\n    # fmt: off\n    mpi_env_vars = {\n        \"OMPI_COMM_WORLD_SIZE\", \"OMPI_COMM_WORLD_RANK\",        # Open MPI\n        \"PMI_SIZE\", \"PMI_RANK\",                                # MPICH and Intel MPI\n        \"MV2_COMM_WORLD_SIZE\", \"MV2_COMM_WORLD_RANK\",          # MVAPICH\n        \"I_MPI_RANK\", \"I_MPI_SIZE\",                            # Intel MPI\n        \"SLURM_PROCID\", \"SLURM_NTASKS\",                        # SLURM\n        \"MPI_LOCALNRANKS\", \"MPI_LOCALRANKID\"                   # General/Other\n    }\n    # fmt: on\n    if mpi_env_vars.intersection(os.environ):\n        return True\n\n    log.info(\"This script does not seem to be run with MPI. Using the mock MPI module.\")\n    return False"
        },
        "_get_mpi_module": {
          "name": "_get_mpi_module",
          "path": "bamboost.mpi._get_mpi_module",
          "signature": "()",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_mpi_module():\n    if not MPI_ON:\n        import bamboost.mpi.mock as MockMPI\n\n        return MockMPI\n\n    try:\n        import mpi4py.MPI as MPI\n\n        return MPI\n    except ImportError:\n        import bamboost.mpi.mock as MockMPI\n\n        log.info(\"`mpi4py` unavailable [using the mock MPI module]\")\n        return MockMPI"
        }
      }
    },
    "plugins_dev": {
      "name": "plugins_dev",
      "path": "bamboost.plugins_dev",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/plugins_dev/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "fenics": {
          "name": "fenics",
          "path": "bamboost.plugins_dev.fenics",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/plugins_dev/fenics.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "__all__",
              "annotation": null,
              "description": null,
              "value": "['FenicsBamboostPlugin']"
            },
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild('bamboost_plugin_fenics')"
            }
          ],
          "modules": {},
          "classes": {
            "_T_Simulation": {
              "name": "_T_Simulation",
              "path": "bamboost.plugins_dev.fenics._T_Simulation",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent",
                  "annotation": "bamboost.utilities.StrPath",
                  "description": null,
                  "value": null
                },
                {
                  "name": "comm",
                  "annotation": "typing.Optional[bamboost.mpi.Comm]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "index",
                  "annotation": "typing.Optional[bamboost.index.Index]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "data",
                  "annotation": "bamboost.plugins_dev.fenics._T_Series",
                  "description": null,
                  "value": null
                },
                {
                  "name": "meshes",
                  "annotation": "bamboost.plugins_dev.fenics.FenicsBamboostPlugin.bamboost.plugins_dev.fenics.FenicsBamboostPlugin.FenicsMeshes",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class _T_Simulation(SimulationWriter):\n    @cached_property\n    def data(self) -> _T_Series: ...\n    @cached_property\n    def meshes(self) -> FenicsBamboostPlugin.FenicsMeshes: ...",
              "inherited_members": {
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.simulation.base.SimulationWriter": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base.SimulationWriter._file"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.__init__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.status"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.description"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.require_series"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.__enter__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.__exit__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.initialize"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter._initialize_series"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.copy_files"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.create_run_script"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.run_simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base.SimulationWriter.submit_simulation"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.base._Simulation": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.mutable"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.name"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.path"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._psize"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._prank"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._ranks"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._index"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._data_file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._bash_file"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.__eq__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.root"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation._orm"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.from_uid"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.uid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.edit"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.update_database"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.parameters"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.metadata"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.created_at"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.links"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.files"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.git"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.base._Simulation.mesh"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.enter_path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.base._Simulation.create_xdmf"
                  }
                ]
              }
            },
            "_T_Series": {
              "name": "_T_Series",
              "path": "bamboost.plugins_dev.fenics._T_Series",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "simulation",
                  "annotation": "bamboost.core.simulation.base._Simulation[bamboost._typing._MT]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "str",
                  "description": null,
                  "value": "bamboost.constants.PATH_DATA"
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "require_step": {
                  "name": "require_step",
                  "path": "bamboost.plugins_dev.fenics._T_Series.require_step",
                  "signature": "(self, value=..., step=...) -> FenicsBamboostPlugin.FenicsWriter",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": "bamboost.plugins_dev.fenics._T_Series",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "value",
                      "annotation": "float",
                      "description": null,
                      "value": "..."
                    },
                    {
                      "name": "step",
                      "annotation": "typing.Optional[int]",
                      "description": null,
                      "value": "..."
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def require_step(\n    self: _T_Series, value: float = ..., step: Optional[int] = ...\n) -> FenicsBamboostPlugin.FenicsWriter: ..."
                }
              },
              "source": "class _T_Series(Series[Mutable]):\n    def require_step(\n        self: _T_Series, value: float = ..., step: Optional[int] = ...\n    ) -> FenicsBamboostPlugin.FenicsWriter: ...",
              "inherited_members": {
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.hdf5.ref.H5Reference": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._status"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference._is_valid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.new"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object.mutable"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.series.Series": [
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.__init__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.Series._obj"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.__getitem__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.Series._field_instances"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.__len__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series._ipython_key_completions_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series._repr_html_"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.Series.last_step"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.get_field_names"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.get_field"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series.get_fields"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.Series.globals"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.Series.values"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series._values"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.Series._store_value"
                  }
                ]
              }
            },
            "WriteStrategy": {
              "name": "WriteStrategy",
              "path": "bamboost.plugins_dev.fenics.WriteStrategy",
              "description": "Enum for write style.",
              "parameters": [],
              "attributes": [
                {
                  "name": "SCATTERED",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "Scattered write style. Each process writes its own data. This is slower because the\nlocation to write to is not necessarily contiguous."
                    }
                  ],
                  "value": "0"
                },
                {
                  "name": "CONTIGUOUS",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "Contiguous write style. Data is gathered on the root process and written\ncontigously."
                    }
                  ],
                  "value": "1"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class WriteStrategy(Enum):\n    \"\"\"Enum for write style.\"\"\"\n\n    SCATTERED = 0\n    \"\"\"Scattered write style. Each process writes its own data. This is slower because the\n    location to write to is not necessarily contiguous.\"\"\"\n\n    CONTIGUOUS = 1\n    \"\"\"Contiguous write style. Data is gathered on the root process and written\n    contigously.\"\"\"",
              "inherited_members": {}
            },
            "_FenicsStepWriter": {
              "name": "_FenicsStepWriter",
              "path": "bamboost.plugins_dev.fenics._FenicsStepWriter",
              "description": "Helper writer for input from FEniCS directly.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "series",
                  "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "step",
                  "annotation": "int",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.plugins_dev.fenics._FenicsStepWriter.__init__",
                  "signature": "(self, series, step)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "series",
                      "annotation": "bamboost.core.simulation.series.Series[bamboost._typing.Mutable]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "step",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, series: Series[Mutable], step: int):\n    super().__init__(series, step)"
                },
                "add_field": {
                  "name": "add_field",
                  "path": "bamboost.plugins_dev.fenics._FenicsStepWriter.add_field",
                  "signature": "(self, name, function, *, mesh_name=DEFAULT_MESH_NAME, field_type=FieldType.NODE) -> None",
                  "description": "Add a Fenics function to the step.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The name of the field."
                        }
                      ]
                    },
                    {
                      "name": "function",
                      "annotation": "fenics.fenics.Function",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The Fenics function to add."
                        }
                      ]
                    },
                    {
                      "name": "mesh_name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "(Optional) The name of the mesh to which the field belongs. ()"
                        }
                      ],
                      "value": "bamboost.constants.DEFAULT_MESH_NAME"
                    },
                    {
                      "name": "field_type",
                      "annotation": "bamboost.core.simulation.FieldType",
                      "description": [
                        {
                          "kind": "text",
                          "value": "(Optional) The type of the field (default: FieldType.NODE). This\nis only relevant for XDMF writing."
                        }
                      ],
                      "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def add_field(\n    self,\n    name: str,\n    function: fe.Function,\n    *,\n    mesh_name: str = DEFAULT_MESH_NAME,\n    field_type: FieldType = FieldType.NODE,\n) -> None:\n    \"\"\"Add a Fenics function to the step.\n\n    Args:\n        name: The name of the field.\n        function: The Fenics function to add.\n        mesh_name: (Optional) The name of the mesh to which the field belongs. ()\n        field_type: (Optional) The type of the field (default: FieldType.NODE). This\n            is only relevant for XDMF writing.\n    \"\"\"\n    # field = self._series.get_field(name)\n    field = _FenicsFieldData(self._series, name)\n    field.require_self()\n    field.add_fenics_function(\n        str(self._step),\n        function,\n        file_map=True,\n        field_type=field_type,\n        attrs={\"mesh\": mesh_name, \"field_type\": field_type.value},\n    )\n    log.debug(f\"Added field {name} for step {self._step}\")"
                }
              },
              "source": "class _FenicsStepWriter(StepWriter, PluginComponent, replace_base=True):\n    \"\"\"\n    Helper writer for input from FEniCS directly.\n\n    Args:\n        uid: Unique identifier for the simulation\n        path: Path to database\n        comm: MPI communicator\n        create_if_not_exists: Create file if it does not exist\n        write_strategy: Write strategy for the data. Contiguous is faster but\n            requires the entire array to fit in memory of the root process.\n    \"\"\"\n\n    def __init__(self, series: Series[Mutable], step: int):\n        super().__init__(series, step)\n\n    def add_field(\n        self,\n        name: str,\n        function: fe.Function,\n        *,\n        mesh_name: str = DEFAULT_MESH_NAME,\n        field_type: FieldType = FieldType.NODE,\n    ) -> None:\n        \"\"\"Add a Fenics function to the step.\n\n        Args:\n            name: The name of the field.\n            function: The Fenics function to add.\n            mesh_name: (Optional) The name of the mesh to which the field belongs. ()\n            field_type: (Optional) The type of the field (default: FieldType.NODE). This\n                is only relevant for XDMF writing.\n        \"\"\"\n        # field = self._series.get_field(name)\n        field = _FenicsFieldData(self._series, name)\n        field.require_self()\n        field.add_fenics_function(\n            str(self._step),\n            function,\n            file_map=True,\n            field_type=field_type,\n            attrs={\"mesh\": mesh_name, \"field_type\": field_type.value},\n        )\n        log.debug(f\"Added field {name} for step {self._step}\")",
              "inherited_members": {
                "bamboost.plugins.PluginComponent": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.PluginComponent.__plugin__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.PluginComponent.__init_subclass__"
                  }
                ],
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object.mutable"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.series.StepWriter": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.StepWriter._series"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.StepWriter._step"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.StepWriter.add_fields"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.StepWriter.add_scalar"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.StepWriter.add_scalars"
                  }
                ]
              }
            },
            "_FenicsFieldData": {
              "name": "_FenicsFieldData",
              "path": "bamboost.plugins_dev.fenics._FenicsFieldData",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "series",
                  "annotation": "bamboost.core.simulation.series.Series[bamboost._typing._MT]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "add_fenics_function": {
                  "name": "add_fenics_function",
                  "path": "bamboost.plugins_dev.fenics._FenicsFieldData.add_fenics_function",
                  "signature": "(self, name, function, field_type=FieldType.NODE, attrs=None, dtype=None, *, file_map=True) -> None",
                  "description": "Add a Fenics function to the field.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "function",
                      "annotation": "fenics.fenics.Function",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "field_type",
                      "annotation": "bamboost.core.simulation.FieldType",
                      "description": null,
                      "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                    },
                    {
                      "name": "attrs",
                      "annotation": "typing.Optional[dict[str, typing.Any]]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "dtype",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "file_map",
                      "annotation": "bool",
                      "description": null,
                      "value": "True"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def add_fenics_function(\n    self,\n    name: str,\n    function: fe.Function,\n    field_type: FieldType = FieldType.NODE,\n    attrs: Optional[dict[str, Any]] = None,\n    dtype: Optional[str] = None,\n    *,\n    file_map: bool = True,\n) -> None:\n    \"\"\"Add a Fenics function to the field.\"\"\"\n    write_strategy: WriteStrategy = self.__plugin__.opts[\"write_strategy\"]\n\n    if write_strategy == WriteStrategy.CONTIGUOUS:\n        self._dump_fenics_field_on_root(\n            name, function, dtype=dtype, center=field_type\n        )\n    else:\n        self._dump_fenics_field(name, function, dtype=dtype, center=field_type)\n\n    log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n    self.attrs.update(attrs or {})\n\n    # update file_map\n    if file_map:\n        self._group_map[name] = h5py.Dataset"
                },
                "_dump_fenics_field": {
                  "name": "_dump_fenics_field",
                  "path": "bamboost.plugins_dev.fenics._FenicsFieldData._dump_fenics_field",
                  "signature": "(self, name, field, dtype=None, center=FieldType.NODE) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "field",
                      "annotation": "fenics.fenics.Function",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dtype",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "center",
                      "annotation": "bamboost.core.simulation.FieldType",
                      "description": null,
                      "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _dump_fenics_field(\n    self,\n    name: str,\n    field: fe.Function,\n    dtype: Optional[str] = None,\n    center: FieldType = FieldType.NODE,\n) -> None:\n    # get global dofs ordering and vector\n    if center == FieldType.NODE:\n        vector, global_map, global_size = self._get_global_dofs(field)\n    elif center == FieldType.ELEMENT:\n        vector, global_map, global_size = self._get_global_dofs_cell_data(field)\n    else:\n        raise ValueError(\"Invalid field type (NODE or ELEMENT).\")\n\n    dim = vector.shape[1:] if vector.ndim > 1 else None\n\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        dataset = self._obj.require_dataset(\n            name,\n            shape=(global_size, *dim) if dim else (global_size,),\n            dtype=dtype if dtype else vector.dtype,\n        )\n        dataset[global_map] = vector"
                },
                "_dump_fenics_field_on_root": {
                  "name": "_dump_fenics_field_on_root",
                  "path": "bamboost.plugins_dev.fenics._FenicsFieldData._dump_fenics_field_on_root",
                  "signature": "(self, name, field, dtype=None, center=FieldType.NODE) -> None",
                  "description": "Assembles the vector on the root process and writes it to file contiguously.\n\nThis is faster but requires the entire array to fit in memory.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "field",
                      "annotation": "fenics.fenics.Function",
                      "description": [
                        {
                          "kind": "text",
                          "value": "FEniCS function"
                        }
                      ]
                    },
                    {
                      "name": "dtype",
                      "annotation": "typing.Optional[str]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Optional. Numpy style datatype, see h5py documentation,\ndefaults to the dtype of the vector"
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "center",
                      "annotation": "bamboost.core.simulation.FieldType",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Optional. Center of the data. Can be 'Node' or 'Cell'.\nDefault is 'Node'."
                        }
                      ],
                      "value": "bamboost.core.simulation.FieldType.bamboost.core.simulation.FieldType.NODE"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _dump_fenics_field_on_root(\n    self,\n    name: str,\n    field: fe.Function,\n    dtype: Optional[str] = None,\n    center: FieldType = FieldType.NODE,\n) -> None:\n    \"\"\"Assembles the vector on the root process and writes it to file contiguously.\n\n    This is faster but requires the entire array to fit in memory.\n\n    Args:\n        location: Location in the HDF5 file\n        field: FEniCS function\n        dtype: Optional. Numpy style datatype, see h5py documentation,\n            defaults to the dtype of the vector\n        center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n            Default is 'Node'.\n    \"\"\"\n    # get global dofs ordering and vector\n    if center == FieldType.NODE:\n        vector, global_map, global_size = self._get_global_dofs(field)\n    elif center == FieldType.ELEMENT:\n        vector, global_map, global_size = self._get_global_dofs_cell_data(field)\n    else:\n        raise ValueError(\"Invalid field type (NODE or ELEMENT).\")\n\n    dim = vector.shape[1:] if vector.ndim > 1 else None\n\n    vector_p = self._file._comm.gather(vector)\n    global_map_p = self._file._comm.gather(global_map)\n\n    # On RAM, construct a contiguous vector on the root process\n    if self._file._comm.rank == 0:\n        vector_contiguous = np.zeros(\n            (global_size, *dim) if dim else (global_size,), dtype=vector.dtype\n        )\n        for map, vec in zip(global_map_p, vector_p):  # type: ignore\n            vector_contiguous[map] = vec\n\n        # Write vector to file\n        def _write_vector():\n            vec = self.require_dataset(\n                name,\n                shape=(global_size, *dim) if dim else (global_size,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            vec[:] = vector_contiguous\n\n        self.post_write_instruction(_write_vector)"
                },
                "_get_global_dofs": {
                  "name": "_get_global_dofs",
                  "path": "bamboost.plugins_dev.fenics._FenicsFieldData._get_global_dofs",
                  "signature": "(self, func) -> tuple[np.ndarray, np.ndarray, int]",
                  "description": "Get global dofs for a given function.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "func",
                      "annotation": "fenics.fenics.Function",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "numpy.numpy.ndarray",
                    "description": "A tuple with the local vector, a mapping from the local to the"
                  },
                  "docstring": [],
                  "source": "def _get_global_dofs(self, func: fe.Function) -> tuple[np.ndarray, np.ndarray, int]:\n    \"\"\"\n    Get global dofs for a given function.\n\n    Args:\n        - func: Expression/field/function\n\n    Returns:\n        A tuple with the local vector, a mapping from the local to the\n        global vertices (both sorted by index because h5py complains if\n        slicing is not continuously increasing), and the number of global\n        vertices.\n    \"\"\"\n    assert hasattr(func, \"function_space\"), (\n        \"Input is likely an indexed coefficient. Project to it's own function space first.\"\n    )\n\n    # Project to CG1 if necessary\n    if func.ufl_element().degree() != 1:\n        func = fe.project(\n            func, fe.FunctionSpace(func.function_space().mesh(), \"CG\", 1)\n        )\n\n    mesh = func.function_space().mesh()\n    global_size = mesh.num_entities_global(0)\n    shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n    val_per_vertex = np.prod(shape[1:]).astype(np.int32) if func.ufl_shape else 1\n\n    dofmap = func.function_space().dofmap()\n    d2v = fe.dof_to_vertex_map(func.function_space())\n    d2v = (\n        d2v[np.arange(0, len(d2v), val_per_vertex, dtype=np.int32)]\n        // val_per_vertex\n    )\n\n    loc0, loc1 = (i // val_per_vertex for i in dofmap.ownership_range())\n    global_vertex_numbers = mesh.topology().global_indices(0)\n    global_vertices = global_vertex_numbers[d2v[: loc1 - loc0]]\n    sort_indices = np.argsort(global_vertices)\n\n    local_vector = (\n        func.vector().get_local().reshape(shape)[: loc1 - loc0][sort_indices]\n    )\n\n    return (local_vector, global_vertices[sort_indices], global_size)"
                },
                "_get_global_dofs_cell_data": {
                  "name": "_get_global_dofs_cell_data",
                  "path": "bamboost.plugins_dev.fenics._FenicsFieldData._get_global_dofs_cell_data",
                  "signature": "(self, func) -> tuple[np.ndarray, np.ndarray, int]",
                  "description": "Get global dofs for a given function.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "func",
                      "annotation": "fenics.fenics.Function",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "numpy.numpy.ndarray",
                    "description": "A tuple with the local vector, a mapping from the local to the"
                  },
                  "docstring": [],
                  "source": "def _get_global_dofs_cell_data(\n    self, func: fe.Function\n) -> tuple[np.ndarray, np.ndarray, int]:\n    \"\"\"\n    Get global dofs for a given function.\n\n    Args:\n        - func: Expression/field/function\n\n    Returns:\n        A tuple with the local vector, a mapping from the local to the\n        global vertices (both sorted by index because h5py complains if\n        slicing is not continuously increasing), and the number of global\n        vertices.\n    \"\"\"\n    V = func.function_space()\n    val_per_vertex = (\n        np.prod(func.ufl_shape).astype(np.int32) if func.ufl_shape else 1\n    )\n\n    mesh = V.mesh()\n    dofmap = V.dofmap()\n\n    local_to_global_indices = dofmap.tabulate_local_to_global_dofs()\n    local_to_global_indices = (\n        local_to_global_indices[\n            np.arange(\n                0, len(local_to_global_indices), val_per_vertex, dtype=np.int32\n            )\n        ]\n        // val_per_vertex\n    )\n    shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n    local_vector = func.vector().get_local().reshape(shape)\n\n    return (\n        local_vector,\n        local_to_global_indices,\n        self._file._comm.allreduce(mesh.num_cells(), op=MPI.SUM),\n    )"
                }
              },
              "source": "class _FenicsFieldData(FieldData[Mutable], PluginComponent):\n    def add_fenics_function(\n        self,\n        name: str,\n        function: fe.Function,\n        field_type: FieldType = FieldType.NODE,\n        attrs: Optional[dict[str, Any]] = None,\n        dtype: Optional[str] = None,\n        *,\n        file_map: bool = True,\n    ) -> None:\n        \"\"\"Add a Fenics function to the field.\"\"\"\n        write_strategy: WriteStrategy = self.__plugin__.opts[\"write_strategy\"]\n\n        if write_strategy == WriteStrategy.CONTIGUOUS:\n            self._dump_fenics_field_on_root(\n                name, function, dtype=dtype, center=field_type\n            )\n        else:\n            self._dump_fenics_field(name, function, dtype=dtype, center=field_type)\n\n        log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n        self.attrs.update(attrs or {})\n\n        # update file_map\n        if file_map:\n            self._group_map[name] = h5py.Dataset\n\n    def _dump_fenics_field(\n        self,\n        name: str,\n        field: fe.Function,\n        dtype: Optional[str] = None,\n        center: FieldType = FieldType.NODE,\n    ) -> None:\n        # get global dofs ordering and vector\n        if center == FieldType.NODE:\n            vector, global_map, global_size = self._get_global_dofs(field)\n        elif center == FieldType.ELEMENT:\n            vector, global_map, global_size = self._get_global_dofs_cell_data(field)\n        else:\n            raise ValueError(\"Invalid field type (NODE or ELEMENT).\")\n\n        dim = vector.shape[1:] if vector.ndim > 1 else None\n\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            dataset = self._obj.require_dataset(\n                name,\n                shape=(global_size, *dim) if dim else (global_size,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            dataset[global_map] = vector\n\n    def _dump_fenics_field_on_root(\n        self,\n        name: str,\n        field: fe.Function,\n        dtype: Optional[str] = None,\n        center: FieldType = FieldType.NODE,\n    ) -> None:\n        \"\"\"Assembles the vector on the root process and writes it to file contiguously.\n\n        This is faster but requires the entire array to fit in memory.\n\n        Args:\n            location: Location in the HDF5 file\n            field: FEniCS function\n            dtype: Optional. Numpy style datatype, see h5py documentation,\n                defaults to the dtype of the vector\n            center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n                Default is 'Node'.\n        \"\"\"\n        # get global dofs ordering and vector\n        if center == FieldType.NODE:\n            vector, global_map, global_size = self._get_global_dofs(field)\n        elif center == FieldType.ELEMENT:\n            vector, global_map, global_size = self._get_global_dofs_cell_data(field)\n        else:\n            raise ValueError(\"Invalid field type (NODE or ELEMENT).\")\n\n        dim = vector.shape[1:] if vector.ndim > 1 else None\n\n        vector_p = self._file._comm.gather(vector)\n        global_map_p = self._file._comm.gather(global_map)\n\n        # On RAM, construct a contiguous vector on the root process\n        if self._file._comm.rank == 0:\n            vector_contiguous = np.zeros(\n                (global_size, *dim) if dim else (global_size,), dtype=vector.dtype\n            )\n            for map, vec in zip(global_map_p, vector_p):  # type: ignore\n                vector_contiguous[map] = vec\n\n            # Write vector to file\n            def _write_vector():\n                vec = self.require_dataset(\n                    name,\n                    shape=(global_size, *dim) if dim else (global_size,),\n                    dtype=dtype if dtype else vector.dtype,\n                )\n                vec[:] = vector_contiguous\n\n            self.post_write_instruction(_write_vector)\n\n    def _get_global_dofs(self, func: fe.Function) -> tuple[np.ndarray, np.ndarray, int]:\n        \"\"\"\n        Get global dofs for a given function.\n\n        Args:\n            - func: Expression/field/function\n\n        Returns:\n            A tuple with the local vector, a mapping from the local to the\n            global vertices (both sorted by index because h5py complains if\n            slicing is not continuously increasing), and the number of global\n            vertices.\n        \"\"\"\n        assert hasattr(func, \"function_space\"), (\n            \"Input is likely an indexed coefficient. Project to it's own function space first.\"\n        )\n\n        # Project to CG1 if necessary\n        if func.ufl_element().degree() != 1:\n            func = fe.project(\n                func, fe.FunctionSpace(func.function_space().mesh(), \"CG\", 1)\n            )\n\n        mesh = func.function_space().mesh()\n        global_size = mesh.num_entities_global(0)\n        shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n        val_per_vertex = np.prod(shape[1:]).astype(np.int32) if func.ufl_shape else 1\n\n        dofmap = func.function_space().dofmap()\n        d2v = fe.dof_to_vertex_map(func.function_space())\n        d2v = (\n            d2v[np.arange(0, len(d2v), val_per_vertex, dtype=np.int32)]\n            // val_per_vertex\n        )\n\n        loc0, loc1 = (i // val_per_vertex for i in dofmap.ownership_range())\n        global_vertex_numbers = mesh.topology().global_indices(0)\n        global_vertices = global_vertex_numbers[d2v[: loc1 - loc0]]\n        sort_indices = np.argsort(global_vertices)\n\n        local_vector = (\n            func.vector().get_local().reshape(shape)[: loc1 - loc0][sort_indices]\n        )\n\n        return (local_vector, global_vertices[sort_indices], global_size)\n\n    def _get_global_dofs_cell_data(\n        self, func: fe.Function\n    ) -> tuple[np.ndarray, np.ndarray, int]:\n        \"\"\"\n        Get global dofs for a given function.\n\n        Args:\n            - func: Expression/field/function\n\n        Returns:\n            A tuple with the local vector, a mapping from the local to the\n            global vertices (both sorted by index because h5py complains if\n            slicing is not continuously increasing), and the number of global\n            vertices.\n        \"\"\"\n        V = func.function_space()\n        val_per_vertex = (\n            np.prod(func.ufl_shape).astype(np.int32) if func.ufl_shape else 1\n        )\n\n        mesh = V.mesh()\n        dofmap = V.dofmap()\n\n        local_to_global_indices = dofmap.tabulate_local_to_global_dofs()\n        local_to_global_indices = (\n            local_to_global_indices[\n                np.arange(\n                    0, len(local_to_global_indices), val_per_vertex, dtype=np.int32\n                )\n            ]\n            // val_per_vertex\n        )\n        shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n        local_vector = func.vector().get_local().reshape(shape)\n\n        return (\n            local_vector,\n            local_to_global_indices,\n            self._file._comm.allreduce(mesh.num_cells(), op=MPI.SUM),\n        )",
              "inherited_members": {
                "bamboost.plugins.PluginComponent": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.PluginComponent.__plugin__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.PluginComponent.__init_subclass__"
                  }
                ],
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.hdf5.ref.H5Reference": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.new"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object.mutable"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.series.FieldData": [
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.FieldData.__init__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.FieldData.__getitem__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.FieldData._parent"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.series.FieldData.name"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.FieldData.at"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.FieldData._handle_negative_index"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.series.FieldData._slice_step"
                  }
                ],
                "bamboost.core.hdf5.ref.Group": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._status"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._obj"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._is_valid"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._group_map"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__contains__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__iter__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.keys"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.groups"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.datasets"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.items"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_self"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_group"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                  }
                ]
              }
            },
            "_FenicsMeshes": {
              "name": "_FenicsMeshes",
              "path": "bamboost.plugins_dev.fenics._FenicsMeshes",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "simulation",
                  "annotation": "'_Simulation'",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "add_fenics_mesh": {
                  "name": "add_fenics_mesh",
                  "path": "bamboost.plugins_dev.fenics._FenicsMeshes.add_fenics_mesh",
                  "signature": "(self, mesh, name=DEFAULT_MESH_NAME, cell_type=CellType.TRIANGLE) -> None",
                  "description": "Add a mesh with the given name to the simulation.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mesh",
                      "annotation": "fenics.fenics.Mesh",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the mesh"
                        }
                      ],
                      "value": "bamboost.constants.DEFAULT_MESH_NAME"
                    },
                    {
                      "name": "cell_type",
                      "annotation": "bamboost.core.simulation.CellType",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Cell type (default: \"triangle\"). In general, we do not care about\nthe cell type and leave it up to the user to make sense of the data they\nprovide. However, the cell type specified is needed for writing an XDMF\nfile. For possible types, consult the XDMF/paraview manual."
                        }
                      ],
                      "value": "bamboost.core.simulation.CellType.bamboost.core.simulation.CellType.TRIANGLE"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def add_fenics_mesh(\n    self,\n    mesh: fe.Mesh,\n    name: str = DEFAULT_MESH_NAME,\n    cell_type: CellType = CellType.TRIANGLE,\n) -> None:\n    \"\"\"Add a mesh with the given name to the simulation.\n\n    Args:\n        nodes: Node coordinates\n        cells: Cell connectivity\n        name: Name of the mesh\n        cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n            the cell type and leave it up to the user to make sense of the data they\n            provide. However, the cell type specified is needed for writing an XDMF\n            file. For possible types, consult the XDMF/paraview manual.\n    \"\"\"\n    from mpi4py import MPI\n\n    mesh_location = f\"{self._path}/{name}\"\n    with self._temporary_close_file():\n        with fe.HDF5File(MPI.COMM_WORLD, self._file._filename, \"a\") as f:\n            f.write(mesh, mesh_location)\n\n    self.attrs.update({\"cell_type\": cell_type.value})"
                },
                "_temporary_close_file": {
                  "name": "_temporary_close_file",
                  "path": "bamboost.plugins_dev.fenics._FenicsMeshes._temporary_close_file",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@contextmanager\ndef _temporary_close_file(self):\n    was_open = False\n    if self._file.is_open:\n        was_open = True\n        mode = self._file.mode\n        driver = str(self._file.driver)\n        self._file.close()\n    try:\n        yield\n    finally:\n        if was_open:\n            self._file.open(mode, driver)  # type: ignore"
                }
              },
              "source": "class _FenicsMeshes(GroupMeshes[Mutable], PluginComponent, replace_base=True):\n    def add_fenics_mesh(\n        self,\n        mesh: fe.Mesh,\n        name: str = DEFAULT_MESH_NAME,\n        cell_type: CellType = CellType.TRIANGLE,\n    ) -> None:\n        \"\"\"Add a mesh with the given name to the simulation.\n\n        Args:\n            nodes: Node coordinates\n            cells: Cell connectivity\n            name: Name of the mesh\n            cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n                the cell type and leave it up to the user to make sense of the data they\n                provide. However, the cell type specified is needed for writing an XDMF\n                file. For possible types, consult the XDMF/paraview manual.\n        \"\"\"\n        from mpi4py import MPI\n\n        mesh_location = f\"{self._path}/{name}\"\n        with self._temporary_close_file():\n            with fe.HDF5File(MPI.COMM_WORLD, self._file._filename, \"a\") as f:\n                f.write(mesh, mesh_location)\n\n        self.attrs.update({\"cell_type\": cell_type.value})\n\n    @contextmanager\n    def _temporary_close_file(self):\n        was_open = False\n        if self._file.is_open:\n            was_open = True\n            mode = self._file.mode\n            driver = str(self._file.driver)\n            self._file.close()\n        try:\n            yield\n        finally:\n            if was_open:\n                self._file.open(mode, driver)  # type: ignore",
              "inherited_members": {
                "bamboost.plugins.PluginComponent": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.PluginComponent.__plugin__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.PluginComponent.__init_subclass__"
                  }
                ],
                "bamboost.plugins.ElligibleForPlugin": [
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.ElligibleForPlugin.__new__"
                  }
                ],
                "bamboost.core.hdf5.ref.H5Reference": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._file"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference._path"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.H5Reference.new"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                  }
                ],
                "bamboost.core.hdf5.file.H5Object": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object._comm"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.file.H5Object.mutable"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.open"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.post_write_instruction"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.file.H5Object.suspend_immediate_write"
                  }
                ],
                "bamboost.core.simulation.groups.GroupMeshes": [
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.groups.GroupMeshes.__init__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.groups.GroupMeshes.__getitem__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.simulation.groups.GroupMeshes._simulation"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.simulation.groups.GroupMeshes.add"
                  }
                ],
                "bamboost.core.hdf5.ref.Group": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._status"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._obj"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._is_valid"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.core.hdf5.ref.Group._group_map"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__contains__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.__iter__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.keys"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.groups"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.datasets"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.items"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_self"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_group"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                  }
                ]
              }
            },
            "_T_FenicsPluginOpts": {
              "name": "_T_FenicsPluginOpts",
              "path": "bamboost.plugins_dev.fenics._T_FenicsPluginOpts",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "write_strategy",
                  "annotation": "bamboost.plugins_dev.fenics.WriteStrategy",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Write strategy for the data. Contiguous is faster but requires the entire array to fit in memory of the root process."
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class _T_FenicsPluginOpts(TypedDict, total=True):\n    write_strategy: WriteStrategy\n    \"\"\"Write strategy for the data. Contiguous is faster but requires the entire array to fit in memory of the root process.\"\"\"",
              "inherited_members": {}
            },
            "FenicsBamboostPlugin": {
              "name": "FenicsBamboostPlugin",
              "path": "bamboost.plugins_dev.fenics.FenicsBamboostPlugin",
              "description": "Plugin for writing FEniCS data to HDF5 files.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "opts",
                  "annotation": "bamboost.plugins._T_PluginOpts",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "FenicsWriter",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.plugins_dev.fenics._FenicsStepWriter"
                },
                {
                  "name": "FenicsFieldData",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.plugins_dev.fenics._FenicsFieldData"
                },
                {
                  "name": "FenicsMeshes",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.plugins_dev.fenics._FenicsMeshes"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class FenicsBamboostPlugin(Plugin[_T_FenicsPluginOpts]):\n    \"\"\"Plugin for writing FEniCS data to HDF5 files.\"\"\"\n\n    FenicsWriter = _FenicsStepWriter\n    FenicsFieldData = _FenicsFieldData\n    FenicsMeshes = _FenicsMeshes",
              "inherited_members": {
                "bamboost.plugins.Plugin": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.Plugin.name"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.Plugin.override_components"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.Plugin.components"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.plugins.Plugin.__init__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.plugins.Plugin.opts"
                  }
                ]
              }
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "index": {
      "name": "index",
      "path": "bamboost.index",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/index/__init__.py",
      "description": "Module for indexing BAMBOOST collections.\n\nUses a caching mechanism using SQLAlchemy and an SQLite database to store\ninformation about collections and simulations.",
      "docstring": [
        {
          "kind": "admonition",
          "value": {
            "annotation": "usage",
            "description": "Create an instance of the `Index` class and use its methods to interact\nwith the index.\n\n>>> from bamboost.index import Index\n>>> index = Index()\n\nScan for collections in known paths:\n\n>>> index.scan_for_collections()\n\nResolve the path of a collection:\n\n>>> index.resolve_path(<collection-uid>)\n\nGet a simulation from its collection and simulation name:\n\n>>> index.get_simulation(<collection-uid>, <simulation-name>)"
          },
          "title": "Usage"
        },
        {
          "kind": "classes",
          "value": [
            {
              "name": "Index",
              "annotation": null,
              "description": "API for indexing BAMBOOST collections and simulations."
            }
          ]
        }
      ],
      "attributes": [],
      "modules": {
        "base": {
          "name": "base",
          "path": "bamboost.index.base",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/index/base.py",
          "description": "Indexing of bamboost collections and their simulations/parameters. SQLAlchemy is used to\ninteract with the SQLite database.\n\nThe index is generated on the fly or can be explicitly created by scanning the\n`search_paths` for collections. The index is stored as a SQLite database that stores the\npath of collections (characterized with a unique UID), as well as the metadata and\nparameters of all simulations.\n\nThe `bamboost.index.base.Index` class provides the public API for interacting with the\nindex. This works in paralell execution, but the class is designed to execute any\noperations on the database on the root process only. Methods that return something use\n`bcast` to cast the result to all processes. Any SQL operation is executed only on the\nroot process!\n\nDatabase schema:\n- `collections`: Contains information about the collections, namely uids and corresponding\n  paths.\n- `simulations`: Contains information about the simulations, including names, statuses,\n  and links to the corresponding parameters.\n- `parameters`: Contains the parameters associated with the simulations.",
          "docstring": [],
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild('Database')"
            },
            {
              "name": "IDENTIFIER_PREFIX",
              "annotation": null,
              "description": null,
              "value": "'.bamboost-collection'"
            },
            {
              "name": "IDENTIFIER_SEPARATOR",
              "annotation": null,
              "description": null,
              "value": "'-'"
            }
          ],
          "modules": {},
          "classes": {
            "CollectionUID": {
              "name": "CollectionUID",
              "path": "bamboost.index.base.CollectionUID",
              "description": "UID of a collection. If no UID is provided, a new one is generated.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboost.index.base.CollectionUID.__new__",
                  "signature": "(cls, uid=None, length=10)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "typing.Optional[str]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "length",
                      "annotation": "int",
                      "description": null,
                      "value": "10"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __new__(cls, uid: Optional[str] = None, length: int = 10):\n    uid = uid or cls.generate_uid(length)\n    return super().__new__(cls, uid.upper())"
                },
                "generate_uid": {
                  "name": "generate_uid",
                  "path": "bamboost.index.base.CollectionUID.generate_uid",
                  "signature": "(length) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "length",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef generate_uid(length: int) -> str:\n    return uuid.uuid4().hex[:length].upper()"
                }
              },
              "source": "class CollectionUID(str):\n    \"\"\"UID of a collection. If no UID is provided, a new one is generated.\"\"\"\n\n    def __new__(cls, uid: Optional[str] = None, length: int = 10):\n        uid = uid or cls.generate_uid(length)\n        return super().__new__(cls, uid.upper())\n\n    @staticmethod\n    def generate_uid(length: int) -> str:\n        return uuid.uuid4().hex[:length].upper()",
              "inherited_members": {}
            },
            "LazyDefaultIndex": {
              "name": "LazyDefaultIndex",
              "path": "bamboost.index.base.LazyDefaultIndex",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "_instance",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index.base.LazyDefaultIndex.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self) -> None:\n    self._instance = None"
                },
                "__get__": {
                  "name": "__get__",
                  "path": "bamboost.index.base.LazyDefaultIndex.__get__",
                  "signature": "(self, instance, owner) -> Index",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "instance",
                      "annotation": "None",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "owner",
                      "annotation": "typing.Type[bamboost.index.base.Index]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __get__(self, instance: None, owner: Type[Index]) -> Index:\n    assert instance is None, (\n        \"The default index is a class attribute! Use `Index.default` instead.\"\n    )\n    if self._instance is None:\n        self._instance = Index(\n            sql_file=config.index.databaseFile,\n            search_paths=config.index.searchPaths,\n        )\n    return self._instance"
                },
                "__set__": {
                  "name": "__set__",
                  "path": "bamboost.index.base.LazyDefaultIndex.__set__",
                  "signature": "(self, instance, value) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "instance",
                      "annotation": "None",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "value",
                      "annotation": "bamboost.index.base.Index",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __set__(self, instance: None, value: Index) -> None:\n    self._instance = value"
                },
                "__delete__": {
                  "name": "__delete__",
                  "path": "bamboost.index.base.LazyDefaultIndex.__delete__",
                  "signature": "(self, instance) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "instance",
                      "annotation": "None",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __delete__(self, instance: None) -> None:\n    raise AttributeError(\"Cannot delete LazyDefaultIndex descriptor.\")"
                }
              },
              "source": "class LazyDefaultIndex:\n    def __init__(self) -> None:\n        self._instance = None\n\n    def __get__(self, instance: None, owner: Type[Index]) -> Index:\n        assert instance is None, (\n            \"The default index is a class attribute! Use `Index.default` instead.\"\n        )\n        if self._instance is None:\n            self._instance = Index(\n                sql_file=config.index.databaseFile,\n                search_paths=config.index.searchPaths,\n            )\n        return self._instance\n\n    def __set__(self, instance: None, value: Index) -> None:\n        self._instance = value\n\n    def __delete__(self, instance: None) -> None:\n        raise AttributeError(\"Cannot delete LazyDefaultIndex descriptor.\")",
              "inherited_members": {}
            },
            "Index": {
              "name": "Index",
              "path": "bamboost.index.base.Index",
              "description": "API for indexing BAMBOOST collections and simulations.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sql_file",
                  "annotation": "typing.Optional[bamboost._typing.StrPath]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "comm",
                  "annotation": "typing.Optional[bamboost.mpi.Comm]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "search_paths",
                  "annotation": "typing.Optional[typing.Iterable[str | pathlib.Path]]",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "_comm",
                  "annotation": null,
                  "description": null,
                  "value": "Communicator()"
                },
                {
                  "name": "_engine",
                  "annotation": "sqlalchemy.Engine",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_sm",
                  "annotation": "typing.Callable[..., sqlalchemy.orm.Session]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_s",
                  "annotation": "sqlalchemy.orm.Session",
                  "description": null,
                  "value": null
                },
                {
                  "name": "search_paths",
                  "annotation": "bamboost.utilities.PathSet",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Paths to scan for collections."
                    }
                  ],
                  "value": "PathSet(search_paths or config.index.searchPaths)"
                },
                {
                  "name": "default",
                  "annotation": "bamboost.index.base.LazyDefaultIndex",
                  "description": [
                    {
                      "kind": "text",
                      "value": "A default index instance. Uses the default SQLite database file and search paths\nfrom the configuration."
                    }
                  ],
                  "value": "LazyDefaultIndex()"
                },
                {
                  "name": "_file",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "The path to the SQLite database file."
                    }
                  ],
                  "value": "bamboost.index.base.Index(sql_file) or bamboost.config.bamboost.config.index.bamboost.config.index.databaseFile"
                },
                {
                  "name": "_isolated",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "Whether project based indexing is used."
                    }
                  ],
                  "value": "bamboost.config.bamboost.config.index.bamboost.config.index.isolated"
                },
                {
                  "name": "_url",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "The URL to the SQLite database file."
                    }
                  ],
                  "value": "f'sqlite:///{bamboost.index.base.Index(self).bamboost.index.base.Index(self)._file}'"
                },
                {
                  "name": "all_collections",
                  "annotation": "typing.Sequence[bamboost.index.sqlmodel.CollectionORM]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all collections in the index. Eagerly loads the simulations\nand its parameters."
                    }
                  ],
                  "value": null
                },
                {
                  "name": "all_simulations",
                  "annotation": "typing.Sequence[bamboost.index.sqlmodel.SimulationORM]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all simulations in the index. Eagerly loads the parameters."
                    }
                  ],
                  "value": null
                },
                {
                  "name": "all_parameters",
                  "annotation": "typing.Sequence[bamboost.index.sqlmodel.ParameterORM]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all parameters in the index."
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "usage",
                    "description": "Create an instance of the `Index` class and use its methods to interact\nwith the index.\n>>> from bamboost.index import Index\n>>> index = Index()\n\nScan for collections in known paths:\n>>> index.scan_for_collections()\n\nResolve the path of a collection:\n>>> index.resolve_path(<collection-uid>)\n\nGet a simulation from its collection and simulation name:\n>>> index.get_simulation(<collection-uid>, <simulation-name>)"
                  },
                  "title": "Usage"
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index.base.Index.__init__",
                  "signature": "(self, sql_file=None, comm=None, *, search_paths=None) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "sql_file",
                      "annotation": "typing.Optional[bamboost._typing.StrPath]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "comm",
                      "annotation": "typing.Optional[bamboost.mpi.Comm]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "search_paths",
                      "annotation": "typing.Optional[typing.Iterable[str | pathlib.Path]]",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    sql_file: Optional[StrPath] = None,\n    comm: Optional[Comm] = None,\n    *,\n    search_paths: Optional[Iterable[str | Path]] = None,\n) -> None:\n    self.search_paths = PathSet(search_paths or config.index.searchPaths)\n    \"\"\"Paths to scan for collections.\"\"\"\n\n    self._file = sql_file or config.index.databaseFile\n    \"\"\"The path to the SQLite database file.\"\"\"\n\n    self._isolated = config.index.isolated\n    \"\"\"Whether project based indexing is used.\"\"\"\n\n    self._url = f\"sqlite:///{self._file}\"\n    \"\"\"The URL to the SQLite database file.\"\"\"\n\n    self._initialize_root_process(self._url)"
                },
                "_initialize_root_process": {
                  "name": "_initialize_root_process",
                  "path": "bamboost.index.base.Index._initialize_root_process",
                  "signature": "(self, url) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "url",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _initialize_root_process(self, url: str) -> None:\n    self._engine = create_engine(\n        url, json_serializer=json_serializer, json_deserializer=json_deserializer\n    )\n\n    def _fk_pragma_on_connect(dbapi_con, _con_record):\n        dbapi_con.execute(\"pragma foreign_keys=ON\")\n\n    event.listen(self._engine, \"connect\", _fk_pragma_on_connect)\n    create_all(self._engine)\n    self._sm = sessionmaker(\n        bind=self._engine, autobegin=False, expire_on_commit=False\n    )\n    self._s = self._sm()"
                },
                "sql_transaction": {
                  "name": "sql_transaction",
                  "path": "bamboost.index.base.Index.sql_transaction",
                  "signature": "(self) -> Generator[Session, None, None]",
                  "description": "Context manager for a SQL transaction.\n\nIf no transaction is active, a new transaction is started. If a\ntransaction is active, the current session is used.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "usage",
                        "description": ">>> with index.sql_transaction() as s:\n...     s.execute(...)"
                      },
                      "title": "Usage"
                    }
                  ],
                  "source": "@RootProcessMeta.exclude\n@contextmanager\ndef sql_transaction(self) -> Generator[Session, None, None]:\n    \"\"\"Context manager for a SQL transaction.\n\n    If no transaction is active, a new transaction is started. If a\n    transaction is active, the current session is used.\n\n    Usage:\n        >>> with index.sql_transaction() as s:\n        ...     s.execute(...)\n    \"\"\"\n    # if not root rank, return dummy context manager\n    if not self._comm.rank == 0:\n        yield None  # type: ignore\n        return\n\n    if self._s.in_transaction():\n        try:\n            yield self._s\n        except SQLAlchemyError as e:\n            log.warning(f\"Caching transaction failed: {e}\")\n        return\n\n    try:\n        self._s.begin()\n        yield self._s\n        self._s.commit()\n    except SQLAlchemyError as e:\n        # self._s.rollback()  # Is this necessary?\n        log.warning(f\"Caching transaction failed: {e}\")\n    finally:\n        self._s.close()  # Not decided yet if we should close the session"
                },
                "scan_for_collections": {
                  "name": "scan_for_collections",
                  "path": "bamboost.index.base.Index.scan_for_collections",
                  "signature": "(self, *, search_paths=None) -> list[tuple[str, Path]]",
                  "description": "Scan known paths for collections and update the index.\n\nIterates through the search paths and searches files with the\nidentifier file structure. If a collection is found, it is added to the\ncache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "search_paths",
                      "annotation": "List[pathlib.Path]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Paths to scan for collections.\nDefaults to config.index.searchPaths."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef scan_for_collections(\n    self,\n    *,\n    search_paths: Optional[PathSet] = None,\n) -> list[tuple[str, Path]]:\n    \"\"\"Scan known paths for collections and update the index.\n\n    Iterates through the search paths and searches files with the\n    identifier file structure. If a collection is found, it is added to the\n    cache.\n\n    Args:\n        search_paths (List[Path], optional): Paths to scan for collections.\n            Defaults to config.index.searchPaths.\n    \"\"\"\n    search_paths = PathSet(search_paths) or self.search_paths\n    all_found_collections = []\n\n    for path in search_paths:\n        found_collections: tuple[tuple[str, Path], ...] = (\n            _scan_directory_for_collections(path)\n        )\n        if not found_collections:\n            continue\n        collections_data = [\n            {\"uid\": uid, \"path\": str(path)} for uid, path in found_collections\n        ]\n        self._s.execute(CollectionORM.upsert(collections_data))\n        log.debug(f\"Inserting found collections:\\n{collections_data}\")\n        all_found_collections.extend(found_collections)\n\n    return all_found_collections"
                },
                "check_integrity": {
                  "name": "check_integrity",
                  "path": "bamboost.index.base.Index.check_integrity",
                  "signature": "(self) -> None",
                  "description": "Check the integrity of the cache.\n\nThis method checks if the paths stored in the cache are valid. If a\npath is not valid, it is removed from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef check_integrity(self) -> None:\n    \"\"\"Check the integrity of the cache.\n\n    This method checks if the paths stored in the cache are valid. If a\n    path is not valid, it is removed from the cache.\n    \"\"\"\n    for collection in self._s.execute(select(CollectionORM)).scalars().all():\n        if not _validate_path(Path(collection.path), collection.uid):\n            log.info(\n                f\"Invalid collection path in cache: {collection.uid, collection.path} -> removing.\"\n            )\n            self._s.delete(collection)"
                },
                "resolve_path": {
                  "name": "resolve_path",
                  "path": "bamboost.index.base.Index.resolve_path",
                  "signature": "(self, uid, *, search_paths=None) -> Path",
                  "description": "Resolve and return the path of a collection from its UID. Raises a\n`FileNotFoundError` if the collection is not found in the search paths.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "search_paths",
                      "annotation": "typing.Optional[typing.Set[bamboost._typing.StrPath]]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Paths to search for the collection"
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "raises",
                      "value": [
                        {
                          "annotation": "FileNotFoundError",
                          "description": "If the collection is not found in the search paths"
                        }
                      ]
                    }
                  ],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef resolve_path(\n    self,\n    uid: str,\n    *,\n    search_paths: Optional[Set[StrPath]] = None,\n) -> Path:\n    \"\"\"Resolve and return the path of a collection from its UID. Raises a\n    `FileNotFoundError` if the collection is not found in the search paths.\n\n    Args:\n        uid: UID of the collection\n        search_paths: Paths to search for the collection\n\n    Raises:\n        FileNotFoundError: If the collection is not found in the search paths\n    \"\"\"\n    stored_path = self._get_collection_path(uid)\n\n    if stored_path and _validate_path(stored_path, uid):\n        return stored_path\n\n    log.debug(f\"No or invalid path found in cache for collection <{uid}>.\")\n\n    # Try to find the collection in the search paths\n    for root_dir in PathSet(search_paths) or self.search_paths:\n        log.debug(f\"Searching for collection <{uid}> in <{root_dir}>\")\n        paths_found = _find_collection(uid, Path(root_dir))\n\n        if len(paths_found) > 0:  # If at least one file is found\n            if len(paths_found) > 1:\n                log.warning(\n                    f\"Multiple collections found for {uid}. Using the first one.\"\n                    f\"\\n{paths_found}\"\n                )\n\n            # Store the collection in the cache\n            self.upsert_collection(uid, paths_found[0])\n            return paths_found[0]\n\n    raise FileNotFoundError(f\"Database with {uid} was not found.\")"
                },
                "resolve_uid": {
                  "name": "resolve_uid",
                  "path": "bamboost.index.base.Index.resolve_uid",
                  "signature": "(self, path) -> CollectionUID",
                  "description": "Resolve the UID of a collection from a path.\n\nReturns the UID of the collection or a new UID if it can't be\ndetermined.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "bamboost._typing.StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef resolve_uid(self, path: StrPath) -> CollectionUID:\n    \"\"\"Resolve the UID of a collection from a path.\n\n    Returns the UID of the collection or a new UID if it can't be\n    determined.\n\n    Args:\n        path: Path of the collection\n    \"\"\"\n    path = Path(path)\n    cached_uid: str | None = self._s.execute(\n        select(CollectionORM.uid).where(CollectionORM.path == path.as_posix())\n    ).scalar()\n    if cached_uid and _validate_path(path, cached_uid):\n        return CollectionUID(cached_uid)\n\n    log.debug(f\"No or invalid uid found in cache for collection <{path}>.\")\n\n    identified_uid = _find_uid_from_path(path)\n    uid = CollectionUID(\n        identified_uid\n    )  # Note: this generates a new UID if none is found\n    self._s.execute(\n        CollectionORM.upsert({\"uid\": uid, \"path\": path.absolute().as_posix()})\n    )\n    return uid"
                },
                "sync_collection": {
                  "name": "sync_collection",
                  "path": "bamboost.index.base.Index.sync_collection",
                  "signature": "(self, uid, path=None, *, force_all=False) -> None",
                  "description": "Sync the table with the file system.\n\nIterates through the simulations in the collection and updates the\nmetadata and parameters if the HDF5 file has been modified.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "path",
                      "annotation": "typing.Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "force_all",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef sync_collection(\n    self, uid: str, path: Optional[StrPath] = None, *, force_all: bool = False\n) -> None:\n    \"\"\"Sync the table with the file system.\n\n    Iterates through the simulations in the collection and updates the\n    metadata and parameters if the HDF5 file has been modified.\n\n    Args:\n        uid: UID of the collection\n        path (Optional): Path of the collection\n    \"\"\"\n    path = Path(path or self.resolve_path(uid)).absolute()\n    # Get all simulation names in the file system\n    all_simulations_fs = set(\n        (\n            i.name\n            for i in path.iterdir()\n            if i.is_dir() and i.joinpath(constants.HDF_DATA_FILE_NAME).is_file()\n        )\n    )\n\n    collection = self._s.get(CollectionORM, uid)\n\n    if collection:\n        for simulation in collection.simulations:\n            if simulation.name not in all_simulations_fs:\n                self._s.delete(simulation)\n                continue\n\n            # if the HDF5 file has not been modified since the last sync,\n            # remove the simulation from the active update set\n            if force_all:\n                continue\n            h5_file = path.joinpath(simulation.name, constants.HDF_DATA_FILE_NAME)\n            if (  # type: ignore\n                datetime.fromtimestamp(h5_file.stat().st_mtime)\n                <= simulation.modified_at\n            ):\n                all_simulations_fs.remove(simulation.name)\n\n    for name in all_simulations_fs:\n        log.debug(f\"Syncing simulation {name} in collection {uid}.\")\n        self.upsert_simulation(\n            collection_uid=uid, simulation_name=name, collection_path=path\n        )"
                },
                "collection": {
                  "name": "collection",
                  "path": "bamboost.index.base.Index.collection",
                  "signature": "(self, uid) -> CollectionORM | None",
                  "description": "Return a collection from the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef collection(self, uid: str) -> CollectionORM | None:\n    \"\"\"Return a collection from the index.\n\n    Args:\n        uid: UID of the collection\n    \"\"\"\n    log.debug(\"Fetching collection from cache.\")\n    return (\n        self._s.execute(\n            select(CollectionORM)\n            .where(CollectionORM.uid == uid)\n            .options(\n                joinedload(CollectionORM.simulations).subqueryload(\n                    SimulationORM.parameters\n                )\n            )\n        )\n        .unique()\n        .scalar()\n    )"
                },
                "simulation": {
                  "name": "simulation",
                  "path": "bamboost.index.base.Index.simulation",
                  "signature": "(self, collection_uid, name) -> SimulationORM | None",
                  "description": "Return a simulation from the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef simulation(self, collection_uid: str, name: str) -> SimulationORM | None:\n    \"\"\"Return a simulation from the index.\n\n    Args:\n        collection_uid: UID of the collection\n        name: Name of the simulation\n    \"\"\"\n    return (\n        self._s.execute(\n            select(SimulationORM)\n            .where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == name,\n            )\n            .options(joinedload(SimulationORM.parameters))\n        )\n        .unique()\n        .scalar()\n    )"
                },
                "_drop_collection": {
                  "name": "_drop_collection",
                  "path": "bamboost.index.base.Index._drop_collection",
                  "signature": "(self, uid) -> None",
                  "description": "Drop a collection from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef _drop_collection(self, uid: str) -> None:\n    \"\"\"Drop a collection from the cache.\n\n    Args:\n        uid: UID of the collection\n    \"\"\"\n    self._s.execute(delete(CollectionORM).where(CollectionORM.uid == uid))"
                },
                "_drop_simulation": {
                  "name": "_drop_simulation",
                  "path": "bamboost.index.base.Index._drop_simulation",
                  "signature": "(self, collection_uid, simulation_name) -> None",
                  "description": "Drop a simulation from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef _drop_simulation(self, collection_uid: str, simulation_name: str) -> None:\n    \"\"\"Drop a simulation from the cache.\n\n    Args:\n        collection_uid: UID of the collection\n        simulation_name: Name of the simulation\n    \"\"\"\n    stmt = delete(SimulationORM).where(\n        SimulationORM.collection_uid == collection_uid,\n        SimulationORM.name == simulation_name,\n    )\n    self._s.execute(stmt)"
                },
                "upsert_collection": {
                  "name": "upsert_collection",
                  "path": "bamboost.index.base.Index.upsert_collection",
                  "signature": "(self, uid, path) -> None",
                  "description": "Cache a collection in the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "path",
                      "annotation": "pathlib.Path",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef upsert_collection(self, uid: str, path: Path) -> None:\n    \"\"\"Cache a collection in the index.\n\n    Args:\n        uid: UID of the collection\n        path: Path of the collection\n    \"\"\"\n    self._s.execute(CollectionORM.upsert({\"uid\": uid, \"path\": path.as_posix()}))"
                },
                "upsert_simulation": {
                  "name": "upsert_simulation",
                  "path": "bamboost.index.base.Index.upsert_simulation",
                  "signature": "(self, collection_uid, simulation_name, parameters=None, metadata=None, *, collection_path=None) -> None",
                  "description": "Cache a simulation from a collection.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    },
                    {
                      "name": "parameters",
                      "annotation": "typing.Optional[typing.Mapping[typing.Any, typing.Any]]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "metadata",
                      "annotation": "typing.Optional[typing.Mapping[typing.Any, typing.Any]]",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "collection_path",
                      "annotation": "typing.Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef upsert_simulation(\n    self,\n    collection_uid: str,\n    simulation_name: str,\n    parameters: Optional[Mapping[Any, Any]] = None,\n    metadata: Optional[Mapping[Any, Any]] = None,\n    *,\n    collection_path: Optional[StrPath] = None,\n) -> None:\n    \"\"\"Cache a simulation from a collection.\n\n    Args:\n        collection_uid: UID of the collection\n        simulation_name: Name of the simulation\n        collection_path (Optional): Path of the collection\n    \"\"\"\n    collection_path = Path(collection_path or self.resolve_path(collection_uid))\n\n    if metadata is None and parameters is None:\n        from bamboost.core.simulation.base import Simulation\n\n        # if neither metadata nor parameters are provided, read them from the HDF5 file\n        # temp change the communicator to MPI.COMM_SELF -> because here is only\n        # executed on rank 0\n        # 04.03.25: unclear whether passing comm=MPI.COMM_SELF is sufficient in itself\n        # 26.03.25: removed the context manager, because it is included in the metaclass\n        sim = Simulation(\n            simulation_name,\n            collection_path,\n            index=self,\n            collection_uid=collection_uid,\n        )\n        with sim._file.open(\"r\"):\n            metadata, parameters = sim.metadata._dict, sim.parameters._dict\n\n    # Upsert the simulation table\n    sim_id = self._s.execute(\n        SimulationORM.upsert(\n            {\n                \"collection_uid\": collection_uid,\n                \"name\": simulation_name,\n                \"modified_at\": datetime.now(),\n                **(metadata or {}),\n            }\n        )\n    ).scalar_one()\n\n    # Upsert the parameters table\n    if parameters:\n        self._s.execute(\n            ParameterORM.upsert(\n                [\n                    {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                    for k, v in parameters.items()\n                ]\n            )\n        )"
                },
                "update_simulation_metadata": {
                  "name": "update_simulation_metadata",
                  "path": "bamboost.index.base.Index.update_simulation_metadata",
                  "signature": "(self, collection_uid, simulation_name, data) -> None",
                  "description": "Update the metadata of a simulation by passing it as a dict.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "typing.Mapping",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary with new data"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef update_simulation_metadata(\n    self, collection_uid: str, simulation_name: str, data: Mapping\n) -> None:\n    \"\"\"Update the metadata of a simulation by passing it as a dict.\n\n    Args:\n        data: Dictionary with new data\n    \"\"\"\n    self._s.execute(\n        SimulationORM.upsert(\n            {\"collection_uid\": collection_uid, \"name\": simulation_name, **data}\n        )\n    )"
                },
                "update_simulation_parameters": {
                  "name": "update_simulation_parameters",
                  "path": "bamboost.index.base.Index.update_simulation_parameters",
                  "signature": "(self, collection_uid, simulation_name, parameters) -> None",
                  "description": "Update the parameters of a simulation by passing it as a dict.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "bamboost._typing.SimulationParameterT",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary with new parameters"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef update_simulation_parameters(\n    self,\n    collection_uid: str,\n    simulation_name: str,\n    parameters: SimulationParameterT,\n) -> None:\n    \"\"\"Update the parameters of a simulation by passing it as a dict.\n\n    Args:\n        parameters: Dictionary with new parameters\n    \"\"\"\n    sim_id = self._s.execute(\n        select(SimulationORM.id).where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n    ).scalar_one()\n\n    self._s.execute(\n        ParameterORM.upsert(\n            [\n                {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                for k, v in parameters.items()\n            ]\n        )\n    )"
                },
                "_get_collection_path": {
                  "name": "_get_collection_path",
                  "path": "bamboost.index.base.Index._get_collection_path",
                  "signature": "(self, uid) -> Optional[Path]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_collection_path(\n    self,\n    uid: str,\n) -> Optional[Path]:\n    res = self._s.execute(\n        select(CollectionORM.path).where(CollectionORM.uid == uid)\n    ).scalar()\n    return Path(res) if res else None"
                },
                "_get_collections": {
                  "name": "_get_collections",
                  "path": "bamboost.index.base.Index._get_collections",
                  "signature": "(self) -> Sequence[CollectionORM]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_collections(self) -> Sequence[CollectionORM]:\n    return self._s.execute(select(CollectionORM)).scalars().all()"
                },
                "_get_simulation": {
                  "name": "_get_simulation",
                  "path": "bamboost.index.base.Index._get_simulation",
                  "signature": "(self, collection_uid, simulation_name) -> SimulationORM | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "bamboost.index.base.CollectionUID | str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_simulation(\n    self, collection_uid: CollectionUID | str, simulation_name: str\n) -> SimulationORM | None:\n    return self._s.execute(\n        select(SimulationORM)\n        .where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n        .options(joinedload(SimulationORM.parameters))\n    ).scalar()"
                }
              },
              "source": "class Index(metaclass=RootProcessMeta):\n    \"\"\"API for indexing BAMBOOST collections and simulations.\n\n    Usage:\n        Create an instance of the `Index` class and use its methods to interact\n        with the index.\n        >>> from bamboost.index import Index\n        >>> index = Index()\n\n        Scan for collections in known paths:\n        >>> index.scan_for_collections()\n\n        Resolve the path of a collection:\n        >>> index.resolve_path(<collection-uid>)\n\n        Get a simulation from its collection and simulation name:\n        >>> index.get_simulation(<collection-uid>, <simulation-name>)\n\n    Args:\n        cache: CacheAPI instance to use for the index. If not provided, a new\n            instance is created with the default cache file.\n    \"\"\"\n\n    _comm = Communicator()\n    _engine: Engine\n    _sm: Callable[..., Session]\n    _s: Session\n    search_paths: PathSet\n\n    default: ClassVar[LazyDefaultIndex] = LazyDefaultIndex()\n    \"\"\"A default index instance. Uses the default SQLite database file and search paths\n    from the configuration.\"\"\"\n\n    def __init__(\n        self,\n        sql_file: Optional[StrPath] = None,\n        comm: Optional[Comm] = None,\n        *,\n        search_paths: Optional[Iterable[str | Path]] = None,\n    ) -> None:\n        self.search_paths = PathSet(search_paths or config.index.searchPaths)\n        \"\"\"Paths to scan for collections.\"\"\"\n\n        self._file = sql_file or config.index.databaseFile\n        \"\"\"The path to the SQLite database file.\"\"\"\n\n        self._isolated = config.index.isolated\n        \"\"\"Whether project based indexing is used.\"\"\"\n\n        self._url = f\"sqlite:///{self._file}\"\n        \"\"\"The URL to the SQLite database file.\"\"\"\n\n        self._initialize_root_process(self._url)\n\n    def _initialize_root_process(self, url: str) -> None:\n        self._engine = create_engine(\n            url, json_serializer=json_serializer, json_deserializer=json_deserializer\n        )\n\n        def _fk_pragma_on_connect(dbapi_con, _con_record):\n            dbapi_con.execute(\"pragma foreign_keys=ON\")\n\n        event.listen(self._engine, \"connect\", _fk_pragma_on_connect)\n        create_all(self._engine)\n        self._sm = sessionmaker(\n            bind=self._engine, autobegin=False, expire_on_commit=False\n        )\n        self._s = self._sm()\n\n    @RootProcessMeta.exclude\n    @contextmanager\n    def sql_transaction(self) -> Generator[Session, None, None]:\n        \"\"\"Context manager for a SQL transaction.\n\n        If no transaction is active, a new transaction is started. If a\n        transaction is active, the current session is used.\n\n        Usage:\n            >>> with index.sql_transaction() as s:\n            ...     s.execute(...)\n        \"\"\"\n        # if not root rank, return dummy context manager\n        if not self._comm.rank == 0:\n            yield None  # type: ignore\n            return\n\n        if self._s.in_transaction():\n            try:\n                yield self._s\n            except SQLAlchemyError as e:\n                log.warning(f\"Caching transaction failed: {e}\")\n            return\n\n        try:\n            self._s.begin()\n            yield self._s\n            self._s.commit()\n        except SQLAlchemyError as e:\n            # self._s.rollback()  # Is this necessary?\n            log.warning(f\"Caching transaction failed: {e}\")\n        finally:\n            self._s.close()  # Not decided yet if we should close the session\n\n    @_sql_transaction\n    def scan_for_collections(\n        self,\n        *,\n        search_paths: Optional[PathSet] = None,\n    ) -> list[tuple[str, Path]]:\n        \"\"\"Scan known paths for collections and update the index.\n\n        Iterates through the search paths and searches files with the\n        identifier file structure. If a collection is found, it is added to the\n        cache.\n\n        Args:\n            search_paths (List[Path], optional): Paths to scan for collections.\n                Defaults to config.index.searchPaths.\n        \"\"\"\n        search_paths = PathSet(search_paths) or self.search_paths\n        all_found_collections = []\n\n        for path in search_paths:\n            found_collections: tuple[tuple[str, Path], ...] = (\n                _scan_directory_for_collections(path)\n            )\n            if not found_collections:\n                continue\n            collections_data = [\n                {\"uid\": uid, \"path\": str(path)} for uid, path in found_collections\n            ]\n            self._s.execute(CollectionORM.upsert(collections_data))\n            log.debug(f\"Inserting found collections:\\n{collections_data}\")\n            all_found_collections.extend(found_collections)\n\n        return all_found_collections\n\n    @_sql_transaction\n    def check_integrity(self) -> None:\n        \"\"\"Check the integrity of the cache.\n\n        This method checks if the paths stored in the cache are valid. If a\n        path is not valid, it is removed from the cache.\n        \"\"\"\n        for collection in self._s.execute(select(CollectionORM)).scalars().all():\n            if not _validate_path(Path(collection.path), collection.uid):\n                log.info(\n                    f\"Invalid collection path in cache: {collection.uid, collection.path} -> removing.\"\n                )\n                self._s.delete(collection)\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def resolve_path(\n        self,\n        uid: str,\n        *,\n        search_paths: Optional[Set[StrPath]] = None,\n    ) -> Path:\n        \"\"\"Resolve and return the path of a collection from its UID. Raises a\n        `FileNotFoundError` if the collection is not found in the search paths.\n\n        Args:\n            uid: UID of the collection\n            search_paths: Paths to search for the collection\n\n        Raises:\n            FileNotFoundError: If the collection is not found in the search paths\n        \"\"\"\n        stored_path = self._get_collection_path(uid)\n\n        if stored_path and _validate_path(stored_path, uid):\n            return stored_path\n\n        log.debug(f\"No or invalid path found in cache for collection <{uid}>.\")\n\n        # Try to find the collection in the search paths\n        for root_dir in PathSet(search_paths) or self.search_paths:\n            log.debug(f\"Searching for collection <{uid}> in <{root_dir}>\")\n            paths_found = _find_collection(uid, Path(root_dir))\n\n            if len(paths_found) > 0:  # If at least one file is found\n                if len(paths_found) > 1:\n                    log.warning(\n                        f\"Multiple collections found for {uid}. Using the first one.\"\n                        f\"\\n{paths_found}\"\n                    )\n\n                # Store the collection in the cache\n                self.upsert_collection(uid, paths_found[0])\n                return paths_found[0]\n\n        raise FileNotFoundError(f\"Database with {uid} was not found.\")\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def resolve_uid(self, path: StrPath) -> CollectionUID:\n        \"\"\"Resolve the UID of a collection from a path.\n\n        Returns the UID of the collection or a new UID if it can't be\n        determined.\n\n        Args:\n            path: Path of the collection\n        \"\"\"\n        path = Path(path)\n        cached_uid: str | None = self._s.execute(\n            select(CollectionORM.uid).where(CollectionORM.path == path.as_posix())\n        ).scalar()\n        if cached_uid and _validate_path(path, cached_uid):\n            return CollectionUID(cached_uid)\n\n        log.debug(f\"No or invalid uid found in cache for collection <{path}>.\")\n\n        identified_uid = _find_uid_from_path(path)\n        uid = CollectionUID(\n            identified_uid\n        )  # Note: this generates a new UID if none is found\n        self._s.execute(\n            CollectionORM.upsert({\"uid\": uid, \"path\": path.absolute().as_posix()})\n        )\n        return uid\n\n    @_sql_transaction\n    def sync_collection(\n        self, uid: str, path: Optional[StrPath] = None, *, force_all: bool = False\n    ) -> None:\n        \"\"\"Sync the table with the file system.\n\n        Iterates through the simulations in the collection and updates the\n        metadata and parameters if the HDF5 file has been modified.\n\n        Args:\n            uid: UID of the collection\n            path (Optional): Path of the collection\n        \"\"\"\n        path = Path(path or self.resolve_path(uid)).absolute()\n        # Get all simulation names in the file system\n        all_simulations_fs = set(\n            (\n                i.name\n                for i in path.iterdir()\n                if i.is_dir() and i.joinpath(constants.HDF_DATA_FILE_NAME).is_file()\n            )\n        )\n\n        collection = self._s.get(CollectionORM, uid)\n\n        if collection:\n            for simulation in collection.simulations:\n                if simulation.name not in all_simulations_fs:\n                    self._s.delete(simulation)\n                    continue\n\n                # if the HDF5 file has not been modified since the last sync,\n                # remove the simulation from the active update set\n                if force_all:\n                    continue\n                h5_file = path.joinpath(simulation.name, constants.HDF_DATA_FILE_NAME)\n                if (  # type: ignore\n                    datetime.fromtimestamp(h5_file.stat().st_mtime)\n                    <= simulation.modified_at\n                ):\n                    all_simulations_fs.remove(simulation.name)\n\n        for name in all_simulations_fs:\n            log.debug(f\"Syncing simulation {name} in collection {uid}.\")\n            self.upsert_simulation(\n                collection_uid=uid, simulation_name=name, collection_path=path\n            )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_collections(self) -> Sequence[CollectionORM]:\n        \"\"\"Return all collections in the index. Eagerly loads the simulations\n        and its parameters.\n        \"\"\"\n        return (\n            self._s.execute(\n                select(CollectionORM).options(\n                    joinedload(CollectionORM.simulations).subqueryload(\n                        SimulationORM.parameters\n                    )\n                )\n            )\n            .unique()\n            .scalars()\n            .all()\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def collection(self, uid: str) -> CollectionORM | None:\n        \"\"\"Return a collection from the index.\n\n        Args:\n            uid: UID of the collection\n        \"\"\"\n        log.debug(\"Fetching collection from cache.\")\n        return (\n            self._s.execute(\n                select(CollectionORM)\n                .where(CollectionORM.uid == uid)\n                .options(\n                    joinedload(CollectionORM.simulations).subqueryload(\n                        SimulationORM.parameters\n                    )\n                )\n            )\n            .unique()\n            .scalar()\n        )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_simulations(self) -> Sequence[SimulationORM]:\n        \"\"\"Return all simulations in the index. Eagerly loads the parameters.\"\"\"\n        return (\n            self._s.execute(\n                select(SimulationORM).options(joinedload(SimulationORM.parameters))\n            )\n            .unique()\n            .scalars()\n            .all()\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def simulation(self, collection_uid: str, name: str) -> SimulationORM | None:\n        \"\"\"Return a simulation from the index.\n\n        Args:\n            collection_uid: UID of the collection\n            name: Name of the simulation\n        \"\"\"\n        return (\n            self._s.execute(\n                select(SimulationORM)\n                .where(\n                    SimulationORM.collection_uid == collection_uid,\n                    SimulationORM.name == name,\n                )\n                .options(joinedload(SimulationORM.parameters))\n            )\n            .unique()\n            .scalar()\n        )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_parameters(self) -> Sequence[ParameterORM]:\n        \"\"\"Return all parameters in the index.\"\"\"\n        return self._s.execute(select(ParameterORM)).scalars().all()\n\n    @_sql_transaction\n    def _drop_collection(self, uid: str) -> None:\n        \"\"\"Drop a collection from the cache.\n\n        Args:\n            uid: UID of the collection\n        \"\"\"\n        self._s.execute(delete(CollectionORM).where(CollectionORM.uid == uid))\n\n    @_sql_transaction\n    def _drop_simulation(self, collection_uid: str, simulation_name: str) -> None:\n        \"\"\"Drop a simulation from the cache.\n\n        Args:\n            collection_uid: UID of the collection\n            simulation_name: Name of the simulation\n        \"\"\"\n        stmt = delete(SimulationORM).where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n        self._s.execute(stmt)\n\n    @_sql_transaction\n    def upsert_collection(self, uid: str, path: Path) -> None:\n        \"\"\"Cache a collection in the index.\n\n        Args:\n            uid: UID of the collection\n            path: Path of the collection\n        \"\"\"\n        self._s.execute(CollectionORM.upsert({\"uid\": uid, \"path\": path.as_posix()}))\n\n    @_sql_transaction\n    def upsert_simulation(\n        self,\n        collection_uid: str,\n        simulation_name: str,\n        parameters: Optional[Mapping[Any, Any]] = None,\n        metadata: Optional[Mapping[Any, Any]] = None,\n        *,\n        collection_path: Optional[StrPath] = None,\n    ) -> None:\n        \"\"\"Cache a simulation from a collection.\n\n        Args:\n            collection_uid: UID of the collection\n            simulation_name: Name of the simulation\n            collection_path (Optional): Path of the collection\n        \"\"\"\n        collection_path = Path(collection_path or self.resolve_path(collection_uid))\n\n        if metadata is None and parameters is None:\n            from bamboost.core.simulation.base import Simulation\n\n            # if neither metadata nor parameters are provided, read them from the HDF5 file\n            # temp change the communicator to MPI.COMM_SELF -> because here is only\n            # executed on rank 0\n            # 04.03.25: unclear whether passing comm=MPI.COMM_SELF is sufficient in itself\n            # 26.03.25: removed the context manager, because it is included in the metaclass\n            sim = Simulation(\n                simulation_name,\n                collection_path,\n                index=self,\n                collection_uid=collection_uid,\n            )\n            with sim._file.open(\"r\"):\n                metadata, parameters = sim.metadata._dict, sim.parameters._dict\n\n        # Upsert the simulation table\n        sim_id = self._s.execute(\n            SimulationORM.upsert(\n                {\n                    \"collection_uid\": collection_uid,\n                    \"name\": simulation_name,\n                    \"modified_at\": datetime.now(),\n                    **(metadata or {}),\n                }\n            )\n        ).scalar_one()\n\n        # Upsert the parameters table\n        if parameters:\n            self._s.execute(\n                ParameterORM.upsert(\n                    [\n                        {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                        for k, v in parameters.items()\n                    ]\n                )\n            )\n\n    @_sql_transaction\n    def update_simulation_metadata(\n        self, collection_uid: str, simulation_name: str, data: Mapping\n    ) -> None:\n        \"\"\"Update the metadata of a simulation by passing it as a dict.\n\n        Args:\n            data: Dictionary with new data\n        \"\"\"\n        self._s.execute(\n            SimulationORM.upsert(\n                {\"collection_uid\": collection_uid, \"name\": simulation_name, **data}\n            )\n        )\n\n    @_sql_transaction\n    def update_simulation_parameters(\n        self,\n        collection_uid: str,\n        simulation_name: str,\n        parameters: SimulationParameterT,\n    ) -> None:\n        \"\"\"Update the parameters of a simulation by passing it as a dict.\n\n        Args:\n            parameters: Dictionary with new parameters\n        \"\"\"\n        sim_id = self._s.execute(\n            select(SimulationORM.id).where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == simulation_name,\n            )\n        ).scalar_one()\n\n        self._s.execute(\n            ParameterORM.upsert(\n                [\n                    {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                    for k, v in parameters.items()\n                ]\n            )\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_collection_path(\n        self,\n        uid: str,\n    ) -> Optional[Path]:\n        res = self._s.execute(\n            select(CollectionORM.path).where(CollectionORM.uid == uid)\n        ).scalar()\n        return Path(res) if res else None\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_collections(self) -> Sequence[CollectionORM]:\n        return self._s.execute(select(CollectionORM)).scalars().all()\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_simulation(\n        self, collection_uid: CollectionUID | str, simulation_name: str\n    ) -> SimulationORM | None:\n        return self._s.execute(\n            select(SimulationORM)\n            .where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == simulation_name,\n            )\n            .options(joinedload(SimulationORM.parameters))\n        ).scalar()",
              "inherited_members": {}
            }
          },
          "functions": {
            "_sql_transaction": {
              "name": "_sql_transaction",
              "path": "bamboost.index.base._sql_transaction",
              "signature": "(func) -> Callable[Concatenate[Index, _P], _T]",
              "description": "Decorator to add a session to the function signature.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.index.base.Index, bamboost._typing._P], bamboost._typing._T]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _sql_transaction(\n    func: Callable[Concatenate[Index, _P], _T],\n) -> Callable[Concatenate[Index, _P], _T]:\n    \"\"\"Decorator to add a session to the function signature.\n\n    Args:\n        func: The function to decorate.\n    \"\"\"\n\n    @wraps(func)\n    def inner(self: Index, *args: _P.args, **kwargs: _P.kwargs) -> Any:\n        with self.sql_transaction():\n            return func(self, *args, **kwargs)\n\n    return inner"
            },
            "simulation_metadata_from_h5": {
              "name": "simulation_metadata_from_h5",
              "path": "bamboost.index.base.simulation_metadata_from_h5",
              "signature": "(file) -> Tuple[SimulationMetadataT, SimulationParameterT]",
              "description": "Extract metadata and parameters from a BAMBOOST simulation HDF5 file.\n\nReads the metadata and parameters from the HDF5 file and returns them as a\ntuple.",
              "parameters": [
                {
                  "name": "file",
                  "annotation": "pathlib.Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Path to the HDF5 file."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def simulation_metadata_from_h5(\n    file: Path,\n) -> Tuple[SimulationMetadataT, SimulationParameterT]:\n    \"\"\"Extract metadata and parameters from a BAMBOOST simulation HDF5 file.\n\n    Reads the metadata and parameters from the HDF5 file and returns them as a\n    tuple.\n\n    Args:\n        file: Path to the HDF5 file.\n    \"\"\"\n    if not file.is_file():\n        raise FileNotFoundError(f\"File not found: {file}\")\n\n    from bamboost.core.hdf5.file import HDF5File\n\n    with HDF5File(file).open(\"r\") as f:\n        meta: SimulationMetadataT = {\n            \"created_at\": datetime.fromisoformat(f.attrs.get(\"created_at\", 0))\n            if f.attrs.get(\"created_at\")\n            else datetime.now(),\n            \"modified_at\": datetime.fromtimestamp(file.stat().st_mtime),\n            \"description\": f.attrs.get(\"notes\", \"\"),\n            \"status\": f.attrs.get(\"status\", \"\"),\n        }\n        params: SimulationParameterT = dict(f[\"parameters\"].attrs)\n\n        return meta, params"
            },
            "create_identifier_file": {
              "name": "create_identifier_file",
              "path": "bamboost.index.base.create_identifier_file",
              "signature": "(path, uid) -> None",
              "description": "Create an identifier file in the collection directory.",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "bamboost._typing.StrPath",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Path to the collection directory"
                    }
                  ]
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID of the collection"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def create_identifier_file(path: StrPath, uid: str) -> None:\n    \"\"\"Create an identifier file in the collection directory.\n\n    Args:\n        path: Path to the collection directory\n        uid: UID of the collection\n    \"\"\"\n    path = Path(path)\n    with open(path.joinpath(get_identifier_filename(uid)), \"w\") as f:\n        f.write(\"Date of creation: \" + str(datetime.now()))"
            },
            "get_identifier_filename": {
              "name": "get_identifier_filename",
              "path": "bamboost.index.base.get_identifier_filename",
              "signature": "(uid) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def get_identifier_filename(uid: str) -> str:\n    return IDENTIFIER_PREFIX + IDENTIFIER_SEPARATOR + uid"
            },
            "_validate_path": {
              "name": "_validate_path",
              "path": "bamboost.index.base._validate_path",
              "signature": "(path, uid) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": null
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _validate_path(path: Path, uid: str) -> bool:\n    return path.is_dir() and path.joinpath(get_identifier_filename(uid)).is_file()"
            },
            "_find_uid_from_path": {
              "name": "_find_uid_from_path",
              "path": "bamboost.index.base._find_uid_from_path",
              "signature": "(path) -> Optional[str]",
              "description": null,
              "parameters": [
                {
                  "name": "path",
                  "annotation": "pathlib.Path",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _find_uid_from_path(path: Path) -> Optional[str]:\n    try:\n        return path.glob(f\"{IDENTIFIER_PREFIX}*\").__next__().name.rsplit(\"-\", 1)[1]\n    except StopIteration:\n        return None"
            },
            "_find_collection": {
              "name": "_find_collection",
              "path": "bamboost.index.base._find_collection",
              "signature": "(uid, root_dir) -> tuple[Path, ...]",
              "description": "Find the collection with UID under given root_dir.",
              "parameters": [
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID to search for"
                    }
                  ]
                },
                {
                  "name": "root_dir",
                  "annotation": "pathlib.Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "root directory for search"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _find_collection(uid: str, root_dir: Path) -> tuple[Path, ...]:\n    \"\"\"Find the collection with UID under given root_dir.\n\n    Args:\n        uid: UID to search for\n        root_dir: root directory for search\n    \"\"\"\n    return tuple(\n        Path(i).parent for i in _find_files(get_identifier_filename(uid), root_dir)\n    )"
            },
            "_find_files": {
              "name": "_find_files",
              "path": "bamboost.index.base._find_files",
              "signature": "(pattern, root_dir, exclude=None) -> Tuple[Path, ...]",
              "description": "Locate every file matching *pattern* under *root_dir* while **pruning**\ndirectory names listed in *exclude* (exact-match on the final path part).\n\nReturns an immutable tuple of absolute paths (str) just like the POSIX helper.",
              "parameters": [
                {
                  "name": "pattern",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "root_dir",
                  "annotation": "str | os.os.PathLike",
                  "description": null,
                  "value": null
                },
                {
                  "name": "exclude",
                  "annotation": "typing.Iterable[str] | None",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _find_files(\n    pattern: str,\n    root_dir: str | os.PathLike,\n    exclude: Iterable[str] | None = None,\n) -> Tuple[Path, ...]:\n    \"\"\"\n    Locate every file matching *pattern* under *root_dir* while **pruning**\n    directory names listed in *exclude* (exact-match on the final path part).\n\n    Returns an immutable tuple of absolute paths (str) just like the POSIX helper.\n    \"\"\"\n    root = Path(root_dir)\n    hits: list[Path] = []\n\n    if exclude is None:\n        exclude = config.index.excludeDirs\n\n    for base, dirnames, filenames in os.walk(root, topdown=True):\n        # --- prune in\u2013place so the walker never descends further ---\n        dirnames[:] = [d for d in dirnames if d not in exclude]\n\n        for fname in filenames:\n            if fnmatch.fnmatch(fname, pattern):\n                hits.append(Path(base, fname))\n\n    return tuple(hits)"
            },
            "_scan_directory_for_collections": {
              "name": "_scan_directory_for_collections",
              "path": "bamboost.index.base._scan_directory_for_collections",
              "signature": "(root_dir) -> tuple[tuple[str, Path], ...]",
              "description": "Scan the directory for collections.",
              "parameters": [
                {
                  "name": "root_dir",
                  "annotation": "pathlib.Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Directory to scan for collections"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "tuple[tuple[str, pathlib.Path], ...]",
                "description": "Tuple of tuples with the UID and path of the collection"
              },
              "docstring": [],
              "source": "def _scan_directory_for_collections(root_dir: Path) -> tuple[tuple[str, Path], ...]:\n    \"\"\"Scan the directory for collections.\n\n    Args:\n        root_dir: Directory to scan for collections\n\n    Returns:\n        Tuple of tuples with the UID and path of the collection\n    \"\"\"\n\n    log.debug(f\"Scanning {root_dir}\")\n\n    if not root_dir.exists():\n        log.warning(f\"Path does not exist: {root_dir}\")\n        return ()\n\n    found_indicator_files = _find_files(\n        get_identifier_filename(\"*\"), root_dir.as_posix()\n    )\n\n    if not found_indicator_files:\n        log.info(f\"No collections found in {root_dir}\")\n        return ()\n\n    return tuple(\n        (i.name.rsplit(IDENTIFIER_SEPARATOR, 1)[-1], i.parent)\n        for i in found_indicator_files\n    )"
            }
          }
        },
        "_filtering": {
          "name": "_filtering",
          "path": "bamboost.index._filtering",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/index/_filtering.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "Operand",
              "annotation": null,
              "description": null,
              "value": "typing.Union['_Key', 'Operator', str, float, int]"
            }
          ],
          "modules": {},
          "classes": {
            "_SupportsOperators": {
              "name": "_SupportsOperators",
              "path": "bamboost.index._filtering._SupportsOperators",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__lt__": {
                  "name": "__lt__",
                  "path": "bamboost.index._filtering._SupportsOperators.__lt__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __lt__(self, other: Operand) -> \"Operator\": ..."
                },
                "__le__": {
                  "name": "__le__",
                  "path": "bamboost.index._filtering._SupportsOperators.__le__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __le__(self, other: Operand) -> \"Operator\": ..."
                },
                "__eq__": {
                  "name": "__eq__",
                  "path": "bamboost.index._filtering._SupportsOperators.__eq__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __eq__(self, other: Operand) -> \"Operator\": ..."
                },
                "__ne__": {
                  "name": "__ne__",
                  "path": "bamboost.index._filtering._SupportsOperators.__ne__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __ne__(self, other: Operand) -> \"Operator\": ..."
                },
                "__gt__": {
                  "name": "__gt__",
                  "path": "bamboost.index._filtering._SupportsOperators.__gt__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __gt__(self, other: Operand) -> \"Operator\": ..."
                },
                "__ge__": {
                  "name": "__ge__",
                  "path": "bamboost.index._filtering._SupportsOperators.__ge__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __ge__(self, other: Operand) -> \"Operator\": ..."
                },
                "__add__": {
                  "name": "__add__",
                  "path": "bamboost.index._filtering._SupportsOperators.__add__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __add__(self, other: Operand) -> \"Operator\": ..."
                },
                "__sub__": {
                  "name": "__sub__",
                  "path": "bamboost.index._filtering._SupportsOperators.__sub__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __sub__(self, other: Operand) -> \"Operator\": ..."
                },
                "__mul__": {
                  "name": "__mul__",
                  "path": "bamboost.index._filtering._SupportsOperators.__mul__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __mul__(self, other: Operand) -> \"Operator\": ..."
                },
                "__truediv__": {
                  "name": "__truediv__",
                  "path": "bamboost.index._filtering._SupportsOperators.__truediv__",
                  "signature": "(self, other) -> 'Operator'",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Operand",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __truediv__(self, other: Operand) -> \"Operator\": ..."
                }
              },
              "source": "class _SupportsOperators:\n    def __lt__(self, other: Operand) -> \"Operator\": ...\n    def __le__(self, other: Operand) -> \"Operator\": ...\n    def __eq__(self, other: Operand) -> \"Operator\": ...\n    def __ne__(self, other: Operand) -> \"Operator\": ...\n    def __gt__(self, other: Operand) -> \"Operator\": ...\n    def __ge__(self, other: Operand) -> \"Operator\": ...\n    def __add__(self, other: Operand) -> \"Operator\": ...\n    def __sub__(self, other: Operand) -> \"Operator\": ...\n    def __mul__(self, other: Operand) -> \"Operator\": ...\n    def __truediv__(self, other: Operand) -> \"Operator\": ...",
              "inherited_members": {}
            },
            "Operator": {
              "name": "Operator",
              "path": "bamboost.index._filtering.Operator",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "op",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "a",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "b",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "_op",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index._filtering.Operator(op)"
                },
                {
                  "name": "_a",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index._filtering.Operator(a)"
                },
                {
                  "name": "_b",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index._filtering.Operator(b)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index._filtering.Operator.__init__",
                  "signature": "(self, op, a, b=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "op",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "a",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "b",
                      "annotation": null,
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, op, a, b=None):\n    self._op = op\n    self._a = a\n    self._b = b"
                },
                "evaluate": {
                  "name": "evaluate",
                  "path": "bamboost.index._filtering.Operator.evaluate",
                  "signature": "(self, item) -> bool",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "item",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def evaluate(self, item: dict) -> bool:\n    def resolve(val):\n        if isinstance(val, _Key):\n            return item[val._value]\n        elif isinstance(val, Operator):\n            return val.evaluate(item)\n        return val\n\n    if self._b is None:\n        return self._op(resolve(self._a))\n    return self._op(resolve(self._a), resolve(self._b))"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index._filtering.Operator.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Operation({self._a} {self._op.__name__} {self._b})\""
                }
              },
              "source": "@add_operators\nclass Operator(_SupportsOperators):\n    @overload\n    def __init__(\n        self,\n        op: Callable[[Any, Any], bool],\n        a: Number | str | _Key | Operator,\n        b: Number | str | _Key | Operator,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, op: Callable[[Any], bool], a: Number | str | _Key | Operator\n    ) -> None: ...\n    def __init__(self, op, a, b=None):\n        self._op = op\n        self._a = a\n        self._b = b\n\n    def evaluate(self, item: dict) -> bool:\n        def resolve(val):\n            if isinstance(val, _Key):\n                return item[val._value]\n            elif isinstance(val, Operator):\n                return val.evaluate(item)\n            return val\n\n        if self._b is None:\n            return self._op(resolve(self._a))\n        return self._op(resolve(self._a), resolve(self._b))\n\n    def __repr__(self) -> str:\n        return f\"Operation({self._a} {self._op.__name__} {self._b})\"",
              "inherited_members": {
                "bamboost.index._filtering._SupportsOperators": [
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__lt__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__le__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__eq__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__ne__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__gt__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__ge__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__add__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__sub__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__mul__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__truediv__"
                  }
                ]
              }
            },
            "_Key": {
              "name": "_Key",
              "path": "bamboost.index._filtering._Key",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "_value",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index._filtering._Key(key)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index._filtering._Key.__init__",
                  "signature": "(self, key) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, key: str) -> None:\n    self._value = key"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index._filtering._Key.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Key({self._value})\""
                }
              },
              "source": "@add_operators\nclass _Key(_SupportsOperators):\n    def __init__(self, key: str) -> None:\n        self._value = key\n\n    def __repr__(self) -> str:\n        return f\"Key({self._value})\"",
              "inherited_members": {
                "bamboost.index._filtering._SupportsOperators": [
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__lt__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__le__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__eq__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__ne__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__gt__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__ge__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__add__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__sub__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__mul__"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index._filtering._SupportsOperators.__truediv__"
                  }
                ]
              }
            },
            "Filter": {
              "name": "Filter",
              "path": "bamboost.index._filtering.Filter",
              "description": "Filter applied to a collection.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "operators",
                  "annotation": "bamboost.index._filtering.Operator",
                  "description": null,
                  "value": "()"
                }
              ],
              "attributes": [
                {
                  "name": "_ops",
                  "annotation": "typing.Sequence[bamboost.index._filtering.Operator]",
                  "description": null,
                  "value": "bamboost.index._filtering.Filter(operators)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index._filtering.Filter.__init__",
                  "signature": "(self, *operators) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "operators",
                      "annotation": "bamboost.index._filtering.Operator",
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *operators: Operator) -> None:\n    self._ops: Sequence[Operator] = operators"
                },
                "__and__": {
                  "name": "__and__",
                  "path": "bamboost.index._filtering.Filter.__and__",
                  "signature": "(self, other) -> Filter",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "other",
                      "annotation": "bamboost.index._filtering.Filter | None",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __and__(self, other: Filter | None) -> Filter:\n    return Filter(*self._ops, *other._ops) if other else self"
                },
                "apply": {
                  "name": "apply",
                  "path": "bamboost.index._filtering.Filter.apply",
                  "signature": "(self, df) -> DataFrame | Series | Any",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "df",
                      "annotation": "pandas.DataFrame",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def apply(self, df: DataFrame) -> DataFrame | Series | Any:\n    mask = df.apply(lambda row: all(op.evaluate(row) for op in self._ops), axis=1)\n    return df[mask]"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index._filtering.Filter.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return \"Filter({})\".format(\" & \".join(str(op) for op in self._ops))"
                }
              },
              "source": "class Filter:\n    \"\"\"Filter applied to a collection.\"\"\"\n\n    def __init__(self, *operators: Operator) -> None:\n        self._ops: Sequence[Operator] = operators\n\n    def __and__(self, other: Filter | None) -> Filter:\n        return Filter(*self._ops, *other._ops) if other else self\n\n    def apply(self, df: DataFrame) -> DataFrame | Series | Any:\n        mask = df.apply(lambda row: all(op.evaluate(row) for op in self._ops), axis=1)\n        return df[mask]\n\n    def __repr__(self) -> str:\n        return \"Filter({})\".format(\" & \".join(str(op) for op in self._ops))",
              "inherited_members": {}
            }
          },
          "functions": {
            "add_operators": {
              "name": "add_operators",
              "path": "bamboost.index._filtering.add_operators",
              "signature": "(cls)",
              "description": null,
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def add_operators(cls):\n    ops = {\n        \"__lt__\": operator.lt,\n        \"__le__\": operator.le,\n        \"__eq__\": operator.eq,\n        \"__ne__\": operator.ne,\n        \"__gt__\": operator.gt,\n        \"__ge__\": operator.ge,\n        \"__add__\": operator.add,\n        \"__sub__\": operator.sub,\n        \"__mul__\": operator.mul,\n        \"__truediv__\": operator.truediv,\n        \"__floordiv__\": operator.floordiv,\n        \"__mod__\": operator.mod,\n        \"__pow__\": operator.pow,\n    }\n\n    def make_op(op_func):\n        def method(self, other):\n            return Operator(op_func, self, other)\n\n        return method\n\n    for name, func in ops.items():\n        setattr(cls, name, make_op(func))\n\n    return cls"
            }
          }
        },
        "sqlmodel": {
          "name": "sqlmodel",
          "path": "bamboost.index.sqlmodel",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/index/sqlmodel.py",
          "description": "SQLAlchemy ORM models for the bamboost index database.\n\nThe SQL model consists of three tables:\n- `collections`: Contains information about the collections, namely uids and corresponding\n  paths.\n- `simulations`: Contains information about the simulations, including names, statuses,\n  and parameters.\n- `parameters`: Contains the parameters associated with the simulations.\n\nSimulations are linked to collections via a foreign key, and parameters are linked to\nsimulations via foreign keys.",
          "docstring": [],
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild(__name__)"
            },
            {
              "name": "_Base",
              "annotation": null,
              "description": null,
              "value": "declarative_base()"
            },
            {
              "name": "create_all",
              "annotation": null,
              "description": null,
              "value": "bamboost.index.sqlmodel._Base.bamboost.index.sqlmodel._Base.metadata.bamboost.index.sqlmodel._Base.metadata.create_all"
            },
            {
              "name": "_APIMethod",
              "annotation": null,
              "description": null,
              "value": "TypeVar('_APIMethod', bound=Callable[..., Any])"
            },
            {
              "name": "_encoders",
              "annotation": "typing.Dict[type, typing.Callable[[typing.Any], typing.Any]]",
              "description": null,
              "value": "{datetime.datetime: lambda obj: obj.obj.isoformat(), complex: lambda obj: {'real': obj.obj.real, 'imag': obj.obj.imag}}"
            },
            {
              "name": "_decoders",
              "annotation": "typing.Dict[type, typing.Callable[[typing.Any], typing.Any]]",
              "description": null,
              "value": "{datetime.datetime: lambda obj: datetime.datetime.datetime.datetime.fromisoformat(obj), complex: lambda obj: complex(obj['real'], obj['imag'])}"
            }
          ],
          "modules": {},
          "classes": {
            "SqliteJSONEncoder": {
              "name": "SqliteJSONEncoder",
              "path": "bamboost.index.sqlmodel.SqliteJSONEncoder",
              "description": "Custom JSON encoder for numpy types.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "default": {
                  "name": "default",
                  "path": "bamboost.index.sqlmodel.SqliteJSONEncoder.default",
                  "signature": "(self, obj) -> Any",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "obj",
                      "annotation": "typing.Any",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def default(self, obj: Any) -> Any:\n    import numpy as np\n\n    if isinstance(obj, np.ndarray):\n        return obj.tolist()\n    if isinstance(obj, (np.generic, np.number)):\n        return obj.item()\n\n    for typ, encoder in _encoders.items():\n        if isinstance(obj, typ):\n            return {\"__type__\": typ.__name__, \"__value__\": encoder(obj)}\n\n    try:\n        return super().default(obj)\n    except TypeError:\n        # Handle objects that cannot be serialized by default\n        return f\"{str(obj)} (unserializable)\""
                }
              },
              "source": "class SqliteJSONEncoder(json.JSONEncoder):\n    \"\"\"Custom JSON encoder for numpy types.\"\"\"\n\n    def default(self, obj: Any) -> Any:\n        import numpy as np\n\n        if isinstance(obj, np.ndarray):\n            return obj.tolist()\n        if isinstance(obj, (np.generic, np.number)):\n            return obj.item()\n\n        for typ, encoder in _encoders.items():\n            if isinstance(obj, typ):\n                return {\"__type__\": typ.__name__, \"__value__\": encoder(obj)}\n\n        try:\n            return super().default(obj)\n        except TypeError:\n            # Handle objects that cannot be serialized by default\n            return f\"{str(obj)} (unserializable)\"",
              "inherited_members": {}
            },
            "_CollectionMixin": {
              "name": "_CollectionMixin",
              "path": "bamboost.index.sqlmodel._CollectionMixin",
              "description": "Methods for collections.",
              "parameters": [],
              "attributes": [
                {
                  "name": "simulations",
                  "annotation": "sqlalchemy.orm.Mapped[typing.List[bamboost.index.sqlmodel.SimulationORM]]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parameters",
                  "annotation": "typing.List[bamboost.index.sqlmodel.ParameterORM]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Retrieves all parameters associated with the collections's simulations."
                    },
                    {
                      "kind": "returns",
                      "value": [
                        {
                          "name": "",
                          "annotation": "typing.List[bamboost.index.sqlmodel.ParameterORM]",
                          "description": "List of parameters belonging to simulations in the collection."
                        }
                      ]
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "get_parameter_keys": {
                  "name": "get_parameter_keys",
                  "path": "bamboost.index.sqlmodel._CollectionMixin.get_parameter_keys",
                  "signature": "(self) -> tuple[list[str], list[int]]",
                  "description": "Extracts unique parameter keys and their occurences across all simulations.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "tuple[list[str], list[int]]",
                    "description": "A tuple containing a list of unique parameter keys and a corresponding count list."
                  },
                  "docstring": [],
                  "source": "def get_parameter_keys(self) -> tuple[list[str], list[int]]:\n    \"\"\"Extracts unique parameter keys and their occurences across all simulations.\n\n    Returns:\n        A tuple containing a list of unique parameter keys and a corresponding count list.\n    \"\"\"\n    unique_params = list(set(p.key for p in self.parameters))\n    counts = [sum(p.key == k for p in self.parameters) for k in unique_params]\n    return unique_params, counts"
                },
                "to_pandas": {
                  "name": "to_pandas",
                  "path": "bamboost.index.sqlmodel._CollectionMixin.to_pandas",
                  "signature": "(self, flatten=True) -> 'DataFrame'",
                  "description": "Converts the collection to a pandas DataFrame.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "flatten",
                      "annotation": "bool",
                      "description": [
                        {
                          "kind": "text",
                          "value": "If True, flatten dictionaries with dot notation."
                        }
                      ],
                      "value": "True"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "'DataFrame'",
                    "description": "pandas.DataFrame: DataFrame representation of the collection."
                  },
                  "docstring": [],
                  "source": "def to_pandas(self, flatten: bool = True) -> \"DataFrame\":\n    \"\"\"Converts the collection to a pandas DataFrame.\n\n    Args:\n        flatten: If True, flatten dictionaries with dot notation.\n\n    Returns:\n        pandas.DataFrame: DataFrame representation of the collection.\n    \"\"\"\n    import pandas as pd\n\n    if flatten:\n        return pd.DataFrame.from_records(\n            [\n                flatten_dict(sim.as_dict(standalone=False))\n                for sim in self.simulations\n            ]\n        )\n    else:\n        return pd.DataFrame.from_records(\n            [sim.as_dict(standalone=False) for sim in self.simulations]\n        )"
                }
              },
              "source": "class _CollectionMixin:\n    \"\"\"Methods for collections.\"\"\"\n\n    simulations: Mapped[List[SimulationORM]]\n\n    @property\n    def parameters(self) -> List[ParameterORM]:\n        \"\"\"Retrieves all parameters associated with the collections's simulations.\n\n        Returns:\n            List of parameters belonging to simulations in the collection.\n        \"\"\"\n        return [p for s in self.simulations for p in s.parameters]\n\n    def get_parameter_keys(self) -> tuple[list[str], list[int]]:\n        \"\"\"Extracts unique parameter keys and their occurences across all simulations.\n\n        Returns:\n            A tuple containing a list of unique parameter keys and a corresponding count list.\n        \"\"\"\n        unique_params = list(set(p.key for p in self.parameters))\n        counts = [sum(p.key == k for p in self.parameters) for k in unique_params]\n        return unique_params, counts\n\n    def to_pandas(self, flatten: bool = True) -> \"DataFrame\":\n        \"\"\"Converts the collection to a pandas DataFrame.\n\n        Args:\n            flatten: If True, flatten dictionaries with dot notation.\n\n        Returns:\n            pandas.DataFrame: DataFrame representation of the collection.\n        \"\"\"\n        import pandas as pd\n\n        if flatten:\n            return pd.DataFrame.from_records(\n                [\n                    flatten_dict(sim.as_dict(standalone=False))\n                    for sim in self.simulations\n                ]\n            )\n        else:\n            return pd.DataFrame.from_records(\n                [sim.as_dict(standalone=False) for sim in self.simulations]\n            )",
              "inherited_members": {}
            },
            "CollectionORM": {
              "name": "CollectionORM",
              "path": "bamboost.index.sqlmodel.CollectionORM",
              "description": "ORM model representing a collection of simulations.",
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.constants.TABLENAME_COLLECTIONS"
                },
                {
                  "name": "uid",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Unique identifier for the collection (primary key)"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(primary_key=True)"
                },
                {
                  "name": "path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "file system path where the collection is stored."
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(String)"
                },
                {
                  "name": "simulations",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Relationship to the associated simulations, with cascade delete-orphan."
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[typing.List[bamboost.index.sqlmodel.SimulationORM]]",
                  "value": "relationship('SimulationORM', back_populates='collection', cascade='all, delete-orphan')"
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.CollectionORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Collection {self.uid} {self.path}\""
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.index.sqlmodel.CollectionORM._repr_html_",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    return f\"Collection <b>{self.uid}</b><br/>Location: <a href={self.path}><i>{self.path}</i></a>\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.CollectionORM.upsert",
                  "signature": "(cls, data) -> Insert",
                  "description": "Inserts or updates collection records based on the unique uid.",
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "typing.Sequence[typing.Dict[str, str]] | typing.Dict[str, str]",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Data to be upserted. Can be a single dictionary or a sequence of dictionaries."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.Insert",
                    "description": "SQLAlchemy insert statement with conflict resolution."
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[Dict[str, str]] | Dict[str, str]) -> Insert:\n    \"\"\"Inserts or updates collection records based on the unique uid.\n\n    Args:\n        data: Data to be upserted. Can be a single dictionary or a sequence of dictionaries.\n\n    Returns:\n        SQLAlchemy insert statement with conflict resolution.\n    \"\"\"\n    stmt = insert(cls).values(data)\n    return stmt.on_conflict_do_update([\"uid\"], set_=dict(stmt.excluded))"
                }
              },
              "source": "class CollectionORM(_Base, _CollectionMixin):\n    \"\"\"ORM model representing a collection of simulations.\n\n    Attributes:\n        uid: Unique identifier for the collection (primary key)\n        path: file system path where the collection is stored.\n        simulations: Relationship to the associated simulations, with cascade delete-orphan.\n    \"\"\"\n\n    __tablename__ = TABLENAME_COLLECTIONS\n\n    uid: Mapped[str] = mapped_column(primary_key=True)\n    path: Mapped[str] = mapped_column(String)\n\n    # Relationships\n    simulations: Mapped[List[SimulationORM]] = relationship(\n        \"SimulationORM\", back_populates=\"collection\", cascade=\"all, delete-orphan\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Collection {self.uid} {self.path}\"\n\n    def _repr_html_(self) -> str:\n        return f\"Collection <b>{self.uid}</b><br/>Location: <a href={self.path}><i>{self.path}</i></a>\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[Dict[str, str]] | Dict[str, str]) -> Insert:\n        \"\"\"Inserts or updates collection records based on the unique uid.\n\n        Args:\n            data: Data to be upserted. Can be a single dictionary or a sequence of dictionaries.\n\n        Returns:\n            SQLAlchemy insert statement with conflict resolution.\n        \"\"\"\n        stmt = insert(cls).values(data)\n        return stmt.on_conflict_do_update([\"uid\"], set_=dict(stmt.excluded))",
              "inherited_members": {
                "bamboost.index.sqlmodel._CollectionMixin": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.sqlmodel._CollectionMixin.parameters"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.sqlmodel._CollectionMixin.get_parameter_keys"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.sqlmodel._CollectionMixin.to_pandas"
                  }
                ]
              }
            },
            "FilteredCollection": {
              "name": "FilteredCollection",
              "path": "bamboost.index.sqlmodel.FilteredCollection",
              "description": "In-memory filtered view of a CollectionORM.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "base",
                  "annotation": "bamboost.index.sqlmodel.CollectionORM",
                  "description": null,
                  "value": null
                },
                {
                  "name": "filter",
                  "annotation": "bamboost.index._filtering.Filter",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "_base",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index.sqlmodel.FilteredCollection(base)"
                },
                {
                  "name": "_filter",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.index.sqlmodel.FilteredCollection(filter)"
                },
                {
                  "name": "simulations",
                  "annotation": "list[bamboost.index.sqlmodel.SimulationORM]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "List of simulations in the collection that match the filter criteria."
                    }
                  ],
                  "value": null
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index.sqlmodel.FilteredCollection.__init__",
                  "signature": "(self, base, filter)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "base",
                      "annotation": "bamboost.index.sqlmodel.CollectionORM",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "filter",
                      "annotation": "bamboost.index._filtering.Filter",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, base: CollectionORM, filter: Filter):\n    self._base = base\n    self._filter = filter"
                },
                "to_pandas": {
                  "name": "to_pandas",
                  "path": "bamboost.index.sqlmodel.FilteredCollection.to_pandas",
                  "signature": "(self) -> 'DataFrame'",
                  "description": "Converts the collection to a pandas DataFrame.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "'DataFrame'",
                    "description": "pandas.DataFrame: DataFrame representation of the collection."
                  },
                  "docstring": [],
                  "source": "def to_pandas(self) -> \"DataFrame\":\n    \"\"\"Converts the collection to a pandas DataFrame.\n\n    Returns:\n        pandas.DataFrame: DataFrame representation of the collection.\n    \"\"\"\n    import pandas as pd\n\n    df = pd.DataFrame.from_records(\n        [\n            flatten_dict(sim.as_dict(standalone=False))\n            for sim in self._base.simulations\n        ]\n    )\n    return self._filter.apply(df)  # pyright: ignore[reportReturnType]"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.FilteredCollection.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"FilteredCollection {self.uid} with {len(self.simulations)} simulations\""
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.index.sqlmodel.FilteredCollection._repr_html_",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    return f\"<b>FilteredCollection {self.uid}</b><br/>{len(self.simulations)} simulations\""
                }
              },
              "source": "class FilteredCollection(_CollectionMixin):\n    \"\"\"In-memory filtered view of a CollectionORM.\"\"\"\n\n    def __init__(self, base: CollectionORM, filter: Filter):\n        self._base = base\n        self._filter = filter\n\n    @property\n    def simulations(self) -> list[SimulationORM]:\n        \"\"\"List of simulations in the collection that match the filter criteria.\"\"\"\n        df = self.to_pandas()\n        return [sim for sim in self._base.simulations if sim.name in df[\"name\"].values]\n\n    def to_pandas(self) -> \"DataFrame\":\n        \"\"\"Converts the collection to a pandas DataFrame.\n\n        Returns:\n            pandas.DataFrame: DataFrame representation of the collection.\n        \"\"\"\n        import pandas as pd\n\n        df = pd.DataFrame.from_records(\n            [\n                flatten_dict(sim.as_dict(standalone=False))\n                for sim in self._base.simulations\n            ]\n        )\n        return self._filter.apply(df)  # pyright: ignore[reportReturnType]\n\n    @property\n    def uid(self) -> str:\n        return self._base.uid\n\n    @property\n    def path(self) -> str:\n        return self._base.path\n\n    def __repr__(self) -> str:\n        return f\"FilteredCollection {self.uid} with {len(self.simulations)} simulations\"\n\n    def _repr_html_(self) -> str:\n        return f\"<b>FilteredCollection {self.uid}</b><br/>{len(self.simulations)} simulations\"",
              "inherited_members": {
                "bamboost.index.sqlmodel._CollectionMixin": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.index.sqlmodel._CollectionMixin.parameters"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.index.sqlmodel._CollectionMixin.get_parameter_keys"
                  }
                ]
              }
            },
            "SimulationORM": {
              "name": "SimulationORM",
              "path": "bamboost.index.sqlmodel.SimulationORM",
              "description": "ORM model representing a simulation in a collection.",
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.constants.TABLENAME_SIMULATIONS"
                },
                {
                  "name": "__table_args__",
                  "annotation": null,
                  "description": null,
                  "value": "(sqlalchemy.UniqueConstraint('collection_uid', 'name', name='uix_collection_name'),)"
                },
                {
                  "name": "id",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Unique simulation ID (primary key)"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[int]",
                  "value": "mapped_column(primary_key=True, autoincrement=True, unique=True)"
                },
                {
                  "name": "collection_uid",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Foreign key linking to `bamboost.index.sqlmodel.CollectionORM`"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(ForeignKey(CollectionORM.uid))"
                },
                {
                  "name": "name",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Name of the simulation"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(String, nullable=False)"
                },
                {
                  "name": "created_at",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Timestamp when the simulation was created"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[sqlalchemy.DateTime]",
                  "value": "mapped_column(DateTime, nullable=False, default=datetime.now)"
                },
                {
                  "name": "modified_at",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Timestamp when the simulation was last modified"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[sqlalchemy.DateTime]",
                  "value": "mapped_column(DateTime, nullable=False, default=datetime.now)"
                },
                {
                  "name": "description",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Optional description of the simulation"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[typing.Optional[str]]",
                  "value": "mapped_column(String)"
                },
                {
                  "name": "status",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Current status of the simulation"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(String, nullable=False, default='initialized')"
                },
                {
                  "name": "submitted",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Indicates whether the simulation has been submitted"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[bool]",
                  "value": "mapped_column(Boolean, nullable=False, default=False)"
                },
                {
                  "name": "collection",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Relationship to the parent collection"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[bamboost.index.sqlmodel.CollectionORM]",
                  "value": "relationship('CollectionORM', back_populates='simulations')"
                },
                {
                  "name": "parameters",
                  "description": [
                    {
                      "kind": "text",
                      "value": "List of associated parameters"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[typing.List[bamboost.index.sqlmodel.ParameterORM]]",
                  "value": "relationship('ParameterORM', back_populates='simulation', cascade='all, delete-orphan')"
                },
                {
                  "name": "parameter_dict",
                  "annotation": "typing.Dict[str, typing.Any]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return a dictionary of parameters associated with the simulation."
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.SimulationORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Simulation {self.collection_uid}+{self.name} [id: {self.id}]\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.SimulationORM.upsert",
                  "signature": "(cls, data) -> ReturningInsert[Tuple[int]]",
                  "description": "Generate an upsert (insert or update) statement.",
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "typing.Sequence[dict] | dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Data to upsert, either a single record or a sequence of records."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.sql.dml.ReturningInsert[typing.Tuple[int]]",
                    "description": "SQLAlchemy insert statement with conflict resolution. Returning the simulation ID."
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[dict] | dict) -> ReturningInsert[Tuple[int]]:\n    \"\"\"Generate an upsert (insert or update) statement.\n\n    Args:\n        data: Data to upsert, either a single record or a sequence of records.\n\n    Returns:\n        SQLAlchemy insert statement with conflict resolution. Returning the simulation ID.\n    \"\"\"\n    valid_columns = cls.__table__.columns\n\n    def filter_data(record: dict) -> dict:\n        return {k: v for k, v in record.items() if k in valid_columns}\n\n    if isinstance(data, dict):\n        filtered_data = filter_data(data)\n    else:\n        filtered_data = [filter_data(record) for record in data]\n\n    stmt = insert(cls).values(filtered_data)\n\n    # Get keys to update. Do not touch keys that are not in the data.\n    all_keys = (\n        filtered_data.keys()\n        if isinstance(filtered_data, dict)\n        else filtered_data[0].keys()\n    )\n\n    stmt = stmt.on_conflict_do_update(\n        [\"collection_uid\", \"name\"],\n        set_={k: v for k, v in stmt.excluded.items() if k in all_keys},\n    )\n    stmt = stmt.returning(cls.id)\n    return stmt"
                },
                "as_dict_metadata": {
                  "name": "as_dict_metadata",
                  "path": "bamboost.index.sqlmodel.SimulationORM.as_dict_metadata",
                  "signature": "(self) -> Dict[str, Any]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def as_dict_metadata(self) -> Dict[str, Any]:\n    return {k.name: getattr(self, k.name) for k in self.__table__.columns}"
                },
                "as_dict": {
                  "name": "as_dict",
                  "path": "bamboost.index.sqlmodel.SimulationORM.as_dict",
                  "signature": "(self, standalone=True) -> Dict[str, Any]",
                  "description": "Return the simulation as a dictionary.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "standalone",
                      "annotation": "bool",
                      "description": [
                        {
                          "kind": "text",
                          "value": "If False, \"id\", \"collection_uid\", and \"modified_at\" are\nexcluded. Defaults to True."
                        }
                      ],
                      "value": "True"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Dict[str, typing.Any]",
                    "description": "Dictionary representation of the simulation."
                  },
                  "docstring": [],
                  "source": "def as_dict(self, standalone: bool = True) -> Dict[str, Any]:\n    \"\"\"Return the simulation as a dictionary.\n\n    Args:\n        standalone (bool, optional): If False, \"id\", \"collection_uid\", and \"modified_at\" are\n            excluded. Defaults to True.\n\n    Returns:\n        Dictionary representation of the simulation.\n    \"\"\"\n    excluded_columns = (\n        {\n            \"id\",\n            \"collection_uid\",\n            \"modified_at\",\n        }\n        if not standalone\n        else set()\n    )\n    column_names = [\n        c.name for c in self.__table__.columns if c.name not in excluded_columns\n    ]\n\n    return {k: getattr(self, k) for k in column_names} | self.parameter_dict"
                }
              },
              "source": "class SimulationORM(_Base):\n    \"\"\"ORM model representing a simulation in a collection.\n\n    Attributes:\n        id: Unique simulation ID (primary key)\n        collection_uid: Foreign key linking to `bamboost.index.sqlmodel.CollectionORM`\n        name: Name of the simulation\n        created_at: Timestamp when the simulation was created\n        modified_at: Timestamp when the simulation was last modified\n        description: Optional description of the simulation\n        status: Current status of the simulation\n        submitted: Indicates whether the simulation has been submitted\n        collection: Relationship to the parent collection\n        parameters: List of associated parameters\n    \"\"\"\n\n    __tablename__ = TABLENAME_SIMULATIONS\n    __table_args__ = (\n        UniqueConstraint(\"collection_uid\", \"name\", name=\"uix_collection_name\"),\n    )\n\n    class _dataT(TypedDict):\n        collection_uid: str\n        name: str\n        created_at: NotRequired[datetime]\n        modified_at: NotRequired[datetime]\n        description: NotRequired[str]\n        status: NotRequired[str]\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, unique=True)\n    collection_uid: Mapped[str] = mapped_column(ForeignKey(CollectionORM.uid))\n    name: Mapped[str] = mapped_column(String, nullable=False)\n\n    # Metadata\n    created_at: Mapped[DateTime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    modified_at: Mapped[DateTime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    description: Mapped[Optional[str]] = mapped_column(String)\n    status: Mapped[str] = mapped_column(String, nullable=False, default=\"initialized\")\n    submitted: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)\n\n    # Relationships\n    collection: Mapped[CollectionORM] = relationship(\n        \"CollectionORM\", back_populates=\"simulations\"\n    )\n    parameters: Mapped[List[ParameterORM]] = relationship(\n        \"ParameterORM\", back_populates=\"simulation\", cascade=\"all, delete-orphan\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Simulation {self.collection_uid}+{self.name} [id: {self.id}]\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[dict] | dict) -> ReturningInsert[Tuple[int]]:\n        \"\"\"Generate an upsert (insert or update) statement.\n\n        Args:\n            data: Data to upsert, either a single record or a sequence of records.\n\n        Returns:\n            SQLAlchemy insert statement with conflict resolution. Returning the simulation ID.\n        \"\"\"\n        valid_columns = cls.__table__.columns\n\n        def filter_data(record: dict) -> dict:\n            return {k: v for k, v in record.items() if k in valid_columns}\n\n        if isinstance(data, dict):\n            filtered_data = filter_data(data)\n        else:\n            filtered_data = [filter_data(record) for record in data]\n\n        stmt = insert(cls).values(filtered_data)\n\n        # Get keys to update. Do not touch keys that are not in the data.\n        all_keys = (\n            filtered_data.keys()\n            if isinstance(filtered_data, dict)\n            else filtered_data[0].keys()\n        )\n\n        stmt = stmt.on_conflict_do_update(\n            [\"collection_uid\", \"name\"],\n            set_={k: v for k, v in stmt.excluded.items() if k in all_keys},\n        )\n        stmt = stmt.returning(cls.id)\n        return stmt\n\n    def as_dict_metadata(self) -> Dict[str, Any]:\n        return {k.name: getattr(self, k.name) for k in self.__table__.columns}\n\n    def as_dict(self, standalone: bool = True) -> Dict[str, Any]:\n        \"\"\"Return the simulation as a dictionary.\n\n        Args:\n            standalone (bool, optional): If False, \"id\", \"collection_uid\", and \"modified_at\" are\n                excluded. Defaults to True.\n\n        Returns:\n            Dictionary representation of the simulation.\n        \"\"\"\n        excluded_columns = (\n            {\n                \"id\",\n                \"collection_uid\",\n                \"modified_at\",\n            }\n            if not standalone\n            else set()\n        )\n        column_names = [\n            c.name for c in self.__table__.columns if c.name not in excluded_columns\n        ]\n\n        return {k: getattr(self, k) for k in column_names} | self.parameter_dict\n\n    @property\n    def parameter_dict(self) -> Dict[str, Any]:\n        \"\"\"Return a dictionary of parameters associated with the simulation.\"\"\"\n        return {p.key: p.value for p in self.parameters}",
              "inherited_members": {}
            },
            "ParameterORM": {
              "name": "ParameterORM",
              "path": "bamboost.index.sqlmodel.ParameterORM",
              "description": "ORM model representing a parameter associated with a simulation.",
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost.constants.TABLENAME_PARAMETERS"
                },
                {
                  "name": "__table_args__",
                  "annotation": null,
                  "description": null,
                  "value": "(sqlalchemy.UniqueConstraint('simulation_id', 'key', name='uix_simulation_key'),)"
                },
                {
                  "name": "id",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Unique parameter ID (primary key)"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[int]",
                  "value": "mapped_column(primary_key=True, autoincrement=True)"
                },
                {
                  "name": "simulation_id",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Foreign key linking to `bamboost.index.sqlmodel.SimulationORM`"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[int]",
                  "value": "mapped_column(ForeignKey(SimulationORM.id), nullable=False)"
                },
                {
                  "name": "key",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Parameter key (name)"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[str]",
                  "value": "mapped_column(String, nullable=False)"
                },
                {
                  "name": "value",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Parameter value (stored as JSON)"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[sqlalchemy.JSON]",
                  "value": "mapped_column(JSON, nullable=False)"
                },
                {
                  "name": "simulation",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Relationship to the parent simulation"
                    }
                  ],
                  "annotation": "sqlalchemy.orm.Mapped[bamboost.index.sqlmodel.SimulationORM]",
                  "value": "relationship('SimulationORM', back_populates='parameters')"
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.ParameterORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Parameter {self.key} = {self.value} [id: {self.id}]\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.ParameterORM.upsert",
                  "signature": "(cls, data) -> Insert",
                  "description": "Generate an upsert (insert or update) statement.",
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "typing.Sequence[bamboost.index.sqlmodel.ParameterORM._dataT] | bamboost.index.sqlmodel.ParameterORM._dataT",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Data to upsert, either a single record or a sequence of records."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.Insert",
                    "description": "Insert statement with conflict resolution."
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[_dataT] | _dataT) -> Insert:\n    \"\"\"Generate an upsert (insert or update) statement.\n\n    Args:\n        data: Data to upsert, either a single record or a sequence of records.\n\n    Returns:\n        Insert statement with conflict resolution.\n    \"\"\"\n    stmt = insert(cls).values(data)\n    return stmt.on_conflict_do_update(\n        [\"simulation_id\", \"key\"], set_=dict(value=stmt.excluded.value)\n    )"
                }
              },
              "source": "class ParameterORM(_Base):\n    \"\"\"ORM model representing a parameter associated with a simulation.\n\n    Attributes:\n        id: Unique parameter ID (primary key)\n        simulation_id: Foreign key linking to `bamboost.index.sqlmodel.SimulationORM`\n        key: Parameter key (name)\n        value: Parameter value (stored as JSON)\n        simulation: Relationship to the parent simulation\n    \"\"\"\n\n    __tablename__ = TABLENAME_PARAMETERS\n    __table_args__ = (\n        UniqueConstraint(\"simulation_id\", \"key\", name=\"uix_simulation_key\"),\n    )\n\n    class _dataT(TypedDict):\n        simulation_id: int\n        key: str\n        value: Any\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n    simulation_id: Mapped[int] = mapped_column(\n        ForeignKey(SimulationORM.id), nullable=False\n    )\n    key: Mapped[str] = mapped_column(String, nullable=False)\n    value: Mapped[JSON] = mapped_column(JSON, nullable=False)\n\n    # Relationships\n    simulation: Mapped[SimulationORM] = relationship(\n        \"SimulationORM\", back_populates=\"parameters\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Parameter {self.key} = {self.value} [id: {self.id}]\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[_dataT] | _dataT) -> Insert:\n        \"\"\"Generate an upsert (insert or update) statement.\n\n        Args:\n            data: Data to upsert, either a single record or a sequence of records.\n\n        Returns:\n            Insert statement with conflict resolution.\n        \"\"\"\n        stmt = insert(cls).values(data)\n        return stmt.on_conflict_do_update(\n            [\"simulation_id\", \"key\"], set_=dict(value=stmt.excluded.value)\n        )",
              "inherited_members": {}
            }
          },
          "functions": {
            "json_serializer": {
              "name": "json_serializer",
              "path": "bamboost.index.sqlmodel.json_serializer",
              "signature": "(value) -> str",
              "description": "Convert a value to a JSON string.",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "typing.Any",
                  "description": [
                    {
                      "kind": "text",
                      "value": "value to convert"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "str",
                "annotation": "str",
                "description": "JSON string"
              },
              "docstring": [],
              "source": "def json_serializer(value: Any) -> str:\n    \"\"\"Convert a value to a JSON string.\n\n    Args:\n        value: value to convert\n\n    Returns:\n        str: JSON string\n    \"\"\"\n    return json.dumps(value, cls=SqliteJSONEncoder)"
            },
            "json_deserializer": {
              "name": "json_deserializer",
              "path": "bamboost.index.sqlmodel.json_deserializer",
              "signature": "(value) -> Any",
              "description": "Convert a JSON string to a value.",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "JSON string to convert"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "Any",
                "annotation": "typing.Any",
                "description": "Converted value"
              },
              "docstring": [],
              "source": "def json_deserializer(value: str) -> Any:\n    \"\"\"Convert a JSON string to a value.\n\n    Args:\n        value: JSON string to convert\n\n    Returns:\n        Any: Converted value\n    \"\"\"\n    obj = json.loads(value)\n\n    def decode_dict(obj: dict) -> Any:\n        if \"__type__\" in obj and \"__value__\" in obj:\n            typ = obj[\"__type__\"]\n            value = obj[\"__value__\"]\n            for typ_key, decoder in _decoders.items():\n                if typ_key.__name__ == typ:\n                    return decoder(value)\n        return obj\n\n    return decode_dict(obj) if isinstance(obj, dict) else obj"
            }
          }
        }
      },
      "classes": {},
      "functions": {}
    },
    "cli": {
      "name": "cli",
      "path": "bamboost.cli",
      "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "app": {
          "name": "app",
          "path": "bamboost.cli.app",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/app.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "app",
              "annotation": null,
              "description": null,
              "value": "typer.Typer(no_args_is_help=True)"
            },
            {
              "name": "console",
              "annotation": null,
              "description": null,
              "value": "rich.get_console()"
            }
          ],
          "modules": {},
          "classes": {},
          "functions": {
            "_app_callback": {
              "name": "_app_callback",
              "path": "bamboost.cli.app._app_callback",
              "signature": "(ctx)",
              "description": "Command line interface for bamboost.\n\nYou can use this to list collections or simulations, create collections/simulations,\nand run simulations.",
              "parameters": [
                {
                  "name": "ctx",
                  "annotation": "typer.typer.Context",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.callback(context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\ndef _app_callback(ctx: typer.Context):\n    \"\"\"Command line interface for bamboost.\n\n    You can use this to list collections or simulations, create collections/simulations,\n    and run simulations.\n    \"\"\""
            },
            "list_collections": {
              "name": "list_collections",
              "path": "bamboost.cli.app.list_collections",
              "signature": "()",
              "description": "List all collections.",
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@database_cli.app.command(\"ls\")\ndef list_collections():\n    \"\"\"List all collections.\"\"\"\n    _assert_database_exists()\n    console.print(_render._list_collections())"
            },
            "list": {
              "name": "list",
              "path": "bamboost.cli.app.list",
              "signature": "(collection_uid=None, simulation_name=None, sync_fs=typer.Option(False, '--sync', '-s', help='Sync the collection with the filesystem.'))",
              "description": "List all collections, or all simulations in a specified collection. (alias: \"ls\")",
              "parameters": [
                {
                  "name": "collection_uid",
                  "annotation": "typing_extensions.Annotated[typing.Optional[str], typer.typer.Argument(autocompletion=bamboost.cli._completion.bamboost.cli._completion._get_uids_from_db, help='UID of the collection to list simulations for.')]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "simulation_name",
                  "annotation": "typing_extensions.Annotated[typing.Optional[str], typer.typer.Argument(help='Name of the simulation to display. If not provided, the collection is listed.', autocompletion=bamboost.cli._completion.bamboost.cli._completion._get_simulation_names)]",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "sync_fs",
                  "annotation": "bool",
                  "description": null,
                  "value": "typer.Option(False, '--sync', '-s', help='Sync the collection with the filesystem.')"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.command()\n@app.command(\"ls\", hidden=True)\ndef list(\n    collection_uid: Annotated[\n        Optional[str],\n        typer.Argument(\n            autocompletion=_completion._get_uids_from_db,\n            help=\"UID of the collection to list simulations for.\",\n        ),\n    ] = None,\n    simulation_name: Annotated[\n        Optional[str],\n        typer.Argument(\n            help=\"Name of the simulation to display. If not provided, the collection is listed.\",\n            autocompletion=_completion._get_simulation_names,\n        ),\n    ] = None,\n    sync_fs: bool = typer.Option(\n        False, \"--sync\", \"-s\", help=\"Sync the collection with the filesystem.\"\n    ),\n):\n    \"\"\"List all collections, or all simulations in a specified collection. (alias: \"ls\")\"\"\"\n    _assert_database_exists()\n\n    # If the user has not provided a collection UID, list all collections\n    if collection_uid is None:\n        return console.print(_render._list_collections())\n\n    with console.status(\"[bold blue]Fetching data...\", spinner=\"dots\"):\n        # if the user has provided a collection UID, list all simulations in that collection\n        # specifically handle the case where the collection is empty\n        if simulation_name is None:\n            try:\n                df = _render._list_simulations(collection_uid, sync_fs)\n            except ValueError as e:\n                return console.print(str(e), style=\"red\")\n\n            if df.empty:\n                return console.print(\n                    f\"Collection [bold]{collection_uid}[/bold] is empty.\\n\"\n                    \"[dim]If you expected something here: Use '-s' to sync the collection with the filesystem.[/dim]\"\n                )\n\n            collection_path = INDEX.query(\n                \"SELECT path FROM collections WHERE uid = ?\", (collection_uid,)\n            )[0][0]\n            return console.print(\n                f\"[dim]> Displaying collection [bold]{collection_uid}[/bold] \"\n                f\"([default]{collection_path}[/default]):\\n\",\n                df,\n            )\n\n        # if the user has provided a simulation name, display the simulation details\n        else:\n            from bamboost.index import Index\n\n            sim = Index.default.simulation(collection_uid, simulation_name)\n            if sim is None:\n                return console.print(\n                    f\"Simulation [bold]{simulation_name}[/bold] not found in collection [bold]{collection_uid}[/bold].\",\n                    style=\"red\",\n                )\n            return console.print(sim.as_dict())"
            },
            "show_config": {
              "name": "show_config",
              "path": "bamboost.cli.app.show_config",
              "signature": "(dir=typer.Option(None, '--dir', '-d', help='Directory to show the config for.'))",
              "description": "Show the active configuration.",
              "parameters": [
                {
                  "name": "dir",
                  "annotation": "typing.Optional[str]",
                  "description": null,
                  "value": "typer.Option(None, '--dir', '-d', help='Directory to show the config for.')"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.command()\ndef show_config(\n    dir: Optional[str] = typer.Option(\n        None, \"--dir\", \"-d\", help=\"Directory to show the config for.\"\n    ),\n):\n    \"\"\"Show the active configuration.\"\"\"\n    if dir:\n        from bamboost._config import _Config\n\n        config = _Config(dir)\n    else:\n        from bamboost import config\n\n    console.print(config)"
            },
            "new": {
              "name": "new",
              "path": "bamboost.cli.app.new",
              "signature": "(path) -> None",
              "description": "Create a new collection.",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "typing_extensions.Annotated[str, typer.typer.Argument(..., help='Path of the collection to create.')]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.command()\ndef new(\n    path: Annotated[str, typer.Argument(..., help=\"Path of the collection to create.\")],\n) -> None:\n    \"\"\"Create a new collection.\"\"\"\n    path_object = Path(path).resolve()\n    if path_object.exists():\n        return console.print(f\"[red]:cross_mark: Path already in use {path_object}\")\n\n    with console.status(\n        \"[bold blue]Creating new collection...\", spinner=\"dots\", spinner_style=\"blue\"\n    ):\n        from bamboost.core import Collection\n\n        coll = Collection(path_object, create_if_not_exist=True)\n        console.print(\"[green]:heavy_check_mark: New collection created\")\n        console.print(f\"[default]{'UID:':<5} {coll.uid}\")\n        console.print(f\"[default]{'Path:':<5} {coll.path}\")"
            },
            "_assert_database_exists": {
              "name": "_assert_database_exists",
              "path": "bamboost.cli.app._assert_database_exists",
              "signature": "() -> bool",
              "description": "Check if the database exists.",
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _assert_database_exists() -> bool:\n    \"\"\"Check if the database exists.\"\"\"\n    from bamboost._config import config\n\n    if config.index.databaseFile.exists():\n        return True\n\n    console.print(f\"Creating database file {config.index.databaseFile}\")\n    database_cli.scan()\n    return True"
            }
          }
        },
        "database": {
          "name": "database",
          "path": "bamboost.cli.database",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/database.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "app",
              "annotation": null,
              "description": null,
              "value": "typer.Typer(name='index', help='API for displaying and managing the collection index.')"
            },
            {
              "name": "console",
              "annotation": null,
              "description": null,
              "value": "rich.get_console()"
            }
          ],
          "modules": {},
          "classes": {},
          "functions": {
            "_app_callback": {
              "name": "_app_callback",
              "path": "bamboost.cli.database._app_callback",
              "signature": "()",
              "description": "Display the database file (project path).",
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.callback()\ndef _app_callback():\n    \"\"\"Display the database file (project path).\"\"\"\n    from bamboost import config\n\n    console.print(f\"[dim default][bold]Index file: [/bold]{config.index.databaseFile}\")\n    if config.index.isolated:\n        console.print(f\"[dim default][bold]Project: [/bold]{config.index.projectDir}\")"
            },
            "clean": {
              "name": "clean",
              "path": "bamboost.cli.database.clean",
              "signature": "()",
              "description": "Clean the index of any stale entries.",
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.command()\ndef clean():\n    \"\"\"Clean the index of any stale entries.\"\"\"\n    with console.status(\"[bold blue]Cleaning index...\", spinner=\"dots\") as status:\n        try:\n            from bamboost.index import Index\n\n            Index.default.check_integrity()\n            console.print(\"[green]:heavy_check_mark: Index cleaned.\")\n        except Exception as e:\n            console.print(f\"[bold red]Task failed: {e}\")"
            },
            "scan": {
              "name": "scan",
              "path": "bamboost.cli.database.scan",
              "signature": "()",
              "description": "Scan the search paths for collections.",
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@app.command()\ndef scan():\n    \"\"\"Scan the search paths for collections.\"\"\"\n    with console.status(\n        \"[bold blue]Scanning search paths...\", spinner=\"dots\"\n    ) as status:\n        try:\n            from bamboost.index import Index\n\n            _found_colls = Index.default.scan_for_collections()\n            console.print(\"[green]:heavy_check_mark: Index scanned.\")\n            # tab = _get_collections_table(found_colls)\n            # console.print(tab)\n        except Exception as e:\n            console.print(f\"[bold red]Task failed: {e}\")"
            }
          }
        },
        "_fast_index_query": {
          "name": "_fast_index_query",
          "path": "bamboost.cli._fast_index_query",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/_fast_index_query.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "INDEX",
              "annotation": null,
              "description": null,
              "value": "FastIndexQuery()"
            }
          ],
          "modules": {},
          "classes": {
            "FastIndexQuery": {
              "name": "FastIndexQuery",
              "path": "bamboost.cli._fast_index_query.FastIndexQuery",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "db_path",
                  "annotation": null,
                  "description": null,
                  "value": "bamboost._config.config.bamboost._config.config.index.bamboost._config.config.index.databaseFile"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._fast_index_query.FastIndexQuery.__init__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self):\n    from bamboost._config import config\n\n    self.db_path = config.index.databaseFile"
                },
                "connection": {
                  "name": "connection",
                  "path": "bamboost.cli._fast_index_query.FastIndexQuery.connection",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@contextmanager\ndef connection(self):\n    try:\n        self._conn = sqlite3.connect(self.db_path)\n        self._cursor = self._conn.cursor()\n        yield self._cursor\n    finally:\n        self._conn.close()"
                },
                "query": {
                  "name": "query",
                  "path": "bamboost.cli._fast_index_query.FastIndexQuery.query",
                  "signature": "(self, query, *args) -> list[tuple]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "query",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def query(self, query: str, *args) -> list[tuple]:\n    with self.connection() as cursor:\n        cursor.execute(query, *args)\n        return cursor.fetchall()"
                }
              },
              "source": "class FastIndexQuery:\n    def __init__(self):\n        from bamboost._config import config\n\n        self.db_path = config.index.databaseFile\n\n    @contextmanager\n    def connection(self):\n        try:\n            self._conn = sqlite3.connect(self.db_path)\n            self._cursor = self._conn.cursor()\n            yield self._cursor\n        finally:\n            self._conn.close()\n\n    def query(self, query: str, *args) -> list[tuple]:\n        with self.connection() as cursor:\n            cursor.execute(query, *args)\n            return cursor.fetchall()",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "_render": {
          "name": "_render",
          "path": "bamboost.cli._render",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/_render.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {},
          "functions": {
            "_get_collections_table": {
              "name": "_get_collections_table",
              "path": "bamboost.cli._render._get_collections_table",
              "signature": "(collections) -> Table",
              "description": null,
              "parameters": [
                {
                  "name": "collections",
                  "annotation": "typing.Iterable[tuple]",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _get_collections_table(collections: Iterable[tuple]) -> \"Table\":\n    from rich.table import Column, Table\n\n    tab = Table(\n        \"\",\n        \"UID\",\n        Column(\"Path\", style=\"blue\"),\n        title_justify=\"left\",\n        highlight=True,\n        pad_edge=False,\n        box=None,\n    )\n\n    for i, coll in enumerate(collections):\n        tab.add_row(\n            str(i), coll[0], f\"[link={coll[1].as_uri()}]{coll[1].as_posix()}[/link]\"\n        )\n\n    return tab"
            },
            "_list_collections": {
              "name": "_list_collections",
              "path": "bamboost.cli._render._list_collections",
              "signature": "() -> RenderableType",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _list_collections() -> \"RenderableType\":\n    from pathlib import Path\n\n    tab = _get_collections_table(\n        (i, Path(j)) for i, j in INDEX.query(\"SELECT * FROM collections\")\n    )\n    return tab"
            },
            "_list_simulations": {
              "name": "_list_simulations",
              "path": "bamboost.cli._render._list_simulations",
              "signature": "(collection_uid, sync=False) -> DataFrame",
              "description": null,
              "parameters": [
                {
                  "name": "collection_uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "sync",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _list_simulations(collection_uid: str, sync: bool = False) -> \"DataFrame\":\n    from datetime import datetime\n\n    from bamboost.index import Index\n\n    if sync:\n        Index.default.sync_collection(collection_uid)\n\n    coll = Index.default.collection(collection_uid)\n    if coll is None:\n        raise ValueError(f\"Collection with UID {collection_uid} not found.\")\n    tab = coll.to_pandas()\n\n    # Format datetime columns\n    for col in tab.select_dtypes(include=[\"datetime64\"]):\n        tab[col] = tab[col].apply(lambda x: datetime.strftime(x, \"%Y-%m-%d %H:%M:%S\"))\n\n    return tab"
            }
          }
        },
        "__main__": {
          "name": "__main__",
          "path": "bamboost.cli.__main__",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/__main__.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {},
          "functions": {}
        },
        "_completion": {
          "name": "_completion",
          "path": "bamboost.cli._completion",
          "filepath": "/home/florez/work/code/fumadocs-python-autodoc/apps/example/.venv/lib/python3.13/site-packages/bamboost/cli/_completion.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {},
          "functions": {
            "_get_uids_from_db": {
              "name": "_get_uids_from_db",
              "path": "bamboost.cli._completion._get_uids_from_db",
              "signature": "(_ctx, incomplete)",
              "description": "Dynamically fetch UIDs from the database.",
              "parameters": [
                {
                  "name": "_ctx",
                  "annotation": "typer.typer.Context",
                  "description": null,
                  "value": null
                },
                {
                  "name": "incomplete",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _get_uids_from_db(_ctx: typer.Context, incomplete: str):\n    \"\"\"Dynamically fetch UIDs from the database.\"\"\"\n    return [\n        row\n        for row in INDEX.query(\n            \"SELECT uid, path FROM collections WHERE uid LIKE ?\", (f\"{incomplete}%\",)\n        )\n    ]"
            },
            "_get_simulation_names": {
              "name": "_get_simulation_names",
              "path": "bamboost.cli._completion._get_simulation_names",
              "signature": "(ctx, incomplete)",
              "description": "Dynamically fetch simulation names based on the selected collection UID.",
              "parameters": [
                {
                  "name": "ctx",
                  "annotation": "typer.typer.Context",
                  "description": null,
                  "value": null
                },
                {
                  "name": "incomplete",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _get_simulation_names(ctx: typer.Context, incomplete: str):\n    \"\"\"Dynamically fetch simulation names based on the selected collection UID.\"\"\"\n    collection_uid = ctx.params.get(\n        \"collection_uid\"\n    )  # Get the currently selected collection\n    if not collection_uid:\n        return []  # No collection selected yet, no autocompletion\n\n    try:\n        names = INDEX.query(\n            \"SELECT name FROM simulations WHERE collection_uid = ? AND name LIKE ?\",\n            (collection_uid, f\"{incomplete}%\"),\n        )\n        return [row[0] for row in names]\n    except Exception:\n        return []"
            }
          }
        }
      },
      "classes": {
        "CliHandler": {
          "name": "CliHandler",
          "path": "bamboost.cli.CliHandler",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "emit": {
              "name": "emit",
              "path": "bamboost.cli.CliHandler.emit",
              "signature": "(self, record)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "record",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def emit(self, record):\n    print(record.getMessage())"
            }
          },
          "source": "class CliHandler(logging.Handler):\n    def emit(self, record):\n        print(record.getMessage())",
          "inherited_members": {}
        }
      },
      "functions": {}
    }
  },
  "classes": {},
  "functions": {
    "_add_stream_handler": {
      "name": "_add_stream_handler",
      "path": "bamboost._add_stream_handler",
      "signature": "(logger) -> None",
      "description": null,
      "parameters": [
        {
          "name": "logger",
          "annotation": "logging.logging.Logger",
          "description": null,
          "value": null
        }
      ],
      "returns": {
        "name": "",
        "annotation": null,
        "description": null
      },
      "docstring": [],
      "source": "def _add_stream_handler(logger: logging.Logger) -> None:\n    from bamboost.mpi import MPI, MPI_ON\n\n    class _LogFormatterWithRank(logging.Formatter):\n        def format(self, record):\n            record.rank = MPI.COMM_WORLD.rank\n            return super().format(record)\n\n    if MPI_ON:\n        formatter = _LogFormatterWithRank(\n            \"[%(asctime)s] %(name)s: %(levelname)s [%(rank)d] - %(message)s\",\n            style=\"%\",\n            datefmt=\"%Y-%m-%d %H:%M:%S\",\n        )\n    else:\n        formatter = logging.Formatter(\n            \"[%(asctime)s] %(name)s: %(levelname)s - %(message)s\",\n            datefmt=\"%Y-%m-%d %H:%M:%S\",\n        )\n    STREAM_HANDLER.setFormatter(formatter)\n    logger.addHandler(STREAM_HANDLER)"
    },
    "set_log_level": {
      "name": "set_log_level",
      "path": "bamboost.set_log_level",
      "signature": "(level) -> None",
      "description": null,
      "parameters": [
        {
          "name": "level",
          "annotation": "typing.Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
          "description": null,
          "value": null
        }
      ],
      "returns": {
        "name": "",
        "annotation": null,
        "description": null
      },
      "docstring": [],
      "source": "def set_log_level(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n) -> None:\n    BAMBOOST_LOGGER.setLevel(level)"
    }
  },
  "version": "0.10.0a0.post1+g5f9e493"
}